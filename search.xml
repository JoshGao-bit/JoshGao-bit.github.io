<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>MATLAB 函数 —— rcosdesign</title>
    <url>/posts/5c45edfe.html</url>
    <content><![CDATA[<p><code>rcosdesign</code>：升余弦 FIR 脉冲成型滤波器设计</p>
<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><p><code>b = rcosdesign(beta,span,sps)</code><br><code>b = rcosdesign(beta,span,sps,shape)</code></p>
<a id="more"></a>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p><code>b = rcosdesign(beta,span,sps)</code> 返回系数 <code>b</code>，该系数对应于具有由 <code>beta</code> 指定的衰减因子的平方根升余弦 FIR 滤波器。滤波器有 <code>span</code> 个符号，每个符号包含 <code>sps</code> 个样本。 滤波器的阶次，也即 <code>sps * span</code> 必须是偶数。滤波器的能量为 1。<a href="#Examples-01">举例</a></p>
<p><code>b = rcosdesign(beta,span,sps,shape)</code> 根据 <code>shape</code> 返回不同的滤波器。当 <code>shape</code> 为 <code>sqrt</code> 时，将返回根升余弦滤波器；当 <code>shape</code> 为 <code>normal</code> 时，将返回升余弦 FIR 滤波器。<a href="#Examples-02">举例</a></p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><h2 id="设计根升余弦滤波器"><a href="#设计根升余弦滤波器" class="headerlink" title="设计根升余弦滤波器"></a>设计根升余弦滤波器<span id="Examples-01"></span></h2><p>将滚降系数设为 <code>0.25</code>，波器的符号数设为 <code>6</code>，每个符号 <code>4</code> 个采样点。验证 <code>sqrt</code> 是 <code>shape</code> 参数的默认值。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">h <span class="built_in">=</span> rcosdesign(<span class="number">0.25</span>,<span class="number">6</span>,<span class="number">4</span>);</span><br><span class="line">mx <span class="built_in">=</span> max(abs(h-rcosdesign(<span class="number">0.25</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="string">&#x27;sqrt&#x27;</span>)))</span><br></pre></td></tr></table></figure>
<blockquote>
<p><font face="Consolas">mx = 0</font><br></p>
</blockquote>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">fvtool(h,<span class="string">&#x27;Analysis&#x27;</span>,<span class="string">&#x27;impulse&#x27;</span>)</span><br></pre></td></tr></table></figure>
<div align="center">
  <img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-25-matlab-rcosdesign/2020-11-25-matlab-rcosdesign-010-DesignASquareRootRaisedCosineFilterExample-01.png?imageMogr2/thumbnail/!100p|watermark/2/text/QEpvc2ggR2Fv/fontsize/15/dissolve/60/gravity/southeast/dx/5/dy/5"/>
</div>

<h2 id="升余弦和根升余弦滤波器的脉冲响应"><a href="#升余弦和根升余弦滤波器的脉冲响应" class="headerlink" title="升余弦和根升余弦滤波器的脉冲响应"></a>升余弦和根升余弦滤波器的脉冲响应<span id="Examples-02"></span></h2><p>将升余弦滤波器与根升余弦滤波器进行比较。一个理想的（无限长）升余弦脉冲成型滤波器等效于两个级联的理想的根升余弦滤波器。因此，FIR 升余弦滤波器的脉冲响应应类似于与其自身卷积的根升余弦滤波器的脉冲响应。</p>
<p>设计一个衰减为 <code>0.25</code> 的升余弦滤波器。指定滤波器有 <code>4</code> 个符号，每个符号 <code>3</code> 个采样点。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">rf <span class="built_in">=</span> <span class="number">0.25</span>;</span><br><span class="line">span <span class="built_in">=</span> <span class="number">4</span>;</span><br><span class="line">sps <span class="built_in">=</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">h1 <span class="built_in">=</span> rcosdesign(rf,span,sps,<span class="string">&#x27;normal&#x27;</span>);</span><br><span class="line">fvtool(h1,<span class="string">&#x27;impulse&#x27;</span>)</span><br></pre></td></tr></table></figure>
<div align="center">
  <img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-25-matlab-rcosdesign/2020-11-25-matlab-rcosdesign-020-ImpulseResponsesOfNormalAndSquareRootRaisedCosineFiltersExample-01.png?imageMogr2/thumbnail/!100p|watermark/2/text/QEpvc2ggR2Fv/fontsize/15/dissolve/60/gravity/southeast/dx/5/dy/5"/>
</div>

<p><strong>升余弦滤波器在 <code>sps</code> 的整数倍处具有零值点</strong>。因此，它满足无码间串扰（ISI）的 Nyquist 准则。但是，根升余弦滤波器没有这样的特性：</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">h2 <span class="built_in">=</span> rcosdesign(rf,span,sps,<span class="string">&#x27;sqrt&#x27;</span>);</span><br><span class="line">fvtool(h2,<span class="string">&#x27;impulse&#x27;</span>)</span><br></pre></td></tr></table></figure>
<div align="center">
  <img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-25-matlab-rcosdesign/2020-11-25-matlab-rcosdesign-030-ImpulseResponsesOfNormalAndSquareRootRaisedCosineFiltersExample-02.png?imageMogr2/thumbnail/!100p|watermark/2/text/QEpvc2ggR2Fv/fontsize/15/dissolve/60/gravity/southeast/dx/5/dy/5"/>
</div>

<p>将根升余弦滤波器与自身进行卷积。在最大值处截断脉冲响应，使其长度与 <code>h1</code> 相同。使用最大值将响应归一化。然后，将卷积后的根升余弦滤波器与升余弦滤波器进行比较。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">h3 <span class="built_in">=</span> conv(h2,h2);</span><br><span class="line">p2 <span class="built_in">=</span> ceil(length(h3)/<span class="number">2</span>);</span><br><span class="line">m2 <span class="built_in">=</span> ceil(p2-length(h1)/<span class="number">2</span>);</span><br><span class="line">M2 <span class="built_in">=</span> floor(p2+length(h1)/<span class="number">2</span>);</span><br><span class="line">ct <span class="built_in">=</span> h3(m2:M2);</span><br><span class="line"></span><br><span class="line">stem([h1/max(abs(h1));ct/max(abs(ct))]<span class="string">&#x27;,&#x27;</span>filled<span class="string">&#x27;)</span></span><br><span class="line"><span class="string">xlabel(&#x27;</span>Samples<span class="string">&#x27;)</span></span><br><span class="line"><span class="string">ylabel(&#x27;</span>Normalized amplitude<span class="string">&#x27;)</span></span><br><span class="line"><span class="string">legend(&#x27;</span>h1<span class="string">&#x27;,&#x27;</span>h2 * h2<span class="string">&#x27;)</span></span><br></pre></td></tr></table></figure>
<div align="center">
  <img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-25-matlab-rcosdesign/2020-11-25-matlab-rcosdesign-040-ImpulseResponsesOfNormalAndSquareRootRaisedCosineFiltersExample-03.png?imageMogr2/thumbnail/!100p|watermark/2/text/QEpvc2ggR2Fv/fontsize/15/dissolve/60/gravity/southeast/dx/5/dy/5"/>
</div>

<p>卷积响应的长度是有限的，因此根升余弦滤波器与自身进行卷积得到的结果会与升余弦滤波器不一致。增加 <code>span</code> 可以在响应之间获得更紧密的一致性，并更好地符合 Nyquist 准则。</p>
<h2 id="将信号通过升余弦滤波器"><a href="#将信号通过升余弦滤波器" class="headerlink" title="将信号通过升余弦滤波器"></a>将信号通过升余弦滤波器<span id="Examples-03"></span></h2><p>本例说明如何将信号通过根升余弦滤波器。</p>
<p>指定滤波器参数。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">rolloff <span class="built_in">=</span> <span class="number">0.25</span>;     <span class="comment">% 滚降因子</span></span><br><span class="line">span <span class="built_in">=</span> <span class="number">6</span>;           <span class="comment">% 滤波器宽度（符号数）</span></span><br><span class="line">sps <span class="built_in">=</span> <span class="number">4</span>;            <span class="comment">% 每个符号的样本数</span></span><br></pre></td></tr></table></figure>
<p>生成根升余弦滤波器的系数。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">b <span class="built_in">=</span> rcosdesign(rolloff, span, sps);</span><br></pre></td></tr></table></figure>
<p>生成双极性数据向量。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">d <span class="built_in">=</span> <span class="number">2</span>*randi([<span class="number">0</span> <span class="number">1</span>], <span class="number">100</span>, <span class="number">1</span>) - <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>上采样并对数据进行滤波以实现脉冲成型。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">x <span class="built_in">=</span> upfirdn(d, b, sps);</span><br></pre></td></tr></table></figure>
<p>添加噪声。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">r <span class="built_in">=</span> x + randn(size(x))*<span class="number">0.01</span>;</span><br></pre></td></tr></table></figure>
<p>对接收到的信号进行滤波和下采样以进行匹配滤波。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">y <span class="built_in">=</span> upfirdn(r, b, <span class="number">1</span>, sps);</span><br></pre></td></tr></table></figure>
<p>有关如何使用根升余弦滤波器对信号进行插值和抽取的信息，请参见使<a href="https://ww2.mathworks.cn/help/comm/ug/interpolate-and-decimate-using-rrc-filter.html">用 RRC 滤波器进行插值和抽取</a>（Communications Toolbox）。</p>
<h1 id="输入参数"><a href="#输入参数" class="headerlink" title="输入参数"></a>输入参数</h1><h2 id="beta-滚降系数"><a href="#beta-滚降系数" class="headerlink" title="beta - 滚降系数"></a><code>beta</code> - 滚降系数</h2><p>滚降系数，指定为不大于 <code>1</code> 的<strong>实非负标量</strong>。滚降系数决定滤波器的多余带宽。滚降系数为 <code>0</code> 时为矩形滤波器（brick-wall filter），滚降因子为 <code>1</code> 时为纯升余弦滤波器。</p>
<p><strong>数据类型</strong>：<code>double</code> | <code>single</code></p>
<h2 id="span-符号数"><a href="#span-符号数" class="headerlink" title="span - 符号数"></a><code>span</code> - 符号数</h2><p>符号数，指定为<strong>正整数标量</strong>。</p>
<p><strong>数据类型</strong>：<code>double</code> | <code>single</code></p>
<h2 id="sps-每个符号的样本数"><a href="#sps-每个符号的样本数" class="headerlink" title="sps - 每个符号的样本数"></a><code>sps</code> - 每个符号的样本数</h2><p>每个符号的样本数（上采样因子），指定为<strong>正整数标量</strong>。</p>
<p><strong>数据类型</strong>：<code>double</code> | <code>single</code></p>
<h2 id="shape-升余弦滤波器的形状"><a href="#shape-升余弦滤波器的形状" class="headerlink" title="shape - 升余弦滤波器的形状"></a><code>shape</code> - 升余弦滤波器的形状</h2><p>升余弦滤波器的形状，指定为 <code>normal</code> 或 <code>sqrt</code>。</p>
<h1 id="输出参数"><a href="#输出参数" class="headerlink" title="输出参数"></a>输出参数</h1><h2 id="b-FIR-滤波器系数"><a href="#b-FIR-滤波器系数" class="headerlink" title="b - FIR 滤波器系数"></a><code>b</code> - FIR 滤波器系数</h2><p>升余弦滤波器的系数，以<strong>列向量</strong>的形式返回。</p>
<p><strong>数据类型</strong>：<code>double</code> | <code>single</code></p>
<h1 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h1><ul>
<li>如果您拥有 Communications Toolbox™ 软件的许可证，则可以执行具有流传输行为的多速率升余弦滤波。为此，请使用 System object™ 滤波器——<code>comm.RaisedCosineTransmitFilter</code> 和 <code>comm.RaisedCosineReceiveFilter</code>。</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>[1] Tranter, William H., K. Sam Shanmugan, Theodore S. Rappaport, and Kurt L. Kosbar. <em>Principles of Communication Systems Simulation with Wireless Applications.</em> Upper Saddle River, NJ: Prentice Hall, 2004.</p>
<h1 id="扩展功能"><a href="#扩展功能" class="headerlink" title="扩展功能"></a>扩展功能</h1><h2 id="C-C-代码生成"><a href="#C-C-代码生成" class="headerlink" title="C/C++ 代码生成"></a>C/C++ 代码生成</h2><blockquote>
<p>使用 MATLAB® Coder™ 生成 C 代码和 C++ 代码。</p>
<blockquote>
<p>用法说明和限制：</p>
<p>所有输入必须为常数。 如果表达式或变量的值不变，则也允许使用。</p>
</blockquote>
</blockquote>
<h1 id="另请参阅"><a href="#另请参阅" class="headerlink" title="另请参阅"></a>另请参阅</h1><p><a href="https://ww2.mathworks.cn/help/signal/ref/gaussdesign.html"><code>gaussdesign</code></a></p>
<h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p><a href="https://ww2.mathworks.cn/help/comm/ug/interpolate-and-decimate-using-rrc-filter.html">用 RRC 滤波器进行插值和抽取</a>（Communications Toolbox）</p>
<hr>
<p>在 R2013b 中推出</p>
<hr>
<p>原文参考：<a href="https://ww2.mathworks.cn/help/signal/ref/rcosdesign.html">https://ww2.mathworks.cn/help/signal/ref/rcosdesign.html</a></p>
]]></content>
      <categories>
        <category>MATLAB</category>
        <category>翻译</category>
        <category>帮助文档</category>
      </categories>
      <tags>
        <tag>MATLAB</tag>
        <tag>翻译</tag>
        <tag>成型滤波器</tag>
        <tag>滤波器</tag>
      </tags>
  </entry>
  <entry>
    <title>MATLAB 函数 —— gaussdesign</title>
    <url>/posts/a2967b00.html</url>
    <content><![CDATA[<p><code>gaussdesign</code>：高斯 FIR 脉冲成型滤波器设计</p>
<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><p><code>h = gaussdesign(bt,span,sps)</code></p>
<a id="more"></a>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p><code>h = gaussdesign(bt,span,sps)</code> 设计一个低通 FIR 高斯脉冲成型滤波器，并返回滤波器系数向量 <code>h</code>。滤波器有 <code>span</code> 个符号，每个符号包含 <code>sps</code> 个样本。滤波器的阶次，也即 <code>sps * span</code> 必须是偶数。<a href="#Examples-01">举例</a></p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><h2 id="GSM-GMSK-数字蜂窝通信系统的高斯滤波器"><a href="#GSM-GMSK-数字蜂窝通信系统的高斯滤波器" class="headerlink" title="GSM GMSK 数字蜂窝通信系统的高斯滤波器"></a>GSM GMSK 数字蜂窝通信系统的高斯滤波器<span id="Examples-01"></span></h2><p>指定用于传输比特位的调制是高斯最小频移键控（GMSK）脉冲。此脉冲的 3-dB 带宽等于比特率的 <code>0.3</code> 倍，滤波器的符号数为 <code>4</code>，每个符号 <code>8</code> 个采样点。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">bt <span class="built_in">=</span> <span class="number">0.3</span>;</span><br><span class="line">span <span class="built_in">=</span> <span class="number">4</span>;</span><br><span class="line">sps <span class="built_in">=</span> <span class="number">8</span>;</span><br><span class="line">h <span class="built_in">=</span> gaussdesign(bt,span,sps);</span><br><span class="line">fvtool(h,<span class="string">&#x27;impulse&#x27;</span>)</span><br></pre></td></tr></table></figure>
<div align="center">
  <img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-26-matlab-gaussdesign/2020-11-26-matlab-gaussdesign-010-GaussianFilterForAGSMGMSKDigitalCellularCommunicationSysExample-01.png?imageMogr2/thumbnail/!100p|watermark/2/text/QEpvc2ggR2Fv/fontsize/15/dissolve/60/gravity/southeast/dx/5/dy/5"/>
</div>

<h1 id="输入参数"><a href="#输入参数" class="headerlink" title="输入参数"></a>输入参数</h1><h2 id="bt-3-dB带宽符号时间积"><a href="#bt-3-dB带宽符号时间积" class="headerlink" title="bt - 3-dB带宽符号时间积"></a><code>bt</code> - 3-dB带宽符号时间积</h2><p>3-dB 单边带带宽（以 Hz 为单位）和符号时间（以秒为单位）的乘积，指定为<strong>正实标量</strong>。较小的 <code>bt</code> 值会产生较大的脉冲宽度。</p>
<p><strong>数据类型</strong>：<code>double</code> | <code>single</code></p>
<h2 id="span-符号数"><a href="#span-符号数" class="headerlink" title="span - 符号数"></a><code>span</code> - 符号数</h2><p>符号数，指定为<strong>正整数标量</strong>（默认为 3）。</p>
<p><strong>数据类型</strong>：<code>double</code> | <code>single</code></p>
<h2 id="sps-每个符号的样本数"><a href="#sps-每个符号的样本数" class="headerlink" title="sps - 每个符号的样本数"></a><code>sps</code> - 每个符号的样本数</h2><p>每个符号周期的样本数（上采样因子），指定为<strong>正整数标量</strong>（默认为 2）。</p>
<p><strong>数据类型</strong>：<code>double</code> | <code>single</code></p>
<h1 id="输出参数"><a href="#输出参数" class="headerlink" title="输出参数"></a>输出参数</h1><h2 id="h-FIR-滤波器系数"><a href="#h-FIR-滤波器系数" class="headerlink" title="h - FIR 滤波器系数"></a><code>h</code> - FIR 滤波器系数</h2><p>高斯脉冲成型滤波器的 FIR 系数，以<strong>行向量</strong>的形式返回。系数已被归一化，因此标称通带增益始终为 1。</p>
<p><strong>数据类型</strong>：<code>double</code> | <code>single</code></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>[1] Krishnapura, N., S. Pavan, C. Mathiazhagan, and B. Ramamurthi. “A baseband pulse shaping filter for Gaussian minimum shift keying.” <em>Proceedings of the 1998 IEEE International Symposium on Circuits and Systems</em>. Vol. 1, 1998, pp. 249–252.</p>
<p>[2] Rappaport, Theodore S. <em>Wireless Communications: Principles and Practice.</em> 2nd Ed. Upper Saddle River, NJ: Prentice Hall, 2002.</p>
<h1 id="另请参阅"><a href="#另请参阅" class="headerlink" title="另请参阅"></a>另请参阅</h1><p><a href="https://ww2.mathworks.cn/help/signal/ref/rcosdesign.html"><code>rcosdesign</code></a></p>
<hr>
<p>在 R2013b 中推出</p>
<hr>
<p>原文参考：<a href="https://ww2.mathworks.cn/help/signal/ref/gaussdesign.html">https://ww2.mathworks.cn/help/signal/ref/gaussdesign.html</a></p>
]]></content>
      <categories>
        <category>MATLAB</category>
        <category>翻译</category>
        <category>帮助文档</category>
      </categories>
      <tags>
        <tag>MATLAB</tag>
        <tag>翻译</tag>
        <tag>成型滤波器</tag>
        <tag>滤波器</tag>
      </tags>
  </entry>
  <entry>
    <title>MATLAB 函数 —— upsample（Signal Processing Toolbox）</title>
    <url>/posts/3a606c9c.html</url>
    <content><![CDATA[<p><code>upsample</code>：将采样率提高整数倍</p>
<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><p><code>y = upsample(x,n)</code><br><code>y = upsample(x,n,phase)</code></p>
<a id="more"></a>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p><code>y = upsample(x,n)</code> 通过在样本之间插入 <code>n - 1</code>个零来增加 <code>x</code> 的采样率。如果 <code>x</code> 是矩阵，则该函数将每一列视为单独的序列。<a href="#Examples-01">举例</a></p>
<p><code>y = upsample(x,n,phase)</code> 指定未采样序列所偏移的样本数。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><h2 id="提高采样率"><a href="#提高采样率" class="headerlink" title="提高采样率"></a>提高采样率<span id="Examples-01"></span></h2><p>将序列的采样率提高 <code>3</code> 倍。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">x <span class="built_in">=</span> [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>];</span><br><span class="line">y <span class="built_in">=</span> upsample(x,<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">y &#x3D; 1×12</span><br><span class="line"></span><br><span class="line">    1     0     0     2     0     0     3     0     0     4     0     0</span><br></pre></td></tr></table></figure>
<p>将序列的采样率增加 <code>3</code> 倍，并将相位偏移增加 <code>2</code>。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">x <span class="built_in">=</span> [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>];</span><br><span class="line">y <span class="built_in">=</span> upsample(x,<span class="number">3</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">y &#x3D; 1×12</span><br><span class="line"></span><br><span class="line">    0     0     1     0     0     2     0     0     3     0     0     4     0</span><br></pre></td></tr></table></figure>
<p>将矩阵的采样率提高3倍。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">x <span class="built_in">=</span> [<span class="number">1</span> <span class="number">2</span>;</span><br><span class="line">     <span class="number">3</span> <span class="number">4</span>;</span><br><span class="line">     <span class="number">5</span> <span class="number">6</span>];</span><br><span class="line">y <span class="built_in">=</span> upsample(x,<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">y &#x3D; 9×2</span><br><span class="line"></span><br><span class="line">    1     2</span><br><span class="line">    0     0</span><br><span class="line">    0     0</span><br><span class="line">    3     4</span><br><span class="line">    0     0</span><br><span class="line">    0     0</span><br><span class="line">    5     6</span><br><span class="line">    0     0</span><br><span class="line">    0     0</span><br></pre></td></tr></table></figure>
<h1 id="输入参数"><a href="#输入参数" class="headerlink" title="输入参数"></a>输入参数</h1><h2 id="x-输入数组"><a href="#x-输入数组" class="headerlink" title="x - 输入数组"></a><code>x</code> - 输入数组</h2><p>输入数组，指定为<strong>向量</strong>或<strong>矩阵</strong>。如果 <code>x</code> 是矩阵，该函数会将不同列向量视为独立的通道。</p>
<p><strong>举例</strong>：<code>cos(pi/4*(0:159)) + randn(1,160)</code> 指定加有高斯白噪声的正弦曲线。</p>
<p><strong>举例</strong>：<code>cos(pi./[4;2]*(0:159))&#39; + randn(160,2)</code> 指定一个两通道的正弦波。</p>
<h2 id="n-上采样因子"><a href="#n-上采样因子" class="headerlink" title="n - 上采样因子"></a><code>n</code> - 上采样因子</h2><p>上采样因子，指定为<strong>正整数</strong>。</p>
<p><strong>数据类型</strong>：<code>single</code> | <code>double</code></p>
<h2 id="phase-偏移量"><a href="#phase-偏移量" class="headerlink" title="phase - 偏移量"></a><code>phase</code> - 偏移量</h2><p>偏移量，指定为从 <code>0</code> 到 <code>n - 1</code> 的<strong>正整数</strong>。默认为 <code>0</code>。</p>
<p><strong>数据类型</strong>：<code>single</code> | <code>double</code></p>
<h1 id="输出参数"><a href="#输出参数" class="headerlink" title="输出参数"></a>输出参数</h1><h2 id="y-上采样数组"><a href="#y-上采样数组" class="headerlink" title="y - 上采样数组"></a><code>y</code> - 上采样数组</h2><p>上采样数组，以<strong>向量</strong>或<strong>矩阵</strong>的形式返回。<code>y</code> 有 <code>x × n</code> 个样本。</p>
<h1 id="扩展功能"><a href="#扩展功能" class="headerlink" title="扩展功能"></a>扩展功能</h1><h2 id="C-C-代码生成"><a href="#C-C-代码生成" class="headerlink" title="C/C++ 代码生成"></a>C/C++ 代码生成</h2><blockquote>
<p>使用 MATLAB® Coder™ 生成 C 代码和 C++ 代码。</p>
</blockquote>
<h1 id="另请参阅"><a href="#另请参阅" class="headerlink" title="另请参阅"></a>另请参阅</h1><p><a href="https://ww2.mathworks.cn/help/signal/ref/decimate.html"><code>decimate</code></a> | <a href="https://ww2.mathworks.cn/help/signal/ref/downsample.html"><code>downsample</code></a> | <a href="https://ww2.mathworks.cn/help/signal/ref/interp.html"><code>interp</code></a> | <a href="https://ww2.mathworks.cn/help/matlab/ref/interp1.html"><code>interp1</code></a> | <a href="https://ww2.mathworks.cn/help/signal/ref/resample.html"><code>resample</code></a> | <a href="https://ww2.mathworks.cn/help/matlab/ref/spline.html"><code>spline</code></a> | <a href="https://ww2.mathworks.cn/help/signal/ref/upfirdn.html"><code>upfirdn</code></a></p>
<hr>
<p>在 R2006a 之前推出</p>
<hr>
<p>原文参考：<a href="https://ww2.mathworks.cn/help/signal/ref/upsample.html">https://ww2.mathworks.cn/help/signal/ref/upsample.html</a></p>
]]></content>
      <categories>
        <category>MATLAB</category>
        <category>翻译</category>
        <category>帮助文档</category>
      </categories>
      <tags>
        <tag>MATLAB</tag>
        <tag>翻译</tag>
        <tag>上采样</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo NexT 主题不蒜子相关问题汇总</title>
    <url>/posts/e96c9b26.html</url>
    <content><![CDATA[<h1 id="什么是不蒜子"><a href="#什么是不蒜子" class="headerlink" title="什么是不蒜子"></a>什么是不蒜子</h1><p><a href="https://busuanzi.ibruce.info/">不蒜子</a>是 <a href="http://ibruce.info/">Bruce</a> 开发的一款轻量级的网页计数器，可以将网站访问计数直接显示在网页上。</p>
<h1 id="启用不蒜子"><a href="#启用不蒜子" class="headerlink" title="启用不蒜子"></a>启用不蒜子</h1><p>NexT 预置了不蒜子提供的网页计数功能。只需要在配置文件中启用即可。</p>
<figure class="highlight yaml"><figcaption><span>next/_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># Show Views / Visitors of the website / page with busuanzi.</span></span><br><span class="line"><span class="comment"># Get more information on http://ibruce.info/2015/04/04/busuanzi</span></span><br><span class="line"><span class="attr">busuanzi_count:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span>                          <span class="comment"># 启用不蒜子</span></span><br><span class="line">  <span class="attr">total_visitors:</span> <span class="literal">true</span>                  <span class="comment"># 网站总访客数</span></span><br><span class="line">  <span class="attr">total_visitors_icon:</span> <span class="string">fa</span> <span class="string">fa-user</span></span><br><span class="line">  <span class="attr">total_views:</span> <span class="literal">true</span>                     <span class="comment"># 网站总浏览数</span></span><br><span class="line">  <span class="attr">total_views_icon:</span> <span class="string">fa</span> <span class="string">fa-eye</span></span><br><span class="line">  <span class="attr">post_views:</span> <span class="literal">true</span>                      <span class="comment"># 文章浏览数</span></span><br><span class="line">  <span class="attr">post_views_icon:</span> <span class="string">fa</span> <span class="string">fa-eye</span></span><br></pre></td></tr></table></figure>
<h1 id="不蒜子和-Live2D-冲突的问题"><a href="#不蒜子和-Live2D-冲突的问题" class="headerlink" title="不蒜子和 Live2D 冲突的问题"></a>不蒜子和 Live2D 冲突的问题</h1><a id="more"></a>
<blockquote>
<p>Hexo 版本：5.2.0<br>NexT 版本：8.0.2<br>不蒜子版本: 2.3</p>
</blockquote>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>添加 Live2D 前的不蒜子显示情况如下。</p>
<div align="center">
  <img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-27-hexo-next-busuanzi-issues/2020-11-27-hexo-next-busuanzi-issues-010-Live2D-01.png?imageMogr2/thumbnail/!100p|watermark/2/text/QEpvc2ggR2Fv/fontsize/15/dissolve/60/gravity/southeast/dx/5/dy/5"/>
</div>

<div align="center">
  <img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-27-hexo-next-busuanzi-issues/2020-11-27-hexo-next-busuanzi-issues-020-Live2D-02.png?imageMogr2/thumbnail/!100p|watermark/2/text/QEpvc2ggR2Fv/fontsize/15/dissolve/60/gravity/southeast/dx/5/dy/5"/>
</div>

<p>添加 Live2D 后，不蒜子在页面中不显示。</p>
<div align="center">
  <img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-27-hexo-next-busuanzi-issues/2020-11-27-hexo-next-busuanzi-issues-030-Live2D-03.png?imageMogr2/thumbnail/!100p|watermark/2/text/QEpvc2ggR2Fv/fontsize/15/dissolve/60/gravity/southeast/dx/5/dy/5"/>
</div>

<div align="center">
  <img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-27-hexo-next-busuanzi-issues/2020-11-27-hexo-next-busuanzi-issues-040-Live2D-04.png?imageMogr2/thumbnail/!100p|watermark/2/text/QEpvc2ggR2Fv/fontsize/15/dissolve/60/gravity/southeast/dx/5/dy/5"/>
</div>

<h2 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h2><p>经查，添加 Live2D 后网页的不蒜子部分源码的 <code>style</code> 从 <code>&quot;display: inline;&quot;</code> 替换为了 <code>&quot;display: none;&quot;</code>。</p>
<figure class="highlight html"><figcaption><span>不蒜子不正常显示的网页源码</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item&quot;</span> <span class="attr">title</span>=<span class="string">&quot;阅读次数&quot;</span> <span class="attr">id</span>=<span class="string">&quot;busuanzi_container_page_pv&quot;</span> <span class="attr">style</span>=<span class="string">&quot;display: none;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item-icon&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fa fa-eye&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item-text&quot;</span>&gt;</span> 阅读次数：<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;busuanzi_value_page_pv&quot;</span>&gt;</span>19<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight html"><figcaption><span>不蒜子正常显示的网页源码</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item&quot;</span> <span class="attr">title</span>=<span class="string">&quot;阅读次数&quot;</span> <span class="attr">id</span>=<span class="string">&quot;busuanzi_container_page_pv&quot;</span> <span class="attr">style</span>=<span class="string">&quot;display: inline;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item-icon&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fa fa-eye&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item-text&quot;</span>&gt;</span> 阅读次数：<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;busuanzi_value_page_pv&quot;</span>&gt;</span>18<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>在网页生成引擎中修改代码，去掉不蒜子部分的 <code>id</code> 和 <code>style</code> 属性，重新生成网页即可解决该问题。若将 <code>class</code> 属性一并删除，会导不蒜子部分和前面的其他显示部分缺少分隔符，如下图。</p>
<div align="center">
  <img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-27-hexo-next-busuanzi-issues/2020-11-27-hexo-next-busuanzi-issues-050-Delimeter-01.png?imageMogr2/thumbnail/!100p|watermark/2/text/QEpvc2ggR2Fv/fontsize/15/dissolve/60/gravity/southeast/dx/5/dy/5"/>
</div>

<p>具体需要修改两个文件，<code>next/layout/_third-party/statistics/busuanzi-counter.swig</code> 中修改的是网页页脚部分的不蒜子显示，<code>next/layout/_macro/post.swig</code> 中修改的博客文章阅览数的不蒜子显示。</p>
<figure class="highlight html"><figcaption><span>next/layout/_third-party/statistics/busuanzi-counter.swig</span></figcaption><table><tr><td class="code"><pre><span class="line">&#123;%- if theme.busuanzi_count.total_visitors %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item&quot;</span> <span class="attr">id</span>=<span class="string">&quot;busuanzi_container_site_uv&quot;</span> <span class="attr">style</span>=<span class="string">&quot;display: none;&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">&#123;%- endif %&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line"></span><br><span class="line">&#123;%- if theme.busuanzi_count.total_views %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item&quot;</span> <span class="attr">id</span>=<span class="string">&quot;busuanzi_container_site_pv&quot;</span> <span class="attr">style</span>=<span class="string">&quot;display: none;&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">&#123;%- endif %&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><figcaption><span>next/layout/_macro/post.swig</span></figcaption><table><tr><td class="code"><pre><span class="line">&#123;%- if not is_index and theme.busuanzi_count.enable and theme.busuanzi_count.post_views %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item&quot;</span> <span class="attr">title</span>=<span class="string">&quot;&#123;&#123; __(&#x27;post.views&#x27;) &#125;&#125;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;busuanzi_container_page_pv&quot;</span> <span class="attr">style</span>=<span class="string">&quot;display: none;&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">&#123;%- endif %&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Blog</category>
        <category>Hexo</category>
        <category>Next</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title>Josh 的学习笔记之 Verilog（Part 1 —— 初识 HDL 设计方法）</title>
    <url>/posts/460433dd.html</url>
    <content><![CDATA[<p>本文阐述了 HDL 语言/设计方法的基本概念。主要介绍了数字系统建模方法的演变，引入了 HDL 语言的基本概念，对 Verilog HDL 和 VHDL、Verilog HDL 和 C 的联系与区别进行了说明，在最后引入了 HDL 的设计和验证流程，并对各个流程进行了简单介绍。</p>
<h1 id="1-设计方法的变迁"><a href="#1-设计方法的变迁" class="headerlink" title="1. 设计方法的变迁"></a>1. 设计方法的变迁<a name="01"></a></h1><p>随着微电子设计技术与工艺的发展，数字集成电路从电子管、晶体管、中小规模集成电路、超大规模集成电路（Very Large Scale Integrated Circuit, VLSIC）逐步发展到今天的专用集成电路（Application Specific Integrated Circuit, ASIC），愈发数字化的产品如计算机、手机、数字电视等都运用了复杂的专用数字集成电路。数字逻辑器件从简单的逻辑门到复杂的 SoC，种类繁多，提供了对复杂系统的灵活支撑。</p>
<a id="more"></a>
<p>随着数字电路系统的不断发展，系统的逻辑复杂度与规模日益增加，数字系统的设计方法也随之不断演进。早期简单的门逻辑设计阶段，EDA 工具应用范围十分有限，工程师们习惯于使用<strong><span class="label default">卡诺图</span></strong>简化设计，然后通过面包板等实验系统验证设计；系统相对复杂后，工程师们借助 EDA 工具通过原理图描述数字系统。</p>
<div class="note default">
            <p>原理图由元件库中的元件构成，使用 EDA（Electronic Design Automation，电子设计自动化）工具可以对原理图进行仿真并分析其性能。</p>
          </div>
<p>当数字系统发展到 ASIC 与 PLD（Programmable Logic Device，可编程逻辑器件） 设计阶段后，原理图不利于移植、维护费时费力等缺点逐步显现，这时需要抽象度更高、更灵活的设计方式 —— HDL（Hardware Description Language，硬件描述语言）。</p>
<p>使用 HDL 语言，可以从算法、系统级（System Level）、功能模块级（Functional Model Level）、行为级（Behavioral Level）、寄存器传输级（RTL, Register Transfer Level）、门级（Gate Level）到开关级（Switch Level）等不同层次描述数字电路系统，然后通过 EDA 工具综合、仿真并实现该系统。可以说 HDL 语言的出现是数字系统设计方法的一个重大飞跃。</p>
<p>数字电路系统设计方法的另一个重大飞跃是随着 EDA 工具的不断推陈出新发生的。早期 ASIC 和 PLD 设计时，人们需要直接描述 CMOS 的开关电路或门级电路，其设计量庞大，仿真速度也非常慢，像当今系统门数量为千万门级的 FPGA 用开关级或门级方法描述在当时是不可想象的。这时人们就希望能够使用 HDL 直接从更高的层次描述电路，然后使用 EDA 工具自动将高层次的 HDL 电路描述解析到门级，这些将大大节约设计与仿真时间，这个<strong><span class="label default">从高层次的电路描述通过 EDA 工具解析到门级等低层次的电路描述的过程就叫“综合”（Synthesize），或者逻辑综合</span></strong>。</p>
<div class="note default">
            <p>综合工具能将高层次的 HDL 语言、原理图等设计描述翻译成由与、或、非门等基本逻辑单元组成的门级连接（<strong>网表</strong>）并根据设计目标与要求（约束条件）优化所生成的逻辑连接，输出门级网表文件。</p>
          </div>
<p>目前最成熟的综合工具是 RTL 级综合工具，它能将 RTL 级描述翻译并优化为门级网表。综合工具的产生支撑了直接从 RTL 级描述硬件电路，这种从门级描述抽象到 RTL 级描述数字电路是设计方法的又一次伟大飞跃。</p>
<p>从上面描述可以看到 HDL 语言是分层次的，关于上述 HDL 语言设计层次的含义在 <a href="#03">3. HDL 的设计与验证流程</a>小节和 <a href="https://josh-gao.blog.csdn.net/article/details/105262549#5__1023">《Part 3——描述方式和设计层次》的 5. 设计层次</a>小节有详细论述。)</p>
<h1 id="2-Verilog-语言的特点"><a href="#2-Verilog-语言的特点" class="headerlink" title="2. Verilog 语言的特点"></a>2. Verilog 语言的特点<a name="02"></a></h1><h2 id="2-1-Verilog-的由来"><a href="#2-1-Verilog-的由来" class="headerlink" title="2.1. Verilog 的由来"></a>2.1. Verilog 的由来</h2><p>Verilog 是 Verilog HDL 的简称。</p>
<div class="note info">
            <p>Verilog 语言最初于1983年由 Gateway Design Automation 公司开发，于1995年接受为 IEEE 标准。</p>
          </div>
<p>Verilog 语言不仅定义了语法，而且对每个语法结构都清晰定义了仿真语义，从而便于仿真调试。而且 Verilog 从 C 语言继承了很多操作符和语法结构，对初学者而言易学易用。另外 Verilog 语言具有很强的扩展能力，最新的 Verilog 2001 标准<sup><a href="#fn_1" id="reffn_1">1</a></sup>大大扩展了 Verilog 的应用灵活性。</p>
<p>另外一个流行的 HDL 语言是 VHDL，其发展初期受到美国国防部支持，并于 1987 年成为 IEEE 标准。VHDL 语言的特点是描述严谨。</p>
<h2 id="2-2-Verilog-和-VHDL"><a href="#2-2-Verilog-和-VHDL" class="headerlink" title="2.2. Verilog 和 VHDL"></a>2.2. Verilog 和 VHDL</h2><p>Verilog 和 VHDL 作为最为流行的 HDL 语言，从设计能力上而言都能胜任数字电路系统的设计任务。</p>
<p>VHDL 最初用作文档来描述数字硬件的行为，因此其<strong>描述性和抽象层次更高</strong>。也就是说，VHDL 更适合描述更高层次（如行为级、系统级等）的硬件电路。</p>
<p>Verilog 最初是为了更简洁有效地描述数字硬件电路和仿真而设计的，它的许多关键字与语法集成了 C 语言的体系，因此易学易懂，接受度很广。</p>
<p>前面已经提到最流行的 HDL 语言是 Verilog 和 VHDL。在其基础上发展出了许多抽象程度更高的硬件描述语言，如 SystemVerilog、Superlog、SystemC、CoWare C，这些高级 HDL 语言的语法结枃更加丰富，更适合做系统级、功能级等高层次的设计描述和仿真。</p>
<h2 id="2-3-Verilog-和-C"><a href="#2-3-Verilog-和-C" class="headerlink" title="2.3. Verilog 和 C"></a>2.3. Verilog 和 C</h2><p>Verilog 语言是根据 C 语言发明而来的，因此 Verilog 具备了 C 语言的简洁易用的特点。Verilog 从 C 语言中借鉴了许多语法，例如预编译指令和一些高级编程语言结构。</p>
<ol>
<li><p>C 语言与 Verilog 的最大区别</p>
<p> C 语言与 Verilog 的最大区别在于 C 缺乏硬件描述的 3 个基本概念：</p>
<ul>
<li><p><strong><span class="label primary">互连（connectivity）</span></strong>：硬件系统中，互连是非常重要的组成部分，而在 C 语言中并没有直接可以用来表示模块间互连的变量；而 Verilog 的 <code>wire</code> 型变量配合一些驱动结构能有效地描述网线的互连。</p>
</li>
<li><p><strong><span class="label primary">并发（concurrency）</span></strong>：C 语言天生是<strong>串行</strong>的，不能描述硬件之间并发的特性，C 语言编译后，其机器指令在 CPU 的高速缓冲队列中基本是顺序执行；而 Verilog 可以有效地描述并行的硬件系统，硬件系统比软件系统速度快、实时性高的一个重要原因就是硬件系统中<strong>各个单元的运算是独立的，信号流是并行的</strong>。</p>
</li>
<li><p><strong><span class="label primary">时间（time）</span></strong>：C 程序运行的时候，没有一个严格的时间概念，程序运行的时间长短取决于处理器本身的性能；而 Verilog 语言本身定义了绝对和相对的时间度量，在仿真时可以通过时间度量与周期关系描述信号直接的时间关系。</p>
</li>
</ul>
</li>
<li><p>HDL 语言的本质</p>
<p> 硬件描述语言（HDL）同软件语言（如 C、C++ 等）是有本质区别的。Verilog 作为硬件描述语言，<strong>它的本质作用在于描述硬件</strong>。Verilog 虽然采用了 C 语言形式，但是它的最终描述结果是芯片内部的实际电路。所以评判一段 HDL 代码优劣的最终标准是其描述并实现的硬件电路的性能（包括面积和速度两个方面）。评价一个设计的代码水平较高，仅仅是说这个设计由硬件向 HDL 代码这种表现形式转换得更流畅、合理。而一个设计的最终性能更大程度上取决于设计工程师所构想的硬件实现方案的效率以及合理性。</p>
 <div class="note warning">
            <p>初学者，特别是由软件转行的初学者，片面追求代码的整洁、简短，这是错误的，是与评价 HDL 的标准背道而驰的。正确的编写代码的方法是，首先要做到对所需实现的硬件电路“胸有成竹”，对该部分硬件的结构与连接十分清晰，然后再用适当的 HDL 语句表达出来即可。</p>
          </div>
</li>
<li><p>Verilog 与 C 的结合</p>
<p> Verilog 毕竟是硬件描述语言，在抽象层次上比 C 语言要差一些，语法不如 C 灵活，例如文件输入和输出方面，Verilog 的功能显然不如 C。为了克服 Verilog 高级抽象的缺陷，Verilog 的设计者们发明了 PLI。PLI 可以在仿真器中将 C 语言的程序和 Verilog 的程序互相通信，或者在 Verilog 中调用 C 语言的函数库，这样就大大扩展了 Verilog 语言的灵活性和高层次抽象的能力。开发时，一方面，硬件设计者使用 Verilog 进行硬件建模；另一方面，验证工程师却常常使用 C 来编写测试向量，然后通过 Verilog 的 PLI 将 Verilog 和 C 联系起来。这样，C 语言就很好地弥补了 Verilog 高层次建模的缺陷。</p>
</li>
</ol>
<h1 id="3-HDL-的设计与验证流程"><a href="#3-HDL-的设计与验证流程" class="headerlink" title="3. HDL 的设计与验证流程"></a>3. HDL 的设计与验证流程<a name="03"></a></h1><p>HDL 的基本功能就是有效地描述并仿真硬件系统。在此部分，抛开具体的 PLD 或 ASIC 设计流程，从 HDL 语言层次入手，分析典型的 HDL 设计与验证流程。基于 HDL 的设计、仿真流程如下图所示。图中，虚线框表示的步骤可以根据项目的复杂度省略，而实线框表示的步骤为必须执行的步骤。</p>
<div align="center">
  <img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-27-josh-verilog-part-1/2020-11-27-josh-verilog-part-1-010-DesignSimulationFlowChartBasedonHDL.png!800px"/>
</div>

<p>下面对一些关键设计步骤与概念进行展开。</p>
<h2 id="3-1-系统与功能模块定义（系统与功能模块级）"><a href="#3-1-系统与功能模块定义（系统与功能模块级）" class="headerlink" title="3.1. 系统与功能模块定义（系统与功能模块级）"></a>3.1. 系统与功能模块定义（系统与功能模块级）</h2><p>在大型系统的设计与实现中，首先要进行详细的系统规划和描述，此时 HDL 描述 <strong><span class="label default">侧重于整体系统的划分和实现</span></strong>。对系统级的仿真侧重于对整个系统的功能和性能指标的考量。功能模块级设计时将系统整体功能划分为可实现的具体功能模块，大致确定模块间的接口，如时钟、读写信号、数据流、控制信号等。在有些情况下，还要根据系统要求，描述每个模块或进程的时序约束。另外在此层次，必须权衡整个系统多种的实现方式的优劣，选出系统性能指标优并且可以高效实现的设计方案。功能模块级仿真主要是考察每个功能的功能和基本时序情况。系统与功能模块级设计与仿真常常要借助于 C 语言和抽象程度较高的 HDL 语言描述，如 SystemC、Coware C、SystemVerilog、Superlog 等。</p>
<h2 id="3-2-行为级描述测试激励（Behavioral-Level）"><a href="#3-2-行为级描述测试激励（Behavioral-Level）" class="headerlink" title="3.2. 行为级描述测试激励（Behavioral Level）"></a>3.2. 行为级描述测试激励（Behavioral Level）</h2><p>行为级模块描述的最大特点是 <strong><span class="label default">必须明确每个模块间的所有接口和边界</span></strong>。此时模块内部的功能已经明确，模块间的所有接口，顶层的输入、输出信号等在行为级已经被清晰地描述出来。在 PLD 和 ASIC 设计流程中，常用行为级描述方式编写测试激励。延时描述、监视描述等命令都是在编写测试激励过程中常用的行为级语法。行为级描述常用 HDL 语言如 Verilog 和 VHDL 等。</p>
<h2 id="3-3-寄存器传输级（RTL）"><a href="#3-3-寄存器传输级（RTL）" class="headerlink" title="3.3. 寄存器传输级（RTL）"></a>3.3. 寄存器传输级（RTL）</h2><p>寄存器传输级指不关注寄存器和组合逻辑的细节（如使用了多少逻辑门，逻辑门之间的连接拓扑结构等），<strong><span class="label default">通过描述寄存器到寄存器之间的逻辑功能描述电路</span></strong>的 HDL 层次。RTL 级是比门级更高的抽象层次，一般使用 RTL 级语言描述硬件电路比门级描述电路简单、高效得多。寄存器传输级描述的最大特点是可以直接用综合工具综合门级网表。RTL 设计直接决定着设计的功能和效率。好的 RTL 设计能在满足逻辑功能的前提下，使设计的速度和面积达到一种平衡的优化。RTL 级描述最常用的 HDL 语言是 Verilog 和 VHDL 语言。</p>
<h2 id="3-4-对-RTL-级描述进行功能仿真"><a href="#3-4-对-RTL-级描述进行功能仿真" class="headerlink" title="3.4 对 RTL 级描述进行功能仿真"></a>3.4 对 RTL 级描述进行功能仿真</h2><p>一般来说需要对 RTL 级设计进行功能仿真，仿真的目的为 <strong><span class="label default">验证 RTL 级描述是否与设计意图一致</span></strong>。为了提高效率，一般功能仿真的测试激励使用行为级的 HDL 语言描述。</p>
<h2 id="3-5-逻辑综合（使用-RTL-级-EDA-工具）"><a href="#3-5-逻辑综合（使用-RTL-级-EDA-工具）" class="headerlink" title="3.5. 逻辑综合（使用 RTL 级 EDA 工具）"></a>3.5. 逻辑综合（使用 RTL 级 EDA 工具）</h2><p>RTL 级综合指 <strong><span class="label default">将 RTL 级 HDL 语言翻译成由与、或、非门等基本逻辑单元组成的门级连接（网表），并根据设计目标与要求（约束条件）优化所生成的逻辑连接，输出门级网表文件</span></strong>。随着综合工具的不断智能化，使用 RTL 级语言描述硬件电路越来越方便，特别是在 PLD（主要指 FPGA 和 CPLD）设计领域，最重要的代码设计层次就是 RTL 级。</p>
<h2 id="3-6-门级（Gate-Level）"><a href="#3-6-门级（Gate-Level）" class="headerlink" title="3.6. 门级（Gate Level）"></a>3.6. 门级（Gate Level）</h2><p>由于目前 FPGA 设计大多数依靠专业综合工具完成从 RTL 级代码向门级代码的转换，所有设计者直接用 HDL 语言描述门级模型的情况越来越少，高效的综合工具将设计者从复杂繁琐的门级描述中彻底解脱出来。目前直接使用门级描述的场合一般是 ASIC 和 FPGA 设计中 <strong><span class="label default">某些面积或时序要求较高的模块</span></strong>。门级描述的特点是整个设计用逻辑门实现，通过逻辑门的组合显化描述了设计的引脚、功能、时钟周期等所有信息。</p>
<h2 id="3-7-综合后门级仿真"><a href="#3-7-综合后门级仿真" class="headerlink" title="3.7. 综合后门级仿真"></a>3.7. 综合后门级仿真</h2><p>综合完成后，如果需要检查综合结果是否与原设计一致，就需要做综合后仿真。在仿真时，把综合生成的标准延时文件反标注到综合仿真模型中去，可估计门延时带来的影响。综合后仿真虽然比功能仿真精确一些，但是<strong>只能估计门延时，不能估计线延时</strong>，仿真结果<strong>与布线后的实际情况还有一定的差距</strong>，并不十分准确。这种仿真的主要目的在于 <strong><span class="label default">检查综合器的综合结果是否与设计输入一致</span></strong>。目前主流综合工具日益成熟，对于一般性设计，如果设计者确信自己表述明确，没有综合歧义发生，则可以省略综合后仿真步骤。<strong>一般情况下，综合后仿真与功能仿真的仿真激励相同</strong>。</p>
<h2 id="3-8-布局规划与布局布线"><a href="#3-8-布局规划与布局布线" class="headerlink" title="3.8. 布局规划与布局布线"></a>3.8. 布局规划与布局布线</h2><p>综合的门级结果最终要映射到目标库（如 ASIC 设计）或目标器件（如 PLD 设计）。ASIC 与 PLD 设计的相关流程在此不深究 。</p>
<h2 id="3-9-布局布线后时序仿真与验证"><a href="#3-9-布局布线后时序仿真与验证" class="headerlink" title="3.9. 布局布线后时序仿真与验证"></a>3.9. 布局布线后时序仿真与验证</h2><p>将最终布局规划或布局布线的时延信息反标注到设计网表中，所进行的仿真就叫时序仿真或布局规划与布局布线后仿真，简称后仿真。布局规划与布局布线之后生成的仿真时延文件包含的时延信息最全，不仅包含门延时，还包含实际布线延时，所以时序仿真最准确，能较好地反映芯片的实际工作情况。一般来说，建议进行时序仿真步骤，通过时序仿真能检查设计时序与芯片实际运行情况是否一致，确保设计的可靠性和稳定性。时序仿真的主要目的在于发现时序违规（Timing Violation），即不满足时序约束条件或者器件固有时序规则（建立时间、保持时间等）的情况。</p>
<blockquote id="fn_1">
<sup>1</sup>. 最新的 Verilog HDL标准为 1364-2005。<a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a>
</blockquote>
]]></content>
      <categories>
        <category>Verilog</category>
        <category>Verilog 简介</category>
        <category>Josh 的学习笔记</category>
        <category>Verilog</category>
      </categories>
      <tags>
        <tag>Verilog</tag>
        <tag>HDL</tag>
        <tag>硬件描述语言</tag>
        <tag>行为级</tag>
        <tag>RTL</tag>
        <tag>寄存器传输级</tag>
      </tags>
  </entry>
  <entry>
    <title>MATLAB 函数 —— awgn</title>
    <url>/posts/2f6db45b.html</url>
    <content><![CDATA[<p><code>awgn</code>：在信号中添加高斯白斯噪声</p>
<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><p><code>out = awgn(in,snr)</code><br><code>out = awgn(in,snr,signalpower)</code></p>
<p><code>out = awgn(in,snr,signalpower,randobject)</code><br><code>out = awgn(in,snr,signalpower,seed)</code><br><code>out = awgn(___,powertype)</code></p>
<a id="more"></a>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p><code>out = awgn(in,snr)</code> 将高斯白噪声添加到矢量信号 <code>in</code> 中。此条语句假定 <code>in</code> 的功率为 0 dBW。</p>
<p><code>out = awgn(in,snr,signalpower)</code> 接受以 dBW 为单位的输入信号功率值。要使该函数在添加噪声之前测量 <code>in</code> 的功率，请将 <code>signalpower</code> 指定为 <code>measured</code>。<a href="#Examples-01">举例</a></p>
<p><code>out = awgn(in,snr,signalpower,randobject)</code> 接受满足前述两条语法，外加随机数流对象的输入组合以生成满足正态分布的随机噪声样本。有关产生可重复噪声样本的信息，请参见<a href="#tips">提示</a>。<a href="#Examples-03">举例</a></p>
<p><code>out = awgn(in,snr,signalpower,seed)</code> 指定用于初始化正态随机数生成器的种子值，该种子在添加高斯白噪声到输入信号时使用。有关产生可重复噪声样本的信息，请参见<a href="#tips">提示</a>。</p>
<p><code>out = awgn(___,powertype)</code> 除了前面任何语法中的输入自变量之外，还将可信号和噪声功率类型指定为 <code>dB</code> 或 <code>linear</code>。</p>
<p>有关 SNR 与噪声相对功率的其他度量（例如 $E_\mathrm{S}/N_0$ 和 $E_\mathrm{b}/N_0$）之间的关系，请参阅 <a href="https://ww2.mathworks.cn/help/comm/ug/awgn-channel.html#a1071501088">AWGN 信道噪声级别</a>。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><h2 id="将-AWGN-添加到锯齿波"><a href="#将-AWGN-添加到锯齿波" class="headerlink" title="将 AWGN 添加到锯齿波"></a>将 AWGN 添加到锯齿波<span id="Examples-01"></span></h2><p>创建一个锯齿波。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">t <span class="built_in">=</span> (<span class="number">0</span>:<span class="number">0.1</span>:<span class="number">10</span>)<span class="string">&#x27;;</span></span><br><span class="line"><span class="string">x = sawtooth(t);</span></span><br></pre></td></tr></table></figure>
<p>添加高斯白噪声并绘制结果。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">y <span class="built_in">=</span> awgn(x,<span class="number">10</span>,<span class="string">&#x27;measured&#x27;</span>);</span><br><span class="line">plot(t,[x y])</span><br><span class="line">legend(<span class="string">&#x27;Original Signal&#x27;</span>,<span class="string">&#x27;Signal with AWGN&#x27;</span>)</span><br></pre></td></tr></table></figure>
<div align="center">
  <img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-27-matlab-awgn/2020-11-27-matlab-awgn-010-AddAWGNToSawtoothSignalExample-01.png?imageMogr2/thumbnail/!100p|watermark/2/text/QEpvc2ggR2Fv/fontsize/15/dissolve/60/gravity/southeast/dx/5/dy/5"/>
</div>

<h2 id="AWGN-信道中的常规-QAM-调制"><a href="#AWGN-信道中的常规-QAM-调制" class="headerlink" title="AWGN 信道中的常规 QAM 调制"></a>AWGN 信道中的常规 QAM 调制<span id="Examples-02"></span></h2><p>在存在高斯噪声的情况下，使用非矩形 16 元星座发送和接收数据。绘制噪声星座图，并针对两种不同的信噪比估算误符号率（SER）。</p>
<p>根据电话线调制解调器的 V.29 标准创建一个 16-QAM 星座。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">c <span class="built_in">=</span> [-<span class="number">5</span> -<span class="number">5</span>i <span class="number">5</span> <span class="number">5</span>i -<span class="number">3</span> -<span class="number">3</span>-<span class="number">3</span>i -<span class="number">3</span>i <span class="number">3</span>-<span class="number">3</span>i <span class="number">3</span> <span class="number">3</span>+<span class="number">3</span>i <span class="number">3</span>i -<span class="number">3</span>+<span class="number">3</span>i -<span class="number">1</span> -<span class="number">1</span>i <span class="number">1</span> <span class="number">1</span>i];</span><br><span class="line">M <span class="built_in">=</span> length(c);</span><br></pre></td></tr></table></figure>
<p>生成随机符号。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">data <span class="built_in">=</span> randi([<span class="number">0</span> M-<span class="number">1</span>],<span class="number">2000</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>使用 <code>genqammod</code> 函数调制数据。由于星座图不是矩形，因此必须进行常规 QAM 调制。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">modData <span class="built_in">=</span> genqammod(data,c);</span><br></pre></td></tr></table></figure>
<p>使信号通过具有 20 dB 信噪比（SNR）的 AWGN 信道。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">rxSig <span class="built_in">=</span> awgn(modData,<span class="number">20</span>,<span class="string">&#x27;measured&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>显示接收信号的星座图和参考星座图。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">h <span class="built_in">=</span> scatterplot(rxSig);</span><br><span class="line">hold on</span><br><span class="line">scatterplot(c,[],[],<span class="string">&#x27;r*&#x27;</span>,h)</span><br><span class="line">grid</span><br><span class="line">hold off</span><br></pre></td></tr></table></figure>
<div align="center">
  <img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-27-matlab-awgn/2020-11-27-matlab-awgn-020-GeneralQAMModulationInAnAWGNChannelExample-01.png?imageMogr2/thumbnail/!100p|watermark/2/text/QEpvc2ggR2Fv/fontsize/15/dissolve/60/gravity/southeast/dx/5/dy/5"/>
</div>

<p>使用 <code>genqamdemod</code> 函数解调接收到的信号。计算误符号数和误符号率。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">demodData <span class="built_in">=</span> genqamdemod(rxSig,c);</span><br><span class="line">[numErrors,ser] <span class="built_in">=</span> symerr(data,demodData)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">numErrors &#x3D; 1</span><br><span class="line">ser &#x3D; 5.0000e-04</span><br></pre></td></tr></table></figure>
<p>使用具有 10 dB SNR 的 AWGN 信道重复传输和解调过程。计算降低 SNR 后的误符号率。不出所料，当 SNR 降低时，性能会下降。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">rxSig <span class="built_in">=</span> awgn(modData,<span class="number">10</span>,<span class="string">&#x27;measured&#x27;</span>);</span><br><span class="line">demodData <span class="built_in">=</span> genqamdemod(rxSig,c);</span><br><span class="line">[numErrors,ser] <span class="built_in">=</span> symerr(data,demodData)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">numErrors &#x3D; 462</span><br><span class="line">ser &#x3D; 0.2310</span><br></pre></td></tr></table></figure>
<h2 id="用-RandStream-产生可重复的-AWGN"><a href="#用-RandStream-产生可重复的-AWGN" class="headerlink" title="用 RandStream 产生可重复的 AWGN"></a>用 RandStream 产生可重复的 AWGN<span id="Examples-03"></span></h2><p>使用 <a href="https://ww2.mathworks.cn/help/matlab/ref/randstream.html"><code>RandStream</code></a> 和 <a href="https://ww2.mathworks.cn/help/matlab/ref/randstream.reset.html"><code>reset</code></a> 对象函数生成高斯白噪声相加的结果。</p>
<p>将 X 的功率指定为 0 dBW，添加噪声以产生 10 dB 的 SNR，并利用本地随机流。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">S <span class="built_in">=</span> RandStream(<span class="string">&#x27;mt19937ar&#x27;</span>,<span class="string">&#x27;Seed&#x27;</span>,<span class="number">5489</span>);</span><br><span class="line">sigin <span class="built_in">=</span> sqrt(<span class="number">2</span>)*sin(<span class="number">0</span>:pi/<span class="number">8</span>:<span class="number">6</span>*pi);</span><br><span class="line">sigout1 <span class="built_in">=</span> awgn(sigin,<span class="number">10</span>,<span class="number">0</span>,S);</span><br></pre></td></tr></table></figure>
<p>将 AWGN 添加到 <code>sigin</code>。 使用 <a href="https://ww2.mathworks.cn/help/matlab/ref/isequal.html"><code>isequal</code></a> 比较 <code>sigout1</code> 和 <code>sigout2</code>。 当不重置随机流时，输出不相等。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">sigout2 <span class="built_in">=</span> awgn(sigin,<span class="number">10</span>,<span class="number">0</span>,S);</span><br><span class="line">isequal(sigout1,sigout2)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ans &#x3D; logical</span><br><span class="line">   0</span><br></pre></td></tr></table></figure>
<p>重置随机流对象，将对象置为初始状态，然后再将 AWGN 添加到 <code>sigout1</code>。将 AWGN 添加到 <code>sigin</code> 并将 <code>sigout1</code> 与 <code>sigout3</code> 比较。 重置随机流后，输出相等。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">reset(S);</span><br><span class="line">sigout3 <span class="built_in">=</span> awgn(sigin,<span class="number">10</span>,<span class="number">0</span>,S);</span><br><span class="line">isequal(sigout1,sigout3)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ans &#x3D; logical</span><br><span class="line">   1</span><br></pre></td></tr></table></figure>
<h1 id="输入参数"><a href="#输入参数" class="headerlink" title="输入参数"></a>输入参数</h1><h2 id="in-输入信号"><a href="#in-输入信号" class="headerlink" title="in - 输入信号"></a><code>in</code> - 输入信号</h2><p>输入信号，指定为<strong>标量</strong>，<strong>向量</strong>或<strong>数组</strong>。假定输入信号的功率为0 dBW。</p>
<p><strong>数据类型</strong>：<code>double</code><br><strong>复数支持</strong>：是</p>
<h2 id="snr-信噪比（SNR）"><a href="#snr-信噪比（SNR）" class="headerlink" title="snr - 信噪比（SNR）"></a><code>snr</code> - 信噪比（SNR）</h2><p>信噪比（以 dB 为单位），指定为<strong>标量</strong>。</p>
<div class="note info">
            <p>注意：</p><p>加上噪声后，此函数会将相同的 <code>snr</code> 应用于完整输入信号的所有元素。阵列输入信号没有独立通道的概念。 要独立考虑多个频道，请参阅 <a href="https://ww2.mathworks.cn/help/comm/ref/comm.awgnchannel-system-object.html"><code>comm.AWGNChannel</code></a>。</p>
          </div>
<p><strong>数据类型</strong>：<code>double</code></p>
<h2 id="signalpower-信号功率"><a href="#signalpower-信号功率" class="headerlink" title="signalpower - 信号功率"></a><code>signalpower</code> - 信号功率</h2><p>信号功率，指定为<strong>标量</strong>或 <code>measured</code>。</p>
<ul>
<li><p>当 <code>signalpower</code> 为标量时，该值用作 <code>in</code> 的信号电平，以便根据 <code>snr</code> 的值确定适当的噪声电平。</p>
</li>
<li><p>当 <code>signalpower</code> 为 <code>measured</code> 时，将计算 <code>in</code> 的信号电平，以根据 <code>snr</code> 的值确定适当的噪声电平。</p>
</li>
</ul>
<div class="note info">
            <p>注意：</p><p>当指定 <code>measured</code> 时，此函数将使用完整输入信号的所有元素来计算信号功率。在计算功率时，阵列输入信号没有独立通道的概念。</p>
          </div>
<p><strong>数据类型</strong>：<code>double</code></p>
<h2 id="randobject-随机数流对象"><a href="#randobject-随机数流对象" class="headerlink" title="randobject - 随机数流对象"></a><code>randobject</code> - 随机数流对象</h2><p>随机数流对象，指定为 <a href="https://ww2.mathworks.cn/help/matlab/ref/randstream.html"><code>RandStream</code></a> 对象。 随机流对象的状态确定 <a href="https://ww2.mathworks.cn/help/matlab/ref/randn.html"><code>randn</code></a> 函数产生的数字序列。使用 <a href="https://ww2.mathworks.cn/help/matlab/ref/randstream.reset.html"><code>reset (RandStream)</code></a> 函数及其属性来配置随机流对象。</p>
<p><code>wgn</code> 使用 <a href="https://ww2.mathworks.cn/help/matlab/ref/randn.html"><code>randn</code></a> 生成正常的随机噪声样本。<a href="https://ww2.mathworks.cn/help/matlab/ref/randn.html"><code>randn</code></a> 函数使用 <a href="https://ww2.mathworks.cn/help/matlab/ref/randstream.html"><code>RandStream</code></a> 对象中的一个或多个统一值来生成每个正态值。</p>
<p>有关产生可重复噪声样本的信息，请参见<a href="#tips">提示</a>。</p>
<h2 id="seed-随机数生成器种子"><a href="#seed-随机数生成器种子" class="headerlink" title="seed - 随机数生成器种子"></a><code>seed</code> - 随机数生成器种子</h2><p>随机数生成器种子，指定为<strong>标量</strong>。</p>
<h2 id="powertype-信号功率单元"><a href="#powertype-信号功率单元" class="headerlink" title="powertype - 信号功率单元"></a><code>powertype</code> - 信号功率单元</h2><p>信号功率单元，指定为 <code>dB</code> 或 <code>linear</code>。默认为 <code>dB</code>。</p>
<ul>
<li><p>当功率类型为 <code>dB</code> 时，以 dB 为单位测量 snr，以 dBW 为单位测量信号功率。</p>
</li>
<li><p>当功率类型为 <code>linear</code> 时，<code>snr</code> 以比率进行测量，<code>signalpower</code> 以瓦特为单位。</p>
</li>
</ul>
<p>有关 SNR 与噪声相对功率的其他度量（例如 $E_\mathrm{S}/N_0$ 和 $E_\mathrm{b}/N_0$）之间的关系，请参阅 <a href="https://ww2.mathworks.cn/help/comm/ug/awgn-channel.html#a1071501088">AWGN 信道噪声级别</a>。</p>
<h1 id="输出参数"><a href="#输出参数" class="headerlink" title="输出参数"></a>输出参数</h1><h2 id="out-输出信号"><a href="#out-输出信号" class="headerlink" title="out  - 输出信号"></a><code>out</code>  - 输出信号</h2><p>输出信号，以<strong>标量</strong>，<strong>向量</strong>或<strong>数组</strong>形式返回。 返回的输出信号是添加了高斯白噪声的输入信号。</p>
<h1 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示<span id="tips"></span></h1><ul>
<li><p>要生成可重复的高斯白噪声样本，请使用以下技巧之一：</p>
<ul>
<li><p>提供静态 <code>seed</code> 值作为 <code>awgn</code> 的输入。</p>
</li>
<li><p>在将 <code>randobject</code> 传递为 <code>awgn</code> 的输入之前，请对 <code>randobject</code> 使用 <a href="https://ww2.mathworks.cn/help/matlab/ref/randstream.reset.html"><code>reset (RandSteam)</code></a> 函数。</p>
</li>
<li><p>将处于已知状态的 <code>randobject</code> 提供给 <code>awgn</code>。有关更多信息，请参见 <a href="https://ww2.mathworks.cn/help/matlab/ref/randstream.html"><code>RandStream</code></a>。</p>
</li>
</ul>
</li>
</ul>
<h1 id="扩展功能"><a href="#扩展功能" class="headerlink" title="扩展功能"></a>扩展功能</h1><h2 id="C-C-代码生成"><a href="#C-C-代码生成" class="headerlink" title="C/C++ 代码生成"></a>C/C++ 代码生成</h2><blockquote>
<p>使用 MATLAB® Coder™ 生成 C 代码和 C++ 代码。</p>
<blockquote>
<p>用法说明和限制：</p>
<p>支持代码生成，但包括 <a href="https://ww2.mathworks.cn/help/matlab/ref/randstream.html"><code>RandStream</code></a> 对象的语法除外。</p>
</blockquote>
</blockquote>
<h1 id="另请参阅"><a href="#另请参阅" class="headerlink" title="另请参阅"></a>另请参阅</h1><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p><a href="https://ww2.mathworks.cn/help/matlab/ref/randstream.html"><code>RandStream</code></a> | <a href="[RandStream](https://ww2.mathworks.cn/help/matlab/ref/randstream.html"><code>bsc</code></a>) | <a href="https://ww2.mathworks.cn/help/matlab/ref/randn.html"><code>randn</code></a> | <a href="https://ww2.mathworks.cn/help/comm/ref/wgn.html"><code>wgn</code></a></p>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p><a href="https://ww2.mathworks.cn/help/comm/ref/comm.awgnchannel-system-object.html"><code>comm.AWGNChannel</code></a></p>
<h2 id="话题"><a href="#话题" class="headerlink" title="话题"></a>话题</h2><p><a href="https://ww2.mathworks.cn/help/comm/ug/awgn-channel.html#a1071501088">AWGN Channel Noise Level</a></p>
<hr>
<p>在 R2006a 之前推出</p>
<hr>
<p>原文参考：<a href="https://ww2.mathworks.cn/help/comm/ref/awgn.html">https://ww2.mathworks.cn/help/comm/ref/awgn.html</a></p>
]]></content>
      <categories>
        <category>MATLAB</category>
        <category>翻译</category>
        <category>帮助文档</category>
        <category>信号处理</category>
        <category>噪声</category>
      </categories>
      <tags>
        <tag>MATLAB</tag>
        <tag>翻译</tag>
        <tag>高斯白噪声</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo-NexT 折腾就完事儿了</title>
    <url>/posts/b158f1b4.html</url>
    <content><![CDATA[<h1 id="瞎折腾-美化侧边栏"><a href="#瞎折腾-美化侧边栏" class="headerlink" title="瞎折腾/美化侧边栏"></a>瞎折腾/<del>美化</del>侧边栏</h1><p>在博客根目录下的 <code>source/_data</code> 文件夹中新建 <code>sidebar.swig</code> 文件。</p>
<h2 id="添加-Tag-Cloud"><a href="#添加-Tag-Cloud" class="headerlink" title="添加 Tag Cloud"></a>添加 Tag Cloud</h2><p>安装 <code>hexo-tag-cloud</code> 插件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-tag-cloud --save</span><br></pre></td></tr></table></figure>
<p>添加相关代码写入 <code>sidebar.swig</code>。不喜欢标题的把 <code>&lt;h3 class=&quot;widget-title&quot;&gt;Tag Cloud&lt;/h3&gt;</code> 去掉即可。</p>
<figure class="highlight html"><figcaption><span>source/_data/sidebar.swig</span></figcaption><table><tr><td class="code"><pre><span class="line">&#123;% if site.tags.length &gt; 1 %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/js/tagcloud.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/js/tagcanvas.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;widget-wrap&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span> <span class="attr">class</span>=<span class="string">&quot;widget-title&quot;</span>&gt;</span>Tag Cloud<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;myCanvasContainer&quot;</span> <span class="attr">class</span>=<span class="string">&quot;widget tagcloud&quot;</span> <span class="attr">style</span>=<span class="string">&quot;font-size:20px;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">width</span>=<span class="string">&quot;220&quot;</span> <span class="attr">height</span>=<span class="string">&quot;200&quot;</span> <span class="attr">id</span>=<span class="string">&quot;resCanvas&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width=100%&quot;</span>&gt;</span></span><br><span class="line">            &#123;&#123; list_tags() &#125;&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h1 id="瞎折腾-美化页面"><a href="#瞎折腾-美化页面" class="headerlink" title="瞎折腾/美化页面"></a>瞎折腾/<del>美化</del>页面</h1><p>在博客根目录下的 <code>source/_data</code> 文件夹中新建 <code>variables.styl</code> 文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd hexo</span><br><span class="line">vi source/_data/variables.styl</span><br></pre></td></tr></table></figure>
<h2 id="页面圆角"><a href="#页面圆角" class="headerlink" title="页面圆角"></a>页面圆角</h2><p>在 <code>variables.styl</code> 文件里添加圆角半径值</p>
<figure class="highlight"><figcaption><span>source/_data/variables.styl</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// 圆角设置</span></span><br><span class="line">$border-radius-inner     = 0px;     // 内部圆角半径</span><br><span class="line">$border-radius           = 8px;     // 外部圆角半径</span><br></pre></td></tr></table></figure>
<h1 id="需要修改源代码的操作"><a href="#需要修改源代码的操作" class="headerlink" title="需要修改源代码的操作"></a>需要修改源代码的操作</h1><h2 id="修改侧边栏最大高度"><a href="#修改侧边栏最大高度" class="headerlink" title="修改侧边栏最大高度"></a>修改侧边栏最大高度</h2><p>Sidebar 的高度在 <code>themes/next/source/js/util.js</code> 文件中计算出，修改计算公式可调整 Sidebar 的最大高度。</p>
<figure class="highlight javascript"><figcaption><span>themes/next/source/js/util.js - 原 Sidebar 最大高度</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Init Sidebar &amp; TOC inner dimensions on all pages and for all schemes.</span></span><br><span class="line"><span class="comment"> * Need for Sidebar/TOC inner scrolling if content taller then viewport.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">initSidebarDimension: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// Initialize Sidebar &amp; TOC Height.</span></span><br><span class="line">  <span class="keyword">var</span> sidebarWrapperHeight = <span class="built_in">document</span>.body.offsetHeight - sidebarSchemePadding + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><figcaption><span>themes/next/source/js/util.js - 修改后的 Sidebar 最大高度</span></figcaption><table><tr><td class="code"><pre><span class="line">initSidebarDimension: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// Initialize Sidebar &amp; TOC Height.</span></span><br><span class="line">  <span class="keyword">var</span> sidebarWrapperHeight = <span class="built_in">document</span>.body.offsetHeight - sidebarSchemePadding -<span class="number">100</span> + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<ul>
<li>参考文档：<a href="https://yi-yun.github.io/Hexo-Next-Custom/#更改-sidebar-大小https://yi-yun.github.io/Hexo-Next-Custom/#更改-sidebar-大小">Hexo Next 博客自定义配置 -&gt; 更改-sidebar-大小</a></li>
</ul>
]]></content>
      <categories>
        <category>Blog</category>
        <category>Hexo</category>
        <category>Next</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title>Josh 的学习笔记之 Verilog（Part 2 —— Verilog 语言基础）</title>
    <url>/posts/fd2ca242.html</url>
    <content><![CDATA[<p>本文从一个 Verilog 用例出发，对 Verilog 语言的语法进行了阐释。包括的内容主要有 Verilog 语言的基本词法，常用的编译指令，逻辑值、常量、变量的含义，操作符的概念和分类等，还对 Verilog 中的参数、并发以及系统任务和系统函数进行了简要说明。</p>
<h1 id="1-两种设计方法（Top-Down-和-Bottom-Up）"><a href="#1-两种设计方法（Top-Down-和-Bottom-Up）" class="headerlink" title="1. 两种设计方法（Top-Down 和 Bottom-Up）"></a>1. 两种设计方法（Top-Down 和 Bottom-Up）</h1><p>在传统意义上，设计硬件电路主要是使用自底向上（Bottom-Up）的设计方法。工程师们总是从最底层的逻辑门开始，逐渐搭建成较大的模块，然后再将这些模块组成更大的模块，最后形成整个设计。</p>
<p>在  <a href="https://josh-gao.top/posts/460433dd.html">Part 1——初识 HDL 设计方法</a>中已经提到，随着 HDL 和逻辑综合技术的进步，工程师们逐渐可以使用自顶向下（Top-Down）的方法来设计硬件。这样，工程师们<strong>首先关注于设计的规格（Specification），然后将规格分解为一个个模块，再分解为更小的模块</strong>。然后采用 HDL 的可综合子集直接描述硬件的行为，由逻辑综合工具自动完成由 HDL 到门级电路的转换。</p>
<a id="more"></a>
<p>最近几年，随着 IP核 市场的逐渐兴起，许多设计者逐渐意识到<strong>利用现有的 IP核 可以帮助节约设计成本、减少设计周期</strong>，有许多设计工程师，甚至希望所有的设计模块都使用现成的模块，自己仅仅开发一些简单的粘合逻辑。这就有点像电路板设计的过程，工程师将各种芯片集成到一块电路板上，自己完成这些芯片间的互连和一些简单的 CPLD 逻辑设计，以及对微处理器的编程。使用现有的 IP 来搭建系统实际上也是一种自底向上（Bottom-Up）的设计方法。</p>
<p>从以上描述可以看出，设计硬件电路时，这两种设计方法都有可能采用。Verilog HDL 可以完全支持这两种设计方法。</p>
<ul>
<li>在门级的设计中，用户可以直接实例化 Verilog 语言中的门级原语构建系统；</li>
<li>如果需要描述硬件的行为，可以使用 Verilog 的行为级描述功能；</li>
<li>如果要使用 IP核 ，只要在设计中直接实例化 IP核 即可。</li>
</ul>
<p>EDA 行业的先行者们发明了 Verilog 硬件描述语言，其最根本的目的就是用 Verilog 来描述硬件的行为，但是有的描述是不需要实现为硬件电路的。</p>
<p>如果用户的 Verilog 描述的最终目的是要实现为硬件电路，那么要<strong>时刻提醒自己是在设计电路</strong>，这与用 C 语言对处理器编程有很大的区别。</p>
<p>硬件电路最大的特点是由一个个模块组成，模块之间使用互连线，各个模块<strong>独立并行</strong>工作。同时，它们通过输人和输出端口与相邻的模块互相沟通。每个硬件单元都有相应的<strong>延时特性</strong>，硬件的延时也是设计的目标之一。</p>
<h1 id="2-从-Verilog-实例出发"><a href="#2-从-Verilog-实例出发" class="headerlink" title="2. 从 Verilog 实例出发"></a>2. 从 Verilog 实例出发</h1><h2 id="2-1-Verilog-实例"><a href="#2-1-Verilog-实例" class="headerlink" title="2.1. Verilog 实例"></a>2.1. Verilog 实例</h2><p><a name="JoshVerilog模块"></a>首先看一个简单的如下图所示的电路（模块）：JoshVerilog。它可以是一个独立的设计，也可以是更大的系统的一个组成部分。</p>
<div align="center">
  <img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-28-josh-verilog-part-2/2020-11-28-josh-verilog-part-2-010-JoshVerilog.png!700px"/>
</div>

<p>该电路首先在两个 2 位的输人数据 <code>A_in[1:0]</code> 的和 <code>B_in[1:0]</code> 之间，由 <code>sel</code> 信号做二选一。后面是一个 2-4 译码电路，将输人的信号 <code>result[1:0]</code>解析成 <code>eq0</code>、<code>eql</code>、<code>eq2</code> 和 <code>eq3</code> 这4个信号，它们同时只有一个为 1。</p>
<p>将 <code>eq0</code> 和 <code>eql</code> 相异或（xor），<code>eq2</code> 和 <code>eq3</code> 相异或。然后，将两个异或的结果 <code>A_xor_wire</code> 和 <code>XOR_B</code> 分别寄存输出给 <code>A_xor_out</code> 和 <code>B_xor_out</code> 两个输出寄存器带有低有效（active low）的异步复位端。</p>
<p><strong>这些电路单元都是同时并行工作的，相互之间并没有先后顺序关系，这一点与软件设计程序很不一样。</strong></p>
<p>下面具体分析 <a href="#JoshVerilog模块">JoshVerilog 模块</a>的电路功能。源代码如下。</p>
<p><a name="JoshVerilog代码"></a></p>
<figure class="highlight verilog"><figcaption><span>Josh.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编译指令, 定义时间单位和时间精度</span></span><br><span class="line"><span class="meta">`<span class="meta-keyword">timescale</span> 1ns/100p             // 每个时间单位是1ns, 仿真精度是100ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// module名 + 端口列表</span></span><br><span class="line"><span class="keyword">module</span> Josh( clk, rst_n, A_in, B_in, sel, A_xor_out, B_xor_out );</span><br><span class="line"></span><br><span class="line"><span class="comment">// IO端口声明</span></span><br><span class="line"><span class="keyword">input</span>       clk;</span><br><span class="line"><span class="keyword">input</span>       rst_n;</span><br><span class="line"><span class="keyword">input</span> [<span class="number">1</span>:<span class="number">0</span>] A_in;               <span class="comment">// 该信号的输入位宽为2</span></span><br><span class="line"><span class="keyword">input</span> [<span class="number">1</span>:<span class="number">0</span>] B_in;</span><br><span class="line"><span class="keyword">input</span>       sel;</span><br><span class="line"><span class="keyword">output</span>      A_xor_out;</span><br><span class="line"><span class="keyword">output</span>      B_xor_out;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内部线网和寄存器声明</span></span><br><span class="line"><span class="keyword">wire</span>        A_xor_wire;         <span class="comment">// 模块内wire型变量</span></span><br><span class="line"><span class="keyword">wire</span>        B_xor_wire;</span><br><span class="line"><span class="keyword">wire</span>  [<span class="number">1</span>:<span class="number">0</span>] result;</span><br><span class="line"><span class="keyword">reg</span>         eq0, eq1, eq2, eq3; <span class="comment">// 模块内reg型变量</span></span><br><span class="line"><span class="keyword">reg</span>         A_xor_out;</span><br><span class="line"><span class="keyword">reg</span>         B_xor_out;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 行为描述, DFF_A</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">    <span class="keyword">if</span> (~rst_n)</span><br><span class="line">        A_xor_out &lt;= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        A_xor_out &lt;= A_xor_wire;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 行为描述, DFF_B</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">    <span class="keyword">if</span> (~rst_n)</span><br><span class="line">        B_xor_out &lt;= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        B_xor_out &lt;= B_xor_wire;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据流描述, A_xor_wire</span></span><br><span class="line"><span class="keyword">assign</span> #<span class="number">1</span> A_xor_wire = eq0 ^ eq1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构化描述, XOR_B, 直接使用 Verilog 自带的 xor 门原句</span></span><br><span class="line"><span class="keyword">xor</span> #<span class="number">1</span> XOR_B(B_xor_wire, eq2, eq3);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据流描述, MUX21</span></span><br><span class="line"><span class="keyword">assign</span> #<span class="number">3</span> result = sel ? B_in : A_in;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 行为描述, DECODER, 一个2-4译码器</span></span><br><span class="line"><span class="keyword">always</span> @(result) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">case</span>(result)</span><br><span class="line">        <span class="number">2&#x27;b00</span>: <span class="keyword">begin</span></span><br><span class="line">            &#123;eq3, eq2, eq1, eq0&#125; = #<span class="number">2</span> <span class="number">4&#x27;b0001</span>;</span><br><span class="line">            <span class="built_in">$display</span> (<span class="string">&quot;At time %t-&quot;</span>, <span class="built_in">$time</span>, <span class="string">&quot;eq0 = 1&quot;</span>);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="number">2&#x27;b01</span>: <span class="keyword">begin</span></span><br><span class="line">            &#123;eq3, eq2, eq1, eq0&#125; = #<span class="number">2</span> <span class="number">4&#x27;b0010</span>;</span><br><span class="line">            <span class="built_in">$display</span> (<span class="string">&quot;At time %t-&quot;</span>, <span class="built_in">$time</span>, <span class="string">&quot;eq1 = 1&quot;</span>);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="number">2&#x27;b10</span>: <span class="keyword">begin</span></span><br><span class="line">            &#123;eq3, eq2, eq1, eq0&#125; = #<span class="number">2</span> <span class="number">4&#x27;b0100</span>;</span><br><span class="line">            <span class="built_in">$display</span> (<span class="string">&quot;At time %t-&quot;</span>, <span class="built_in">$time</span>, <span class="string">&quot;eq2 = 1&quot;</span>);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="number">2&#x27;b11</span>: <span class="keyword">begin</span></span><br><span class="line">            &#123;eq3, eq2, eq1, eq0&#125; = #<span class="number">2</span> <span class="number">4&#x27;b1000</span>;</span><br><span class="line">            <span class="built_in">$display</span> (<span class="string">&quot;At time %t-&quot;</span>, <span class="built_in">$time</span>, <span class="string">&quot;eq3 = 1&quot;</span>);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">default</span>: ;</span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">// module结束</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>代码分析如下。</p>
<ol>
<li><p>二选一多路选择器</p>
<p> 对于 <code>MUX21</code> 这样二选一的电路，将采用如下的数据流描述（assign语句）：</p>
 <figure class="highlight verilog"><figcaption><span>Josh.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> #<span class="number">3</span> result = sel ? B_in : A_in;</span><br></pre></td></tr></table></figure>
<p> <code>assign</code> 是 Verilog 中的关键词，用它赋值的语言称为<strong>连续赋值语句</strong>。</p>
<p> 如果 <code>sel</code>为真（1），则选择 <code>B_in</code>，否则将选择 <code>A_in</code>，而 <code>#3</code> 表示经过 3 个延时单位，再将选择结果赋值给 <code>result</code>，这也模拟了组合逻辑的延时。由于在<a href="#JoshVerilog代码">代码</a>最开头已经使用 Verilog 的编译指令将延时单位定义为 1ns（<code>timescale 1ns/100ps</code>），因此这里的 <code>#3</code> 代表 3ns 的延时。</p>
</li>
<li><p>2 - 4 译码器</p>
<p> 关于实现 2 - 4 译码器，则采用了如下的描述：</p>
 <figure class="highlight verilog"><figcaption><span>Josh.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @(result) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">case</span>(result)</span><br><span class="line">        <span class="number">2&#x27;b00</span>: <span class="keyword">begin</span></span><br><span class="line">            &#123;eq3, eq2, eq1, eq0&#125; = #<span class="number">2</span> <span class="number">4&#x27;b0001</span>;</span><br><span class="line">            <span class="built_in">$display</span> (<span class="string">&quot;At time %t-&quot;</span>, <span class="built_in">$time</span>, <span class="string">&quot;eq0 = 1&quot;</span>);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">default</span>: ;</span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p> 这里采用了另一种描述方式：用 <code>always</code> 语句来描述电路的行为。通过 <code>case</code> 判断 <code>result</code> 的值来决定 <code>eq0</code>、<code>eq3</code> 的值。同样，也采用 <code>#2</code> 来模拟组合逻辑的延时。<code>always</code> 和 <code>case</code> 也是 Verilog 中的关键词。这样的描述方法称之为<strong>行为描述</strong>，它侧重于描述电路的行为。</p>
 <figure class="highlight verilog"><figcaption><span>Josh.v</span></figcaption><table><tr><td class="code"><pre><span class="line">&#123;eq3, eq2, eq1, eq0&#125; = #<span class="number">2</span> <span class="number">4&#x27;b0001</span>;</span><br></pre></td></tr></table></figure>
<p> 该语句表示将 <code>4&#39;b0001</code> 赋值给 <code>eq3~eq0</code> 合并成的 4 位变量。<code>&#123;&#125;</code> 是 Verilog 的合并符号。</p>
</li>
<li><p>异或门</p>
<p> 对于 <code>A_xor_wire</code> 和 <code>XOR_B</code> 的两个完全一样的异或门，也采用了两种不同的描述方式：</p>
 <figure class="highlight verilog"><figcaption><span>Josh.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> #<span class="number">1</span> A_xor_wire = eq0 ^ eq1;</span><br></pre></td></tr></table></figure>
<p> 和</p>
 <figure class="highlight verilog"><figcaption><span>Josh.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">xor</span> #<span class="number">1</span> XOR_B(B_xor_wire, eq2, eq3);</span><br></pre></td></tr></table></figure>
<p> <code>xor</code> 是 Verilog 中自带的基本逻辑门原语。这里相当于调用了该 <code>xor</code> 门。而 <code>B_xor_wire</code>、<code>eq2</code> 和 <code>eq3</code> 是代人到 <code>xor</code> 门中的参数。<code>eq2</code> 和 <code>eq3</code> 是输人，<code>B_xor_wire</code> 是输出。这里 <code>B_xor_wire</code> 是 <code>eq2</code> 和 <code>eq3</code> 相异或的结果。</p>
<p> 在 Verilog 中，<strong>将调用其他功能模块（包括 Verilog 的内嵌基本逻辑门）称为“实例化（lnstantiate）”</strong>。实例化<strong>类似</strong>于软件设计中的调用，但不能简单理解为软件中的调用。软件调用过程是顺序执行的，而实例化的硬件电路在设计中是独立于其他功能块，并行运行的。</p>
<p> 这种<strong>在模块中实例化其他功能模块</strong>的描述方式被称之为<strong>结构化描述</strong>。</p>
</li>
</ol>
<h2 id="2-2-3-种描述方法"><a href="#2-2-3-种描述方法" class="headerlink" title="2.2. 3 种描述方法"></a>2.2. 3 种描述方法</h2><p>从以上的描述可以看出 Verilog 语言的 3 种基本的描述方法（基本上所有的 Verilog 功能模块都是由这 3 种方式来描述）：</p>
<ul>
<li><strong>数据流描述</strong>：采用 <code>assign</code> 语句，该语句被称为连续赋值语句；</li>
<li><strong>行为描述</strong>：使用 <code>always</code> 或 <code>initial</code> 语句块，其中出现的语句被称为过程赋值语句；</li>
<li><p><strong>结构化描述</strong>：实例化已有的功能模块。结构化描述主要有以下3种：</p>
<ul>
<li>Module实例化：实例化已有的 module；</li>
<li>门实例化：实例化基本的门电路原语；</li>
<li>用户定义原语（UDP）实例化：实例化用户定义的原语。</li>
</ul>
</li>
</ul>
<p>在<a href="https://josh-gao.blog.csdn.net/article/details/105262549">《Part 3——描述方式和设计层次》</a>中会将详细介绍 Verilog 语言中的这 3 种描述方式。</p>
<h1 id="3-Verilog-的基本词法"><a href="#3-Verilog-的基本词法" class="headerlink" title="3. Verilog 的基本词法"></a>3. Verilog 的基本词法</h1><p>Verilog HDL 是一种<strong>大小写敏感</strong>的语言，这一点与 VHDL 不同，因此在书写的时候要格外注意。在 Verilog 语言中，<strong>所有的关键字（又叫保留字）都为小写</strong>。Verilog 的内部信号名（或称为标识符）使用大写和小写都可以。标识符可以是字母、数字、<code>$</code>（美元符号）和 <code>_</code>（下划线）任意组合，只要<strong>第一个字符是字母或者下划线</strong>即可。</p>
<blockquote>
<p>因为 Verilog HDL 对大小写敏感，因此养成良好的信号定义习惯非常重要，否则容易因为大小写不同造成信号的歧义。推荐的信号定义习惯为：<strong>所有信号和网线名均小写，用下划线分割单词，而宏变量全部用大写字母。</strong></p>
</blockquote>
<p>在上述<a href="#JoshVerilog代码">代码</a>中，用双反斜线 <code>//</code> 表示注释。另外，还有一种注释方式，用 <code>/* ...... */</code> 来表示。所不同的是前者为单行注释，而后者将 <code>/*</code> 和 <code>*/</code> 之间的内容全部看作注释内容。</p>
<blockquote>
<p>通常，注释的内容只是作者为了增强代码的可读性而增加的内容，对整个代码的功能没有任何影响。不过，在一些工具中，尤其是逻辑综合工具，定义了一些特殊的指令，用于控制工具编译过程。这些指令也是以注释的方式出现的。例如：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">moduleblbox(out, data, clk) <span class="comment">/* synthesis syn_black_box */</span>;</span><br></pre></td></tr></table></figure>
<p>在 <code>modulebl_box</code> 的声明处有一行注释，用 <code>/* ...... */</code> 表示。它看起来是一个注释，实际上，是综合工具Synplify中的一个指令，指示 Synplify 将该模块看作一个黑盒（black_box），不处理模块内部的描述。</p>
</blockquote>
<p>在 Verilog 中，通常使用空格符、跳格符和换行符作为间隔。在书写代码的时候，适当运用间隔符可以提高代码的可读性。比如在声明 4 个 <code>reg</code> 型数据 <code>eq0~eq3</code> 时，可以采用上述<a href="#JoshVerilog代码">例子</a>中的方法：</p>
<figure class="highlight verilog"><figcaption><span>Josh.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">reg</span> eq0, eq1, eq2, eq3;</span><br></pre></td></tr></table></figure>
<p>也可以用换行符将其分开：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">reg</span> eq0;</span><br><span class="line"><span class="keyword">reg</span> eq1;</span><br><span class="line"><span class="keyword">reg</span> eq2;</span><br><span class="line"><span class="keyword">reg</span> eq3;</span><br></pre></td></tr></table></figure>
<p>在verilog中，还有一些转义字符。比如 <code>\n</code> 表示换行符；<code>\t</code> 表示 Tab 键；防止引起歧义，就用 <code>\</code> 表示 <code>\</code> 符号本身等等。这里不再对 Verilog 的词法做过多的描述，更多可以参考 Verilog IEEE 国际标准（<a href="https://standards.ieee.org/standard/1364-2005.html">IEEE Std. 1364-2005</a>）。</p>
<h1 id="4-模块和端口"><a href="#4-模块和端口" class="headerlink" title="4. 模块和端口"></a>4. 模块和端口</h1><p>大型设计往往是由一个个模块构成的。实际上，模块可大可小，大到一个复杂的微处理器系统，小到一个基本的晶体管，都可以作为一个模块来设计。例如，在上述代码中描述的 <a href="#JoshVerilog代码">JoshVerilog</a> 就是一个模块。</p>
<p>在 Verilog 中，模块（module）是基本的组成单位。</p>
<blockquote>
<p>通常，建议在一个 Verilog 文件中，只放一个 <code>module</code> 定义，而且使文件名称和 <code>module</code> 名称一致。这是一个良好的设计习惯。</p>
</blockquote>
<p>以下是 Verilog 中 <code>module</code> 的基本语法：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> 模块名称( 端口列表 );</span><br><span class="line"><span class="comment">// 声明：</span></span><br><span class="line">    <span class="keyword">reg</span>, <span class="keyword">parameter</span>,</span><br><span class="line">    <span class="keyword">input</span>, <span class="keyword">output</span>, </span><br><span class="line">    <span class="keyword">function</span>, <span class="keyword">task</span>, ...</span><br><span class="line"><span class="comment">// 语句：</span></span><br><span class="line">    <span class="keyword">initial</span> 语句</span><br><span class="line">    <span class="keyword">always</span> 语句</span><br><span class="line">    <span class="keyword">module</span> 实例化</span><br><span class="line">    门实例化</span><br><span class="line">    用户定义原语 (UDP) 实例化</span><br><span class="line">    连续赋值 (Continous assignment)</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>首先，需要有一个名称来标识这个 <code>module</code>。</p>
<p>通常 <code>module</code> 具有输入和输出端口，在 <code>module</code> 名称后面的括号中列出所有的输入、输出和双向的端口名称。</p>
<p>有些 <code>module</code> 也不包含端口。例如，在仿真平台的顶层模块中，其内部已经实例化了所有的设计模块和激励模块，是一个封闭的系统，没有输入和输出。一般这种没有端口的模块都是用于仿真的，不用作实际电路。</p>
<p>在 <code>module</code> 内部的声明部分，需要声明端口的方向，（<code>input</code>, <code>output</code> 和 <code>inout</code>）和位宽。按照 Verilog 的习惯，<strong>高位写在左边，低位写在右边</strong>。比如</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">input</span> [<span class="number">1</span>:<span class="number">0</span>] A_in；</span><br></pre></td></tr></table></figure>
<p>就表示两位的总线。</p>
<p>模块内部使用的 <code>reg</code>（寄存器类型的一种）、<code>wire</code>（线网类型的一种）、参数、函数以及任务等，都将在 <code>module</code> 中声明。</p>
<p>一般来说，<code>module</code> 的 </p>
<ul>
<li><code>input</code> 默认定义为 <code>wire</code> 类型；</li>
<li><code>output</code> 信号可以是 <code>wire</code>，也可以是 <code>reg</code> 类型（如果在 <code>always</code> 或 <code>initial</code> 语句块中被赋值）；</li>
<li><code>inout</code> 是双向信号，一般将其设为 <code>tri</code> 类型，表示其有多个驱动源，如无驱动时为三态。</li>
</ul>
<p>虽然变量声明只要出现在使用的相应语句之间即可，但还是建议将所有的声明放在所有的语句之前，这样具有较好的可读性。在声明之后，就应该是语句了。语句有如下几种：</p>
<ul>
<li><code>initial</code> 语句；</li>
<li><code>always</code> 语句；</li>
<li>其他子 <code>module</code> 实例化；</li>
<li>门实例化；</li>
<li>用户定义原语（UDP）实例化；</li>
<li>连续赋值（Continous assignment）。</li>
</ul>
<p>Verilog 中所有的功能描述都是通过以上几种描述方式进行的。</p>
<blockquote>
<p>需要格外注意的是，以上几种语句如果出现在同一个 <code>module</code> 内，其<strong>相互之间是没有任何顺序关系的</strong>，它们在 <code>module</code> 中出现顺序的改变不会改变 <code>module</code> 的功能，这正是硬件的一大特点。有硬件电路原理图设计经验的读者们可以想象一下画原理图的过程，先画哪个，后画哪个器件根本没有任何关系。在 Verilog 中也是类似的道理。</p>
</blockquote>
<h1 id="5-编译指令"><a href="#5-编译指令" class="headerlink" title="5. 编译指令"></a>5. 编译指令</h1><p>在 Verilog 语言中，提供了一些编译指令，用于指导编译器的工作。例如，定义宏、文件包含、条件编译、时间单位和精度定义等。</p>
<p>Verilog 中的编译指令是从 C 语言中的“预处理指令”演变得来的。这里列出了一些常用的编译指令如下：</p>
<ul>
<li><code>`timescale</code>；</li>
<li><code>`define, `undef</code>；</li>
<li><code>`ifdef, `else, `endif</code>；</li>
<li><code>`include</code>；</li>
<li><code>`resetall</code>。</li>
</ul>
<p>与 C 语言中使用的 <code>#</code> 不同，Verilog 中使用反引号一来标识编译指令。编译器一旦遇到某个编译指令，则其在整个编译过程中有效，可以包含多个文件，直到编译器遇到另一个相同的编译指令。</p>
<h2 id="5-1-timescale"><a href="#5-1-timescale" class="headerlink" title="5.1. `timescale"></a>5.1. <code>`timescale</code></h2><p>在每一个 <code>module</code> 文件前面加上<code>` </code>的编译指令，就可以保证该文件中的延时信息受其自身文件中的 <code>`timescale</code> 编译指令指导。<strong>否则在编译过程中，该模块将沿用上一个</strong> <code>`timescale</code> <strong>的值，或者使用缺省值</strong>。</p>
<p>在上述实例代码中描述的 <a href="#JoshVerilog代码">JoshVerilog</a> 模块中使用了一个<code>`timescale 1ns/100ps</code> 编译指令。其中 <code>1ns</code> 表示延时单位，<code>100ps</code> 表示时间精度，也就是编译器所能接收的最小仿真时间粒度。<code>`timescale</code> 编译指令在模块外部出现，并且影响后面模块中所有的时延值，直到遇到下一个 <code>`timescale</code> 或 <code>`resetall</code>指令。</p>
<p>比如语句：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> #<span class="number">1</span><span class="variable">.16</span> A_xor_wire = eq0 ^ eq1;</span><br></pre></td></tr></table></figure>
<p>如果采用 <code>`timescale 1ns/100ps</code> 编译指令由于延时单位是 <code>1ns</code>，同时最小时间粒度是 <code>100ps</code>，即 <code>0.1ns</code> ，那么根据四舍五入的规则，<code>1.16ns</code> 则实际上对应 <code>1.2ns</code> 延时。如果采用 <code>`timescale 1ns/10ps</code> 编译指令，由于延时单位是 <code>1ns</code>，同时最小时间粒度是 <code>10ps</code>，即 <code>0.01ns</code>，那么 <code>1.16ns</code> 则实际上对应 <code>1.16ns</code> 延时。</p>
<h2 id="5-2-define-和-undef"><a href="#5-2-define-和-undef" class="headerlink" title="5.2. `define 和 `undef"></a>5.2. <code>`define</code> 和 <code>`undef</code></h2><p><code>`define</code> 用于定义宏。例如，首先定义一个总线宽度的宏为 16，然后利用这个宏定义一个宽度为 16 的 <code>reg</code>类型数据 <code>Data</code>，方法如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="meta-keyword">define</span> BUS_WIDTH 16</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="meta">`BUS_WIDTH - 1 : 0] Data</span></span><br></pre></td></tr></table></figure>
<p>在一个文件中出现的 <code>`define</code>，可以被多个文件使用。也就是说 <code>`define</code> 是一种<strong>全局的定义</strong>。这是 <code>`define</code> 与 <code>parameter</code> 定义的最大区别，在后面也会提到。</p>
<p><code>`define</code> 指令被编译以后，则在整个编译过程中都有效，直到遇到 <code>`undef</code> 指令，该宏就不再有效。如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="meta-keyword">undef</span> BUS_WIDTH</span></span><br></pre></td></tr></table></figure>
<p>遇到该编译指令后，先前的 <code>`define</code> 指令失效。</p>
<h2 id="5-3-ifdef、-else-和-endif"><a href="#5-3-ifdef、-else-和-endif" class="headerlink" title="5.3. `ifdef、`else 和`endif"></a>5.3. <code>`ifdef</code>、<code>`else</code> 和<code>`endif</code></h2><p>再来看看如下的条件编译指令：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="meta-keyword">ifdef</span> NARROW</span></span><br><span class="line">    <span class="keyword">parameter</span> BUS_WIDTH = <span class="number">16</span>；</span><br><span class="line"><span class="meta">`<span class="meta-keyword">else</span></span></span><br><span class="line">    paramete rBUS_WIDTH = <span class="number">32</span>；</span><br><span class="line"><span class="meta">`<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>在这个条件编译指令中，如果先前已经定义了 <code>NARROW</code> 宏，那么参数 <code>BUS_WIDTH</code> 被设置为 16，否则其被设置为 32。<code>`else</code> 指令对于 <code>`ifdef</code> 来说是可选的，也就是说可以单独使用。</p>
<h2 id="5-4-include"><a href="#5-4-include" class="headerlink" title="5.4. `include"></a>5.4. <code>`include</code></h2><p>在 Verilog 中，可以使用 <code>`include</code> 指令来嵌人某个文件的内容。例如：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="meta-keyword">include</span> &quot;HEADFILE.h&quot;</span></span><br></pre></td></tr></table></figure>
<p>那么，在编译的时候，就将使用 <code>HEADFILE.h</code> 文件中的内容完全替换这一行语句。而双引号中的文件可以使用相对路径，或绝对路径，或者默认在当前路径以下。</p>
<h2 id="5-5-resetall"><a href="#5-5-resetall" class="headerlink" title="5.5. `resetall"></a>5.5. <code>`resetall</code></h2><p><code>`resetall</code> 编译指令会将所有其他编译指令重新设置为缺省值，要谨慎使用。</p>
<blockquote>
<p>Verilog 语言中的编译指令不止这几条，其他不常用的指令这里不一一介绍，有兴趣可以参考其他文献。</p>
</blockquote>
<h1 id="6-逻辑值与常量"><a href="#6-逻辑值与常量" class="headerlink" title="6. 逻辑值与常量"></a>6. 逻辑值与常量</h1><h2 id="6-1-逻辑值"><a href="#6-1-逻辑值" class="headerlink" title="6.1. 逻辑值"></a>6.1. 逻辑值</h2><p>在二进制计数中，单位逻辑值只有 <code>1</code> 和 <code>0</code> 两种状态。而在 Verilog 语言中，为了对电路进行精确建模，于是增加了两种逻辑状态 <code>X</code> 和 <code>Z</code>。</p>
<ul>
<li><code>X</code> 表示未知值（unknown），或者不关心（don’t care），<code>X</code> 用作信号状态时表示未知，用在条件判断时（在 <code>casex</code> 或 <code>casez</code>中）表示不关心；</li>
<li><code>Z</code> 表示高阻状态，也就是<strong>没有任何驱动</strong>，通常用来对<strong>三态总线</strong>进行建模。</li>
</ul>
<p>在后面将提到 Verilog 语言中的变量类型。通常 <code>net</code> 型变量如果没有初始化，其值为 <code>Z</code>，<code>register</code> 型变量如果没有初始化，其值为 <code>X</code> 。这一点在仿真时显得比较有意义。</p>
<blockquote>
<p>但是，对综合工具而言（或者说在实际电路中），并没有什么 <code>X</code> 值，只存在 <code>0</code>、<code>1</code> 和 <code>Z</code> 这 3 种状态。在实际电路中还可能出现亚稳态，它既不是 <code>0</code>，也不是 <code>1</code>，是一种暂时的不稳定状态。</p>
</blockquote>
<p>Verilog 语言中所有数据都是由以上描述的 4 种基本的逻辑值 <code>0</code>、<code>1</code>、<code>X</code> 和 <code>Z</code> 构成。同时，<code>X</code> 和 <code>Z</code> 是不区分大小写的。例如：<code>0z1x</code> 和 <code>0Z1X</code> 表示同一个数据。</p>
<h2 id="6-2-常量"><a href="#6-2-常量" class="headerlink" title="6.2. 常量"></a>6.2. 常量</h2><p>常量是 Verilog 中不变的数值。在上述<a href="#JoshVerilog代码">实例代码</a>中，<code>4&#39;b0001</code> 就表示一个 4 位的二进制整型常量：0001。</p>
<p>Verilog中的常量有3种：</p>
<ul>
<li>整数型；</li>
<li>实数型；</li>
<li>字符串型。</li>
</ul>
<h3 id="6-2-1-整型常量"><a href="#6-2-1-整型常量" class="headerlink" title="6.2.1. 整型常量"></a>6.2.1. 整型常量</h3><p>可以使用简单的十进制表示一个整型常量，例如：</p>
<ul>
<li><code>16</code> 表示十进制的 16；</li>
<li><code>-15</code> 表示十进制的 -15，用二进制补码表示，至少需要 5 位，即 10001，最高一位为符号位；如果用 6 位表示，则是 110001，同样最高一位为符号位。</li>
</ul>
<p>整数型常量也可以采用基数表示法，例如：</p>
<ul>
<li><code>8&#39;haa</code>：表示 8 位的<strong>十六进制数</strong>，换算成二进制是 1010_1010。</li>
<li><code>6&#39;o33</code>：表示 6 位的<strong>八进制数</strong>，换算成二进制是 011_011。</li>
<li><code>4&#39;b1011</code>：表示 4 位的<strong>二进制数</strong> 1011。</li>
<li><code>3&#39;d7</code>：表示 3 位<strong>十进制</strong>的 7。</li>
</ul>
<p>在基数表示法中，都是以如下格式写的：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">[长度]&#x27;数值符号 数字</span><br></pre></td></tr></table></figure>
<p>其中长度可有可无，数值符号中，<code>h</code> 表示十六进制，<code>o</code> 表示八进制，<code>b</code> 表示二进制，<code>d</code> 表示十进制数据。如果长度比后面数字的实际位数多，则<strong>自动在数字的左边补足 0</strong>；如果位数少，则<strong>自动截断数字左边超出的位数</strong>。</p>
<p>如果将数字写成 <code>&#39;haa</code>，那么这个十六进制数的长度就决定于数字本身的长度。</p>
<p>在基数表示法中，如果遇到 <code>X</code>，十六进制数中表示 4 个 <code>X</code>，八进制数中表示 3 个 <code>X</code>。</p>
<p>另外，数字中的下划线没有任何意义，只是增强可读性。例如：<code>4&#39;b1011</code> 和 <code>4&#39;b10_11</code> 一样。</p>
<h3 id="6-2-2-实数型常量"><a href="#6-2-2-实数型常量" class="headerlink" title="6.2.2. 实数型常量"></a>6.2.2. 实数型常量</h3><p>Verilog 语言中的实数型变量可以采用十进制，也可以采用科学计数法，例如：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span><span class="variable">.512</span></span><br><span class="line"><span class="number">13_2</span><span class="variable">.18e2</span>       <span class="comment">// 表示13218</span></span><br></pre></td></tr></table></figure>
<h3 id="6-2-3-字符串型常量"><a href="#6-2-3-字符串型常量" class="headerlink" title="6.2.3. 字符串型常量"></a>6.2.3. 字符串型常量</h3><p>字符串是双引号中的字符序列，例如：<code>&quot;HeIIo World&quot;</code>。字符串是 8 位 ASCII 码值的序列，<code>&quot;HeIIo World&quot;</code> 就需要 11 字节存储，方法如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">reg</span>[<span class="number">1</span>:<span class="number">8</span> * <span class="number">11</span>] Message;</span><br><span class="line">Message = <span class="string">&quot;HeIIo World&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>这样就将字符串常量存人到 Message 变量中。</p>
<h1 id="7-变量类型"><a href="#7-变量类型" class="headerlink" title="7. 变量类型"></a>7. 变量类型</h1><p>在 Verilog 语言中，有两大变量类型：</p>
<ul>
<li>线网型：表示电路间的物理连线。</li>
<li>寄存器型：Verilog 中的一个抽象的存储数据单元。</li>
</ul>
<p>对于初学者而言，则需要首先遵守如下的简单规则：</p>
<ul>
<li><strong>凡是在</strong> <code>always</code> <strong>或</strong> <code>initial</code> <strong>语句中赋值的变量，一定是寄存器变量</strong>；</li>
<li><strong>在</strong> <code>assign</code> <strong>中赋值的一定是线网变量</strong>。</li>
</ul>
<h2 id="7-1-线网类型"><a href="#7-1-线网类型" class="headerlink" title="7.1. 线网类型"></a>7.1. 线网类型</h2><p>在线网类型下，分为几种子类，它们具有线网的共性：</p>
<ul>
<li><code>wire</code>、<code>tri</code>：表示电路间连线，<code>tri</code> 主要用于多驱动源建模；</li>
<li><code>wor</code>、<code>trior</code>：表示该连线具有“线或”功能；</li>
<li><code>wand</code>、<code>triand</code>：表示该连线具有“线与”功能；</li>
<li><code>trireg</code>：表示该连线具有总线保持功能；</li>
<li><code>tri1</code>、<code>tri0</code>：表示当无驱动时，连线状态为1（<code>tri1</code>）和0（<code>tri0</code>）；</li>
<li><code>supply1</code>、<code>supply0</code>：分别表示电源和地信号。</li>
</ul>
<p>在以上描述的线网类型中，除了 <code>trireg</code> 未初始化时为 <code>X</code> 以外，其余的未初始化时的值为 <code>Z</code>。</p>
<p>线网类型主要用在连续赋值语句中，以及作为模块之间的互连信号。</p>
<p>在后面的内容中会详细阐述常用线网类型的使用方法。</p>
<h2 id="7-2-寄存器类型"><a href="#7-2-寄存器类型" class="headerlink" title="7.2. 寄存器类型"></a>7.2. 寄存器类型</h2><p>寄存器类型变量在 Verilog 语言中通常表示一个存储数据的空间。尤其是在 Verilog 仿真器中，寄存器类型变量通常占据一个仿真内存空间。</p>
<ul>
<li><code>reg</code>：是最常用的寄存器类型数，可以是 1 位或者多位，或者是二维数组（存储器）；</li>
<li><code>integer</code>：整型数据，存储一个至少 32 位</li>
<li><code>time</code>：时间类型，存储一个至少 64 位的时间值；</li>
<li><code>real</code>，<code>realtime</code>：实数和实数时间寄存器。</li>
</ul>
<h3 id="7-2-1-reg-类型"><a href="#7-2-1-reg-类型" class="headerlink" title="7.2.1 reg 类型"></a>7.2.1 <code>reg</code> 类型</h3><ol>
<li><p>寄存器类型数</p>
<p> <code>reg</code> 类型可以定位为一个寄存器，可以定义一位或者多位，例如：</p>
 <figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">reg</span>         AB;             <span class="comment">// 定义一个名为 AB 的 1 位寄存器</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>]   ABC;            <span class="comment">// 定义一个名为 ABC 的 4 位寄存器</span></span><br></pre></td></tr></table></figure>
<p> 在多位寄存器中，可以作“位选择”或“部分选择”，例如：</p>
 <figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">ABC [<span class="number">3</span>] = <span class="number">1</span>;                <span class="comment">// 将 ABC 的第 3 位赋值为 1</span></span><br><span class="line">ABC [<span class="number">0</span>] = <span class="number">0</span>;                <span class="comment">// 将 ABC 的第 0 位赋为 0</span></span><br><span class="line">ABC [<span class="number">2</span>:<span class="number">1</span>] = <span class="number">2&#x27;b01</span>;          <span class="comment">// 将 ABC 的第 1、2 位赋值为 1 和 0</span></span><br></pre></td></tr></table></figure>
<p> 这样，整个 <code>ABC</code> 变量的值为 <code>4&#39;b1010</code>。</p>
</li>
<li><p>寄存器类型数组</p>
<p> <code>reg</code> 类型可以作为二维数组，也就是存储器，例如：</p>
 <figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] MEMABC [<span class="number">0</span>:<span class="number">7</span>];     <span class="comment">// 定义一个存储器，地址为 0~7，每个存储单元是 4 位</span></span><br></pre></td></tr></table></figure>
<p> 与一维的 <code>reg</code> 变量不同的是，存储器中的存储单元不能再做位选择或部分选择，而每个单元可以单独赋值。比如：</p>
 <figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">MEMABC[<span class="number">1</span>] = <span class="number">4&#x27;b0101</span>;        <span class="comment">// 为 MEMABC 中的第 1 个存储单元赋值 4&#x27;b0101</span></span><br></pre></td></tr></table></figure>
<p> 同时，在 Verilog 中，不存可以对整个存储器赋值的语句，必须对每个单元独立赋值。除非使用 <code>$readmemb</code> 或 <code>$readmemh</code> 系统任务从文件中读入整个或者部分存储器的数据。</p>
</li>
</ol>
<h3 id="7-2-2-integer-类型"><a href="#7-2-2-integer-类型" class="headerlink" title="7.2.2. integer 类型"></a>7.2.2. <code>integer</code> 类型</h3><p><code>integer</code> 变量通常用于高层次建模，也常用在 <code>for</code> 语句的索引中，例如：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">initial</span></span><br><span class="line"><span class="keyword">begin</span>: ACCESS</span><br><span class="line">    <span class="keyword">integer</span> i;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">7</span>; i = i + <span class="number">1</span> )        <span class="comment">// 定义一个整数变量 i</span></span><br><span class="line">        MEMABC[i] = i                       <span class="comment">// 遍历 0～7 地址</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3 id="7-2-3-其他寄存器类型"><a href="#7-2-3-其他寄存器类型" class="headerlink" title="7.2.3. 其他寄存器类型"></a>7.2.3. 其他寄存器类型</h3><p>另外，<code>time</code> 变量用于存储和处理系统时间，<code>real</code> 和 <code>realtime</code> 用来存储实数和实数时间。</p>
<h2 id="7-3-变量的物理含义"><a href="#7-3-变量的物理含义" class="headerlink" title="7.3. 变量的物理含义"></a>7.3. 变量的物理含义</h2><p>这里需要引起重视，<strong>“线网”变量可以理解为电路模块中的连线，但“寄存器”并不严格对应于电路上的存储单元</strong>，包括触发器（flip-flop）或锁存器（latch）。从纯粹语言表达的语义角度来说，寄存器类型变量的值，从一个赋值到下一个赋值被保存下来，并且在仿真过程中会保持而不会丢失。</p>
<p>实际上，从语义上来讲，在 Verilog 仿真工具对语言进行仿真的时候，<strong>寄存器类型的变量是占用仿真环境的物理内存的</strong>，这与 C 语言中的变量类似。寄存器在被赋值后，便一直保存在内存中，保持该值不变，直到再次对该寄存器变量进行赋值。而<strong>线网类型是不占用仿内存的</strong>，它的值是由当前所有驱动该线网的其他变量（可以是寄存器或线网）决定的。这是寄存器和线网最大的区别，也是当初 Verilog 的发明者定义“线网”和“寄存器”变量的根本动机。</p>
<p>在下一小节中，将引人“驱动”和“赋值”两个概念，深人探讨两种变量的含义。</p>
<h2 id="7-4-驱动和赋值"><a href="#7-4-驱动和赋值" class="headerlink" title="7.4. 驱动和赋值"></a>7.4. 驱动和赋值</h2><p>为了更清楚地描述寄存器和线网变量的概念，将以上述<a href="#JoshVerilog代码">实例代码</a>中的语句来说明。首先，引人Verilog 语言中两个重要的概念：驱动（Driving）和赋值（Assigning)。</p>
<ul>
<li><strong>线网是被驱动的，该值不被保持，在任意一个仿真步进上都需要重新计算</strong>；</li>
<li><strong>寄存器是被赋值的，且该值在仿真过程中被保持，直到下一个赋值的出现</strong>。</li>
</ul>
<p>在上述<a href="#JoshVerilog代码">实例代码</a>中，定义了一个 <code>A_xor_wire</code> 的 <code>wire</code>，它是 <code>eq0</code> 和 <code>eq1</code> 相异或的结果。采用如下描述方式：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> #<span class="number">1</span> A_xor_wire = eq0 ^ eq1;</span><br></pre></td></tr></table></figure>
<p>实际上，也可以采用如下的另一种描述方式：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @(eq0 <span class="keyword">or</span> eq1)</span><br><span class="line">    A_xor_wire = #<span class="number">1</span> eq0 ^ eq1;</span><br></pre></td></tr></table></figure>
<p>当然需要在 <code>module</code> 的声明处，将 <code>A_xor_wire</code> 首先定义成 <code>reg</code> 变量，而不是 <code>wire</code> 变量，即需要做如下定义：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">reg</span> A_xor_wire</span><br></pre></td></tr></table></figure>
<p>这两者描述的目的一样，都是一个异或门，如下图所示。</p>
<div align="center">
  <img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-28-josh-verilog-part-2/2020-11-28-josh-verilog-part-2-020-XORGate.png!700px"/>
</div>

<p>下面从语义上的角度探讨两种描述方式的不同。</p>
<p>第一种描述方式使用 <code>assign</code> 语句，Verilog 中将其称为连续赋值语句（Continously Assignment）实际上是<strong>连续驱动</strong>的过程。也就是说，在任意一个仿真时刻，当前时刻 <code>eq0</code> 和 <code>eq1</code> 相异或的结果决定了 <code>1ns</code> 以后（语句 <code>#1</code> 的延时控制）的线网变量 <code>A_xor_wire</code> 的值，<strong>不管 <code>eq0</code> 和 <code>eq1</code> 变化与否，这个驱动过程一直存在</strong>，因此称为连续驱动。（在仿真器中，线网变量是不占用仿真内存空间的。）如上<a href="#异或门">异或门图</a>中的时序所示，这个驱动过程在任意时刻都存在。</p>
<p>在第二种描述方式中使用了 <code>always</code> 语句，后面紧跟着一个敏感列表：<code>@(eq0 or eq1)</code> 因此，这个语句只有在 <code>eq0</code> 或 <code>eq1</code> 发生变化时才会执行。如上<a href="#异或门">异或门图</a>中，在时刻 2、3 和 6，该语句都将执行，将 <code>eq0</code> 和 <code>eq1</code> 赋值的结果延时 1ns 以后赋值给 <code>A_xor_wire</code> 变量。<strong>在其他时刻，<code>A_xor_wire</code> 变量必须保持</strong>。因此，<strong>从仿真语义上讲，需要一个存储单元，也可以说是寄存器，来保存 <code>A_xor_wire</code> 变量的中间值</strong>。这就是Verilog 语言的“寄存器类型”变量的来历，而这个 <code>A_xor_wire</code> 变量首先需要定义为 <code>reg</code> 类型。</p>
<p>不管采用哪种方式，所描述的是一样的组合逻辑电路。尤其是第二种描述，虽然其在语言中被定义为 reg 型，但并不是对应硬件上的触发器（flip-flop），而是 Verilog 语言仿真语义上的寄存器概念。</p>
<p>但是，在对实际电路中D触发器建模的时候，必须采用 <code>reg</code> 型的变量。下图是 D 触发器的模型。</p>
<div align="center">
  <img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-28-josh-verilog-part-2/2020-11-28-josh-verilog-part-2-030-DFlipFlop.png!300px"/>
</div>

<p>在上述<a href="#JoshVerilog代码">实例代码</a>中相应的描述如下：</p>
<figure class="highlight verilog"><figcaption><span>Josh.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">    <span class="keyword">if</span> (~rst_n)</span><br><span class="line">        A_xor_out &lt;= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        A_xor_out &lt;= A_xor_wire;</span><br></pre></td></tr></table></figure>
<p>D 触发器只对时钟和复位（置位）敏感，因此在敏感列表中，列出了 <code>clk</code> 的上升沿和 <code>rst_n</code> 的下降沿。如果 <code>rst_n</code> 为 0，就对触发器的输出复位，否则在 <code>clk</code> 的时钟上升沿发生的时候，将输人的 <code>A_xor_wire</code> 寄存到触发器的输出端 <code>A_xor_out</code>。</p>
<p>这样的代码精确地描述了一个 D 触发器的行为。这里的 <code>reg</code> 变量就对应了硬件中的 D 触发器。</p>
<p>在叙述时，为了简单起见，常常将“驱动”和“赋值”都统一说成是赋值，但是一定要清楚其中的本质。</p>
<h1 id="8-参数"><a href="#8-参数" class="headerlink" title="8. 参数"></a>8. 参数</h1><p>参数是一种常量，通常出现在 <code>module</code> 内部。它常常被用作定义状态机的状态、数据位宽和延时大小等等。例如：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">parameter</span> and_delay = <span class="number">2</span>；</span><br><span class="line"><span class="keyword">parameter</span> xor_delay = <span class="number">4</span>；</span><br></pre></td></tr></table></figure>
<p><strong>参数的值可以在编译时被改变</strong>，因此它又<strong>经常被用于一些参数可调的模块中</strong>，让用户在实例化模块时，根据需要配置参数。</p>
<p>前面介绍的 <code>`define</code> 是一种全局的定义，而 <code>parameter</code> 是出现在模块内部的<strong>局部定义</strong>，而且可以被<strong>灵活改变</strong>，这是 <code>parameter</code> 的一个重要特征。</p>
<p>在<a href="https://josh-gao.blog.csdn.net/article/details/105262549#42__865">《Part 3——描述方式和设计层次》的 4.2 小节</a>中会详细探讨改变模块参数的方法。</p>
<h1 id="9-Verilog-中的并发与顺序"><a href="#9-Verilog-中的并发与顺序" class="headerlink" title="9. Verilog 中的并发与顺序"></a>9. Verilog 中的并发与顺序</h1><p>并行概念是硬件中的一个非常重要的概念，特别是初学者或软件工程师们需要重点理解。</p>
<p>与在处理器上运行的软件不同的是，<strong>硬件电路之间的工作是并行的</strong>。</p>
<p>为了描述硬件的并行性，Verilog 语言本身就具有并发的特性。在 Verilog 语言的 <code>module</code> 中，所有的描述语句（包括连续赋值语句，行为语句块：<code>always</code> 和 <code>initial</code>，模块实例化等）之间都是并行发生的。任何功能描述语句，在 Verilog 的 module 中的顺序都不重要。</p>
<p>但是，在语句块（<code>always</code> 和 <code>initial</code>）内部，则可以存在两种语句组：</p>
<ul>
<li><code>begin ... end</code>：顺序语句组；</li>
<li><code>fork ... join</code>：并行语句组。</li>
</ul>
<p>在 <code>begin ... end</code> 中存在的语句，按照 Veilog 的语义，应该是顺序执行的。而在 <code>fork ... join</code> 中的语句，则是并行执行的。</p>
<p>相比较顺序运行的事物，并行的事物比较难以理解和建模。同时，用于仿真的计算机是串行执行的，而 Verilog 语言本身的语义是用计算机进行模拟的语义，是用一种串行的语义来模拟并行的硬件。</p>
<p>Verilog 仿真器用来模拟硬件的并行行为的方式类似于软件中的多任务操作系统，在某个时刻只能执行一个任务，这样，不同的任务之间看起来是并行执行的。</p>
<p>后续将会重点介绍 Verilog 语言中的这一并行特性，同时阐述 Verilog 的高级仿真原理，希望能帮助大家领会 Verilog 的语义精髓。</p>
<h1 id="10-操作数、操作符和表达式"><a href="#10-操作数、操作符和表达式" class="headerlink" title="10. 操作数、操作符和表达式"></a>10. 操作数、操作符和表达式</h1><h2 id="10-1-操作符"><a href="#10-1-操作符" class="headerlink" title="10.1. 操作符"></a>10.1. 操作符</h2><p>操作符是操作数之间的运算符号。在介绍操作数之前，先来看看 Verilog 中的各种操作符。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">操作符</th>
<th style="text-align:left">含义</th>
<th style="text-align:left">操作符</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>+</code></td>
<td style="text-align:left">一元加</td>
<td style="text-align:left"><code>&gt;&gt;</code></td>
<td style="text-align:left">右移</td>
</tr>
<tr>
<td style="text-align:left"><code>-</code></td>
<td style="text-align:left">一元减</td>
<td style="text-align:left"><code>&lt;</code></td>
<td style="text-align:left">小于</td>
</tr>
<tr>
<td style="text-align:left"><code>!</code></td>
<td style="text-align:left">一元逻辑非</td>
<td style="text-align:left"><code>&lt;=</code></td>
<td style="text-align:left">小于等于</td>
</tr>
<tr>
<td style="text-align:left"><code>~</code></td>
<td style="text-align:left">一元按位求反</td>
<td style="text-align:left"><code>&gt;</code></td>
<td style="text-align:left">大于</td>
</tr>
<tr>
<td style="text-align:left"><code>&amp;</code></td>
<td style="text-align:left">归约与</td>
<td style="text-align:left"><code>&gt;=</code></td>
<td style="text-align:left">大于等于</td>
</tr>
<tr>
<td style="text-align:left"><code>~&amp;</code></td>
<td style="text-align:left">归约与非</td>
<td style="text-align:left"><code>==</code></td>
<td style="text-align:left">逻辑相等</td>
</tr>
<tr>
<td style="text-align:left"><code>^</code></td>
<td style="text-align:left">归约异或</td>
<td style="text-align:left"><code>!=</code></td>
<td style="text-align:left">逻辑不等</td>
</tr>
<tr>
<td style="text-align:left"><code>^~</code> 或 <code>~^</code></td>
<td style="text-align:left">归约异或非</td>
<td style="text-align:left"><code>===</code></td>
<td style="text-align:left">全等</td>
</tr>
<tr>
<td style="text-align:left"><code>&#124;</code></td>
<td style="text-align:left">归约或</td>
<td style="text-align:left"><code>!==</code></td>
<td style="text-align:left">非全等</td>
</tr>
<tr>
<td style="text-align:left"><code>~&#124;</code></td>
<td style="text-align:left">归约或非</td>
<td style="text-align:left"><code>&amp;</code></td>
<td style="text-align:left">按位与</td>
</tr>
<tr>
<td style="text-align:left"><code>*</code></td>
<td style="text-align:left">乘</td>
<td style="text-align:left"><code>^</code></td>
<td style="text-align:left">按位异或</td>
</tr>
<tr>
<td style="text-align:left"><code>/</code></td>
<td style="text-align:left">除以</td>
<td style="text-align:left"><code>^~</code> 或 <code>~^</code></td>
<td style="text-align:left">按位异或非</td>
</tr>
<tr>
<td style="text-align:left"><code>%</code></td>
<td style="text-align:left">取模</td>
<td style="text-align:left"><code>&#124;</code></td>
<td style="text-align:left">按位或</td>
</tr>
<tr>
<td style="text-align:left"><code>+</code></td>
<td style="text-align:left">二元加</td>
<td style="text-align:left"><code>&amp;&amp;</code></td>
<td style="text-align:left">逻辑与</td>
</tr>
<tr>
<td style="text-align:left"><code>-</code></td>
<td style="text-align:left">二元减</td>
<td style="text-align:left"><code>&#124;&gt;&#124;</code></td>
<td style="text-align:left">逻辑或</td>
</tr>
<tr>
<td style="text-align:left"><code>&lt;&lt;</code></td>
<td style="text-align:left">左移</td>
<td style="text-align:left"><code>? :</code></td>
<td style="text-align:left">条件操作符</td>
</tr>
</tbody>
</table>
</div>
<p>其中，一元操作表示仅有一个操作数，二元操作表示有两个操作数。归约操作也是只有一个操作数，它是该操作数中的所有位之间的计算。</p>
<h3 id="10-1-1-算术操作符"><a href="#10-1-1-算术操作符" class="headerlink" title="10.1.1. 算术操作符"></a>10.1.1. 算术操作符</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">操作符</th>
<th style="text-align:center">表达式</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>+</code></td>
<td style="text-align:center"><code>m + n</code></td>
<td style="text-align:center">将 <code>n</code> 与 <code>m</code> 相加</td>
</tr>
<tr>
<td style="text-align:center"><code>-</code></td>
<td style="text-align:center"><code>m - n</code></td>
<td style="text-align:center">将 <code>m</code> 减去 <code>n</code></td>
</tr>
<tr>
<td style="text-align:center"><code>-</code></td>
<td style="text-align:center"><code>-m</code></td>
<td style="text-align:center">将 <code>m</code> 取反（二进制补码）</td>
</tr>
<tr>
<td style="text-align:center"><code>*</code></td>
<td style="text-align:center"><code>m * n</code></td>
<td style="text-align:center">将 <code>m</code> 与 <code>n</code> 相乘</td>
</tr>
<tr>
<td style="text-align:center"><code>/</code></td>
<td style="text-align:center"><code>m / n</code></td>
<td style="text-align:center">将 <code>m</code> 除以 <code>n</code></td>
</tr>
<tr>
<td style="text-align:center"><code>%</code></td>
<td style="text-align:center"><code>m % n</code></td>
<td style="text-align:center">对 <code>m / n</code> 求模</td>
</tr>
</tbody>
</table>
</div>
<h3 id="10-1-2-按位操作符"><a href="#10-1-2-按位操作符" class="headerlink" title="10.1.2. 按位操作符"></a>10.1.2. 按位操作符</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">操作符</th>
<th style="text-align:center">表达式</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>~</code></td>
<td style="text-align:center"><code>~m</code></td>
<td style="text-align:center">将 <code>m</code> 的每个位取反</td>
</tr>
<tr>
<td style="text-align:center"><code>&amp;</code></td>
<td style="text-align:center"><code>m &amp; n</code></td>
<td style="text-align:center">将 <code>m</code> 的每个位与 <code>n</code> 的相应位相与</td>
</tr>
<tr>
<td style="text-align:center"><code>&#124;</code></td>
<td style="text-align:center"><code>m &#124; n</code></td>
<td style="text-align:center">将 <code>m</code> 的每个位与 <code>n</code> 的相应位相或</td>
</tr>
<tr>
<td style="text-align:center"><code>^</code></td>
<td style="text-align:center"><code>m ^ n</code></td>
<td style="text-align:center">将 <code>m</code> 的每个位与 <code>n</code> 的相应位相异或</td>
</tr>
<tr>
<td style="text-align:center"><code>~^</code><br><code>^~</code></td>
<td style="text-align:center"><code>m ~^ n</code><br><code>m ^~ n</code></td>
<td style="text-align:center">将 <code>m</code> 的每个位与 <code>n</code> 的相应位相异或非</td>
</tr>
</tbody>
</table>
</div>
<h3 id="10-1-3-归约操作符"><a href="#10-1-3-归约操作符" class="headerlink" title="10.1.3. 归约操作符"></a>10.1.3. 归约操作符</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">操作符</th>
<th style="text-align:center">表达式</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>&amp;</code></td>
<td style="text-align:center"><code>&amp;m</code></td>
<td style="text-align:center">将 <code>m</code> 中的所有位相与（1位结果）</td>
</tr>
<tr>
<td style="text-align:center"><code>~&amp;</code></td>
<td style="text-align:center"><code>~&amp;m</code></td>
<td style="text-align:center">将 <code>m</code> 中的所有位相与非（1位结果）</td>
</tr>
<tr>
<td style="text-align:center"><code>&#124;</code></td>
<td style="text-align:center"><code>&#124;m</code></td>
<td style="text-align:center">将 <code>m</code> 中的所有位相或（1位结果）</td>
</tr>
<tr>
<td style="text-align:center"><code>~&#124;</code></td>
<td style="text-align:center"><code>~&#124;m</code></td>
<td style="text-align:center">将 <code>m</code> 中的所有位或非（1位结果）</td>
</tr>
<tr>
<td style="text-align:center"><code>^</code></td>
<td style="text-align:center"><code>^m</code></td>
<td style="text-align:center">将 <code>m</code> 中的所有位异或（1位结果）</td>
</tr>
<tr>
<td style="text-align:center"><code>~^</code><br><code>^~</code></td>
<td style="text-align:center"><code>~^m</code><br><code>^~m</code></td>
<td style="text-align:center">将 <code>m</code> 中的所有位相异或非（1位结果）</td>
</tr>
</tbody>
</table>
</div>
<h3 id="10-1-4-逻辑操作符"><a href="#10-1-4-逻辑操作符" class="headerlink" title="10.1.4. 逻辑操作符"></a>10.1.4. 逻辑操作符</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">操作符</th>
<th style="text-align:center">表达式</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>!</code></td>
<td style="text-align:center"><code>!m</code></td>
<td style="text-align:center"><code>m</code> 是否不为真？（1 位 真/假结果）</td>
</tr>
<tr>
<td style="text-align:center"><code>&amp;&amp;</code></td>
<td style="text-align:center"><code>m &amp;&amp; n</code></td>
<td style="text-align:center"><code>m</code> 和 <code>n</code> 是否都为真？（1位 真/假结果）</td>
</tr>
<tr>
<td style="text-align:center"><code>&#124;&#124;</code></td>
<td style="text-align:center"><code>m &#124;&#124; n</code></td>
<td style="text-align:center"><code>m</code> 或 <code>n</code> 是否为真？（1位 真/假结果）</td>
</tr>
</tbody>
</table>
</div>
<h3 id="10-1-5-相等操作符"><a href="#10-1-5-相等操作符" class="headerlink" title="10.1.5. 相等操作符"></a>10.1.5. 相等操作符</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">操作符</th>
<th style="text-align:center">表达式</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>==</code></td>
<td style="text-align:center"><code>m == n</code></td>
<td style="text-align:center"><code>m</code> 和 <code>n</code> 相等吗？（1 位 正确/错误结果）</td>
</tr>
<tr>
<td style="text-align:center"><code>!=</code></td>
<td style="text-align:center"><code>m != n</code></td>
<td style="text-align:center"><code>m</code> 和 <code>n</code> 不等吗？（1 位 正确/错误结果）</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>相等操作符仅比较逻辑 1 和 0。</p>
</blockquote>
<h3 id="10-1-6-全等操作符"><a href="#10-1-6-全等操作符" class="headerlink" title="10.1.6. 全等操作符"></a>10.1.6. 全等操作符</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">操作符</th>
<th style="text-align:center">表达式</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>===</code></td>
<td style="text-align:center"><code>m === n</code></td>
<td style="text-align:center"><code>m</code> 和 <code>n</code> 全等吗？（1 位 正确/错误结果）</td>
</tr>
<tr>
<td style="text-align:center"><code>!==</code></td>
<td style="text-align:center"><code>m !== n</code></td>
<td style="text-align:center"><code>m</code> 和 <code>n</code> 不全等吗？（1 位 正确/错误结果）</td>
</tr>
</tbody>
</table>
</div>
<h3 id="10-1-7-关系操作符"><a href="#10-1-7-关系操作符" class="headerlink" title="10.1.7. 关系操作符"></a>10.1.7. 关系操作符</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">操作符</th>
<th style="text-align:center">表达式</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>&lt;</code></td>
<td style="text-align:center"><code>m &lt; n</code></td>
<td style="text-align:center"><code>m</code> 小于 <code>n</code> ？（1 位 正确/错误结果）</td>
</tr>
<tr>
<td style="text-align:center"><code>&gt;</code></td>
<td style="text-align:center"><code>m &gt; n</code></td>
<td style="text-align:center"><code>m</code> 大于 <code>n</code> ？（1 位 正确/错误结果）</td>
</tr>
<tr>
<td style="text-align:center"><code>&lt;=</code></td>
<td style="text-align:center"><code>m &lt;= n</code></td>
<td style="text-align:center"><code>m</code> 小于等于 <code>n</code> ？（1 位 正确/错误结果）</td>
</tr>
<tr>
<td style="text-align:center"><code>&gt;=</code></td>
<td style="text-align:center"><code>m &gt;= n</code></td>
<td style="text-align:center"><code>m</code> 大于等于 <code>n</code> ？（1 位 正确/错误结果）</td>
</tr>
</tbody>
</table>
</div>
<h3 id="10-1-8-逻辑移位操作符"><a href="#10-1-8-逻辑移位操作符" class="headerlink" title="10.1.8. 逻辑移位操作符"></a>10.1.8. 逻辑移位操作符</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">操作符</th>
<th style="text-align:center">表达式</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>&lt;&lt;</code></td>
<td style="text-align:center"><code>m &lt;&lt; n</code></td>
<td style="text-align:center">将 <code>m</code> 左移 <code>n</code> 位</td>
</tr>
<tr>
<td style="text-align:center"><code>&gt;&gt;</code></td>
<td style="text-align:center"><code>m &gt;&gt; n</code></td>
<td style="text-align:center">将 <code>m</code> 右移 <code>n</code> 位</td>
</tr>
</tbody>
</table>
</div>
<h3 id="10-1-9-条件操作符"><a href="#10-1-9-条件操作符" class="headerlink" title="10.1.9. 条件操作符"></a>10.1.9. 条件操作符</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">操作符</th>
<th style="text-align:center">表达式</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>? :</code></td>
<td style="text-align:center"><code>sel ? m : n</code></td>
<td style="text-align:center">如果 <code>sel</code> 为真，选择 <code>m</code>，否则选择 <code>n</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="10-1-10-连接复制操作符"><a href="#10-1-10-连接复制操作符" class="headerlink" title="10.1.10. 连接复制操作符"></a>10.1.10. 连接复制操作符</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">操作符</th>
<th style="text-align:center">表达式</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>&#123; &#125;</code></td>
<td style="text-align:center"><code>&#123;m,n&#125;</code></td>
<td style="text-align:center">将 <code>m</code> 和 <code>n</code> 连接起来，产生更大的向量</td>
</tr>
<tr>
<td style="text-align:center"><code>&#123;&#123; &#125;&#125;</code></td>
<td style="text-align:center"><code>&#123;n&#123;m&#125;&#125;</code></td>
<td style="text-align:center">将 <code>m</code> 重复 <code>n</code> 次</td>
</tr>
</tbody>
</table>
</div>
<p>在以上描述的操作符之间有优先级之分，下表体现了不同的操作数优先级由高到低排列。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">操作符</th>
<th style="text-align:center">优先级</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>!</code>、<code>~</code>、<code>+</code>、<code>-</code>（一元）</td>
<td style="text-align:center">最高优先级</td>
</tr>
<tr>
<td style="text-align:center"><code>*</code>、<code>/</code>、<code>%</code></td>
<td style="text-align:center">$\vdots$</td>
</tr>
<tr>
<td style="text-align:center"><code>+</code>、<code>-</code>（二元）</td>
<td style="text-align:center">$\vdots$</td>
</tr>
<tr>
<td style="text-align:center"><code>&lt;&lt;</code>、<code>&gt;&gt;</code></td>
<td style="text-align:center">$\vdots$</td>
</tr>
<tr>
<td style="text-align:center"><code>&lt;</code>、<code>&lt;=</code>、<code>&gt;</code>、<code>&gt;=</code></td>
<td style="text-align:center">$\vdots$</td>
</tr>
<tr>
<td style="text-align:center"><code>==</code>、<code>!=</code>、<code>===</code>、<code>!==</code></td>
<td style="text-align:center">$\vdots$</td>
</tr>
<tr>
<td style="text-align:center"><code>&amp;</code>、<code>~&amp;</code></td>
<td style="text-align:center">$\vdots$</td>
</tr>
<tr>
<td style="text-align:center"><code>^</code>、<code>~^</code></td>
<td style="text-align:center">$\vdots$</td>
</tr>
<tr>
<td style="text-align:center"><code>&#124;</code>、<code>~&#124;</code></td>
<td style="text-align:center">$\vdots$</td>
</tr>
<tr>
<td style="text-align:center"><code>&amp;&amp;</code></td>
<td style="text-align:center">$\vdots$</td>
</tr>
<tr>
<td style="text-align:center"><code>&#124;&#124;</code></td>
<td style="text-align:center">$\vdots$</td>
</tr>
<tr>
<td style="text-align:center"><code>? :</code></td>
<td style="text-align:center">最低优先级</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>例如：<code>A + B &amp; C + D</code> 就表示 <code>(A + B) &amp; (C + D)</code>，而不是 <code>A + (B &amp; C) + D</code>。</p>
</blockquote>
<h2 id="10-2-二进制数值"><a href="#10-2-二进制数值" class="headerlink" title="10.2. 二进制数值"></a>10.2. 二进制数值</h2><p>在讨论操作数之前，先来看看二进制数中如何表示有符号数和无符号数。</p>
<p>例如，在一个 6 位二进制整形变量中，</p>
<ul>
<li>无符号数能表示的范围是：<code>0~63</code>；</li>
<li>有符号数采用二进制补码（Two’s complement）方式，能表示的范围是：<code>-32～31</code>。其中二进制的最高位表示符号，最高位为 1 表示该数是负数，为 0 表示该数是正数。</li>
</ul>
<p>这里对具体的编码方式不过多介绍，但学过数字电路的同学必须掌握二进制中无符号数和有符号数的表示方法，以及计算的机制。</p>
<h2 id="10-3-操作数"><a href="#10-3-操作数" class="headerlink" title="10.3. 操作数"></a>10.3. 操作数</h2><p>在 Verilog 语言中，操作数可以是如下几种：</p>
<ul>
<li>常数；</li>
<li>参数；</li>
<li>线网；</li>
<li>寄存器；</li>
<li>向量的位选择;</li>
<li>向量的部分选择；</li>
<li>存储器单元；</li>
<li>系统函数或用户自定义函数调用的返回值。</li>
</ul>
<p>在选择操作数时，需要用户尤其注意的是操作数的极性。通常在 Verilog 中，无符号数用以下3种形式存在：</p>
<ul>
<li>线网变量；</li>
<li>一般寄存器变量；</li>
<li>基数格式表示形式的整数常数。</li>
</ul>
<p>而有符号数有：</p>
<ul>
<li>整型寄存器变量；</li>
<li>十进制形式的整型常量。</li>
</ul>
<p>首先讨论常量，如果采用基数格式表示一个数，例如：<code>-4&#39;d12</code>，其二进制表示方式是：<code>1111_1111_1111_1111_1111_1111_1111_0100</code>（<code>1100</code> 的补码），由于基数格式的整数为无符号数，因此<code>-4&#39;d12</code> 的值就是十进制的 <code>429496728</code>。</p>
<p>当采用普通十进制数来表示 <code>-12</code> 的时候，虽然它的二进制表示方式与上面的数相同，但 <code>-12</code> 是一个有符号数，它在运算时就表示十进制的 <code>-12</code>。</p>
<p>这里定义两个变量，一个是无符号的 <code>reg</code> 型，另一个是有符号的整型：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">reg</span> [<span class="number">4</span>:<span class="number">0</span>] Opreg;            <span class="comment">// 一个 5 位的 reg 型，存储无符号数</span></span><br><span class="line"><span class="keyword">integer</span> Opint;              <span class="comment">// 一个 32 位的 integer 型，存储有符号数</span></span><br></pre></td></tr></table></figure>
<p>做如下运算：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">Opreg = -<span class="number">4</span>d&#x27;<span class="number">12</span>/<span class="number">4</span>;           <span class="comment">// Opreg 被赋值 29，(-4d&#x27;12/4)的最低5位</span></span><br><span class="line">Opint = -<span class="number">4</span>d&#x27;<span class="number">12</span>/<span class="number">4</span>;           <span class="comment">// Opint 被赋值为 1073741821，共 32 位</span></span><br><span class="line">Opreg = -<span class="number">12</span>/<span class="number">4</span>;              <span class="comment">// Opreg 被赋值29，(-12/4)的最低5位</span></span><br><span class="line">Opint = -<span class="number">12</span>/<span class="number">4</span>;              <span class="comment">// Opint 被赋值为 -3，采用 32 位的二进制补码表示方式</span></span><br></pre></td></tr></table></figure>
<p>通过以上的计算结果可以看出，无符号数和有符号数的算术运算非常不同，用户在设计常量和变量并用它们计算的时候，一定要搞清楚它们中哪些表示有符号数，哪些表示无符号数，这很重要。</p>
<h1 id="11-系统任务和系统函数"><a href="#11-系统任务和系统函数" class="headerlink" title="11. 系统任务和系统函数"></a>11. 系统任务和系统函数</h1><p>在 Verilog 语中，预先定义了一些任务和函数，用于完成一些特殊的功能，它们被称为系统任务和系统函数。Verilog 能提供的系统任务和系统函数类型如下：</p>
<ul>
<li>显示任务（display task）；</li>
<li>文件输人/输出任务（file I/O task）；</li>
<li>时间标度任务（timescale task）；</li>
<li>拟控制任务（simulation control task）；</li>
<li>时序验证任务（timing check task）；</li>
<li>PLA建模任务（PLA modeling task）；</li>
<li>机建模任务（stochastic modeling task）；</li>
<li>实数变换函数（conversion functions for real）；</li>
<li>概率分布数（probabilistic distribution function)。</li>
</ul>
<p>由于 Verilog 的系统任务和函数种类很多，在这里，只重点介绍一些常用的内容，希望通过介绍可以能让大家迅速掌握，灵活使用。相信通过以下的介绍，大家可以举一反三，通过参考 Verilog 的语法文献，迅速查找到需要的系统任务和函数，完成需要的功能。</p>
<h2 id="11-1-显示任务"><a href="#11-1-显示任务" class="headerlink" title="11.1. 显示任务"></a>11.1. 显示任务</h2><p><code>$display</code> 是显示任务，通常用来显示变量值、字符串，以及仿真时间等信息。</p>
<p>在 <a href="#JoshVerilog代码">JoshVerilog 模块</a>中使用了这样的系统任务。</p>
<figure class="highlight verilog"><figcaption><span>Josh.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="built_in">$display</span> (<span class="string">&quot;At time %t-&quot;</span>, <span class="built_in">$time</span>, <span class="string">&quot;eq0 = 1&quot;</span>);     <span class="comment">// 显示时间</span></span><br></pre></td></tr></table></figure>
<p>其中，双引号中的是字符串，<code>％t</code> 是时间格式。<code>$time</code> 是产生模拟时间的系统函数，它的返回值显示在字符串中的 <code>％t</code> 位置。</p>
<p>再如：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$display</span>(<span class="string">&quot;The value of ABC is %d&quot;</span>, ABC);        <span class="comment">// 显示当前 ABC 变量的值</span></span><br></pre></td></tr></table></figure>
<p>其中，<code>%d</code> 表示十进制数。<code>ABC</code> 的值显示在字符串中的 <code>%d</code> 位置。</p>
<h2 id="11-2-文件输入出任务"><a href="#11-2-文件输入出任务" class="headerlink" title="11.2. 文件输入出任务"></a>11.2. 文件输入出任务</h2><p>系统函数 <code>$fopen</code> 用于打开一个文件，并返回一个整数的文件指针。然后，<code>$fdisplay</code> 就可以使用这个文件指针向文件中写人信息。写完后，则可以使用 <code>$fclose</code> 这个系统关闭这个文件。例如：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span> Write_Out_File;                     <span class="comment">// 定义一个文件指针</span></span><br><span class="line">Write_Out_File = <span class="built_in">$fopen</span>(<span class="string">&quot;Write_Out_File.txt&quot;</span>);</span><br><span class="line"><span class="built_in">$fdisplay</span>(Write_Out_File, <span class="string">&quot;@ %h\n%h&quot;</span>, Mpi_addr, Data_in);</span><br><span class="line"><span class="built_in">$fclose</span>(Write_Out_File);</span><br></pre></td></tr></table></figure>
<p>以上的语法，将 <code>Mpi_addr</code> 和 <code>Data_in</code> 分别显示在 <code>@ %h\n%h</code> 中两个 <code>%h</code> 的位置，写入 <code>Write_Out_File</code> 指针所指的文件 <code>Write_Out_File.txt</code> 中。</p>
<p>用户可以通过 <code>$readmemb</code> 或者 <code>$readmemh</code> 来从文件中读人数据，但是这个文件中的数据格式是一定的。例如：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] DataSource [<span class="number">0</span>:<span class="number">47</span>];</span><br><span class="line"><span class="built_in">$readmemh</span> (<span class="string">&quot;Read_In_File.txt, DataSource);</span></span><br></pre></td></tr></table></figure>
<p>就是将 <code>Read_In_FiIe</code> 文件中数据读人到 <code>DataSource</code> 数组中，然后就可以直接使用。</p>
<p><code>Read_In_File</code> 数据文件的格式，可以参考如下写法：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">@<span class="number">2</span>f</span><br><span class="line"><span class="number">24</span></span><br><span class="line">@<span class="number">2</span>e</span><br><span class="line"><span class="number">81</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>其中，<code>@2f</code> 表示地址，是十六进制；<code>24</code> 表示该地址的数据，以此类推。</p>
<h2 id="11-3-其他系统任务和数"><a href="#11-3-其他系统任务和数" class="headerlink" title="11.3. 其他系统任务和数"></a>11.3. 其他系统任务和数</h2><ol>
<li><p>仿真控制任务</p>
<p> Verilog 中有一些仿真控制任务，例如：<br> <code>$finish</code> 表示使仿真器退出。<br> <code>$stop</code> 使仿真挂起。</p>
</li>
<li><p>时序验证任务和仿真时间函数</p>
<p> Verilog 仿真器也可以检查设计时序，以及返回当前仿真时间，例如：<br> <code>$setup</code> 系统任务用来检查建立时间。<br> <code>$hold</code> 系统任务用来检查保持时间。<br> <code>$time</code> 系统函数用来返回一个64位的模拟时间。</p>
</li>
<li><p>概率分布函数</p>
<p> <code>$random</code> 系统函数可以用来返回一个32位的有符号整型随机数。</p>
</li>
</ol>
<p>需要注意的是，<strong>系统任务/函数只可以在 Verilog 仿真器中运行，仅仅对代码仿真有意义</strong>，综合和布线工具将忽略所有的系统任务和函数。</p>
<p>除了系统任务和系统函数之外，VeriIog还允许用户自己定义任务和函数。关于自定义的任务和函数的特点及使用方法，请参考后续的相关内容。</p>
<hr>
<p>在本篇笔记中，以一个实例为出发点，系统介绍了 Verilog 的基本语法，相信能为大家深入学习 Verilog 语言打下坚实的基础。</p>
]]></content>
      <categories>
        <category>Verilog</category>
        <category>Josh 的学习笔记</category>
        <category>Verilog</category>
        <category>Verilog 语法</category>
      </categories>
      <tags>
        <tag>Verilog</tag>
        <tag>HDL</tag>
        <tag>自顶向下</tag>
        <tag>自底向上</tag>
        <tag>Verilog 语法</tag>
      </tags>
  </entry>
  <entry>
    <title>Josh 的学习笔记之 Verilog（Part 3 —— 描述方式和设计层次）</title>
    <url>/posts/fd117896.html</url>
    <content><![CDATA[<p>Verilog 语言可以用多种方式来描述硬件，同时，使用这些描述方式又可以在多个抽象层次上设计硬件。这是 Verilog 语言的重要特征。本文主要侧重于阐述 Verilog 语言的描述方法和设计层次。</p>
<h1 id="1-描述方式"><a href="#1-描述方式" class="headerlink" title="1. 描述方式"></a>1. 描述方式</h1><p>在<a href="https://josh-gao.top/posts/fd2ca242.html#3-%E7%A7%8D%E6%8F%8F%E8%BF%B0%E6%96%B9%E6%B3%95">《Part 2——Verilog 语言基础》</a>中己经介绍过，Verilog 语言有 3 种最基本的描述方式．</p>
<ul>
<li>数据流描述，采用 <code>assign</code> 连续赋值语句；</li>
<li>行为描述，使用 <code>always</code> 语句或 <code>initial</code> 语句块中的过程赋值语句；</li>
<li>结构化描述，实例化已有的功能模块或原语。</li>
</ul>
<p>下面分别说明这几种描述方式。</p>
<a id="more"></a>
<h1 id="2-数据流描述"><a href="#2-数据流描述" class="headerlink" title="2. 数据流描述"></a>2. 数据流描述</h1><h2 id="2-1-数据流"><a href="#2-1-数据流" class="headerlink" title="2.1. 数据流"></a>2.1. 数据流</h2><p>在数字电路中，信号经过组合逻辑时有点类似于数据的流动：信号从输入流向输出，而信号不会在其中存储。当输入发生变化时，总会在一定时间以后体现在输出端。</p>
<p>同样，可以模拟数字电路的这一特性，对其进行建模。通常将这种建模方式称为数据流建模。</p>
<p>数据流描述最基本的语句是 <code>assign</code> 连续赋值语句。</p>
<h2 id="2-2-连续赋值语句"><a href="#2-2-连续赋值语句" class="headerlink" title="2.2. 连续赋值语句"></a>2.2. 连续赋值语句</h2><div align="center">
  <img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-30-josh-verilog-part-3/2020-11-30-josh-verilog-part-3-010-XORGate.png!sign"/>
</div>

<p>上图中的电路模型可以用如下的语句来描述：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> #<span class="number">1</span> A_xor_wire = eq0 ^ eq1;</span><br></pre></td></tr></table></figure>
<p>在任意一个时刻，<code>A_xor_wire</code> 线网的值是由 <code>eq0</code> 和 <code>eq1</code> 决定的，也可以说是由它们驱动的。</p>
<h3 id="2-2-1-连续赋值语句的特点"><a href="#2-2-1-连续赋值语句的特点" class="headerlink" title="2.2.1. 连续赋值语句的特点"></a>2.2.1. 连续赋值语句的特点</h3><ol>
<li><p><strong>连续驱动</strong></p>
<p> 在 <a href="https://josh-gao.top/posts/fd2ca242.html#%E5%AF%84%E5%AD%98%E5%99%A8%E7%B1%BB%E5%9E%8B">Part 2 的 7.2 驱动和赋值</a>部分，已经解释了驱动和赋值之间的微妙区别。</p>
<p> 连续赋值语句是连续驱动的。也就是说，任何时刻输人的任何变化都将导致该语句的重新计算。</p>
</li>
<li><p><strong>只有线网类型能在 <code>assign</code> 中赋值</strong></p>
<p> 由于仿真器中不会存储连续赋值语句中被赋值的变量值，因此该变量是线网类型（Net），不能是寄存器类型。需要记住，只有线网类型的变量才可以在 <code>assign</code> 语句中被赋值。</p>
<p> 另外，线网类型的变量可以被多重驱动，也就是说，可以在多个连续赋值语句中驱动同一个线网。在<a href="#drive">2.4 驱动源线网</a>中将进一步介绍。但是，寄存器变量就不同了，它不能被不同的行为进程（例如 <code>always</code> 语句块）驱动。</p>
</li>
<li><p><strong>使用 <code>assign</code> 对组合逻辑建模</strong></p>
<p> 通常建议使用 <code>assign</code> 对组合逻辑建模。因为 <code>assign</code> 语句的连续驱动特点与组合逻辑的行为非常相似。而且，在 <code>assign</code> 语句中加延时可以非常精确的模拟组合逻辑的惯性延时。</p>
</li>
<li><p><strong>并行性</strong></p>
<p> <code>assign</code> 语句和行为语句块（<code>always</code> 和 <code>initial</code>)、其他连续赋值语句、门级模型之间是并行的。一个连续赋值语句是一个独立的进程，进程之间是并发，同时也是交织的。</p>
</li>
</ol>
<h3 id="2-2-2-实例"><a href="#2-2-2-实例" class="headerlink" title="2.2.2. 实例"></a>2.2.2. 实例</h3><div align="center">
  <img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-30-josh-verilog-part-3/2020-11-30-josh-verilog-part-3-020-FullAdder.png!sign"/>
</div>

<p>在上中，用两个半加器和一个或门组成一个全加器，这里将使用连续赋值语句描述这个电路。代码如下。</p>
<p><a name="半加器代码"></a></p>
<figure class="highlight verilog"><figcaption><span>HalfAdd.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> HalfAdd(X, Y, sum, C_out);</span><br><span class="line"></span><br><span class="line"><span class="comment">// IO端口声明</span></span><br><span class="line"><span class="keyword">input</span> X;</span><br><span class="line"><span class="keyword">input</span> Y;</span><br><span class="line"><span class="keyword">output</span> sum;</span><br><span class="line"><span class="keyword">output</span> C_out;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> sum = X ^ Y;</span><br><span class="line"><span class="keyword">assign</span> C_out = X &amp; Y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span> </span><br></pre></td></tr></table></figure>
<figure class="highlight verilog"><figcaption><span>FullAdd.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> FullAdd(X, Y, C_in, sum, C_out);</span><br><span class="line"></span><br><span class="line"><span class="comment">// IO端口声明</span></span><br><span class="line"><span class="keyword">input</span> X;</span><br><span class="line"><span class="keyword">input</span> Y;</span><br><span class="line"><span class="keyword">input</span> C_in;</span><br><span class="line"><span class="keyword">output</span> sum;</span><br><span class="line"><span class="keyword">output</span> C_out;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线网类型用于连接</span></span><br><span class="line"><span class="keyword">wire</span> HalfAdd_A_sum;</span><br><span class="line"><span class="keyword">wire</span> HalfAdd_A_Cout;</span><br><span class="line"><span class="keyword">wire</span> HalfAdd_B_Cout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> C_out = HalfAdd_A_Cout | HalfAdd_B_Cout;</span><br><span class="line"></span><br><span class="line">HalfAdd u_HalfAdd_A(</span><br><span class="line">    <span class="variable">.X</span>      (C_in),</span><br><span class="line">    <span class="variable">.Y</span>      (Y),</span><br><span class="line">    <span class="variable">.s</span>      (HalfAdd_A_sum),</span><br><span class="line">    <span class="variable">.C_out</span>  (HalfAdd_A_Cout)</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">HalfAdd u_HalfAdd_B(</span><br><span class="line">    <span class="variable">.X</span>      (C_in),</span><br><span class="line">    <span class="variable">.Y</span>      (HalfAdd_A_sum),</span><br><span class="line">    <span class="variable">.s</span>      (sum),</span><br><span class="line">    <span class="variable">.C_out</span>  (HalfAdd_B_Cout)</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line"><span class="keyword">endmodule</span> </span><br></pre></td></tr></table></figure>
<p>在 <code>HalfAdd</code> 模块中，两个 <code>assign</code> 语句之间是<strong>完全并行独立执行</strong>的，它们的顺序与逻辑功能无关。同样，<code>FullAdd</code> 模块中，两个 <code>HalfAdd</code> 的实例和或门的 <code>assign</code> 语句之间的关系也是独立的。</p>
<h2 id="2-3-延时"><a href="#2-3-延时" class="headerlink" title="2.3. 延时"></a>2.3. 延时</h2><p>在连续赋值语句中，可以对电路的延时进行建模。当然，也可以没有延时。比如：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> #<span class="number">1</span> A_xor_wire = eq0 ^ eq1;           <span class="comment">// `timescale 1ns/1ns</span></span><br></pre></td></tr></table></figure>
<p>这个语句就表示该异或门的延时为 <code>1ns</code>，也就是说，输人端信号变化到输出端体现出来需要 <code>1ns</code> 的时间。</p>
<p>这里是比较笼统的延时模型。实际上，电路对不同的信号跳变表现出的延时往往并不一致。这些延时模型包括：</p>
<ul>
<li>上升沿延时（输出变为 1）；</li>
<li>下降沿延时（输出变为 0）；</li>
<li>关闭延时（输出变成 <code>Z</code>，高阻态）；</li>
<li>输出变成 <code>X</code> 的延时。</li>
</ul>
<p>用户可以分别描述这几种延时，比如：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> <span class="variable">#(1,2)</span> A_xor_wire = eq0 ^ eq1;</span><br><span class="line"><span class="keyword">assign</span> <span class="variable">#(1,2,3)</span> A_xor <span class="keyword">wire</span> = eq0 ^ eq1;</span><br></pre></td></tr></table></figure>
<p>第一句表示，上升延时 <code>1ns</code>，下降延时 <code>2ns</code>，关闭延时和传递到 <code>X</code> 的延时为两者中最小的，即 <code>1ns</code>。</p>
<p>第二句表示，上升延时 <code>1ns</code>，下降延时 <code>2ns</code>，关闭延时为 <code>3ns</code>，传递到 <code>X</code> 的延时取1、2、3中最小的 <code>1ns</code>。</p>
<p>在一些电路模型中，延时分为最大、典型和最小3种情况。连续赋值语句中的延时也可以采用 <code>min:typ:max</code> 的格式来表示。例如：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> <span class="variable">#(4:5:6, 3:4:5)</span> A_xor_wire = eq0 ^ eq1;</span><br></pre></td></tr></table></figure>
<p>表示上升延时的 <code>min:typ:max</code> 为 <code>4:5:6</code>，下降延时的 <code>min:typ:max</code> 为 <code>3:4:5</code>。</p>
<p>需要注意的是，在连续赋值语句中的延时具有硬件电路中惯性延时的特性。也就是说，<strong>任何小于其延时的信号变化脉冲将被滤除掉，不会体现在输出端口上</strong>。关于这部分内容会在后续详细描述。</p>
<p>另外，<code>assign</code> 语句中的延时特性通常是被逻辑综合工具忽略的。因为综合工具要将 Verilog 语言模型综合成逻辑电路，而逻辑电路的延时是由基本的单元库和走线延时决定的。用户无法对逻辑单元指定延时，但是，用户可以在综合和实现工具中加时序约束，让工具尽量满足设计的时序要求。</p>
<h2 id="2-4-驱动源线网"><a href="#2-4-驱动源线网" class="headerlink" title="2.4. 驱动源线网"></a>2.4. 驱动源线网<a name="drive"></a></h2><p>下面分为几种线网类型来描述当线网具有多重驱动源时的情况。</p>
<h3 id="2-4-1-多重驱动-wire（错误）"><a href="#2-4-1-多重驱动-wire（错误）" class="headerlink" title="2.4.1. 多重驱动 wire（错误）"></a>2.4.1. 多重驱动 <code>wire</code>（错误）</h3><figure class="highlight verilog"><figcaption><span>WS.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> WS (A, B, C, D, WireShort)；</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span> A, B, C, D;</span><br><span class="line"><span class="keyword">output</span> WireShort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">wire</span> WireShort;         <span class="comment">//显式定义为wire类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> WireShort = A ^ B；</span><br><span class="line"><span class="keyword">assign</span> WireShort = C &amp; D；</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>在以上代码中，由于 <code>WireShort</code> 为 <code>wire</code> 类型，同时它有多重驱动源，因此仿真时 <code>WireShort</code> 的值将是 <code>X</code>，也就是不定态。</p>
<h3 id="2-4-2-线或、线与功能"><a href="#2-4-2-线或、线与功能" class="headerlink" title="2.4.2. 线或、线与功能"></a>2.4.2. 线或、线与功能</h3><p>可以使用 <code>wor</code> 线网类型来将不同的输出“线或”在一起，如下：</p>
<figure class="highlight verilog"><figcaption><span>// WO.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> WO (A, B, C, D, WireOr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span> A, B, C, D;</span><br><span class="line"><span class="keyword">output</span> WireOr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">wor</span> WireOr;             <span class="comment">// 显式定义为 wor 类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> WireOr = A ^ B;</span><br><span class="line"><span class="keyword">assign</span> WireOr = C &amp; D;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>逻辑综合以后，它具体对应的逻辑电路如下图所示。</p>
<div align="center">
  <img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-30-josh-verilog-part-3/2020-11-30-josh-verilog-part-3-030-WireOr.png!700px"/>
</div>

<p>同样，可以使用 <code>wand</code> 线网类型来将不同的输出“线与”在一起，如下：</p>
<figure class="highlight verilog"><figcaption><span>WA.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> WA (A, B, C, D, WireAnd);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span> A, B, C, D;</span><br><span class="line"><span class="keyword">output</span> WireAnd;</span><br><span class="line"></span><br><span class="line"><span class="keyword">wand</span> WireAnd;           <span class="comment">// 显式定义为 wand 类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> WireAnd = A ^ B;</span><br><span class="line"><span class="keyword">assign</span> WireAnd = C &amp; D;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>它对应的逻辑电路如下图所示。</p>
<div align="center">
  <img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-30-josh-verilog-part-3/2020-11-30-josh-verilog-part-3-040-WireAnd.png!700px"/>
</div>

<h3 id="2-4-3-三态总线功能"><a href="#2-4-3-三态总线功能" class="headerlink" title="2.4.3. 三态总线功能"></a>2.4.3. 三态总线功能</h3><p>如果要实现多个三态总线相连，可以采用 <code>tri</code> 型线网：</p>
<figure class="highlight verilog"><figcaption><span>WT.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> WT (A, B, C, D, WireTri, en1_n, en2_n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span> A, B, C, D, en1_n, en2_n;</span><br><span class="line"><span class="keyword">output</span> WireTri;</span><br><span class="line"></span><br><span class="line"><span class="keyword">tri</span> WireTri;            <span class="comment">// 显式定义为 tri 类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> WireTri = (en1_n) ? <span class="number">1&#x27;bz</span> : (A ^ B);</span><br><span class="line"><span class="keyword">assign</span> WireTri = (en2_n) ? <span class="number">1&#x27;bz</span> : (C &amp; D);</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>其实现的电路如下图所示。</p>
<div align="center">
  <img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-30-josh-verilog-part-3/2020-11-30-josh-verilog-part-3-050-WireTri.png!700px"/>
</div>

<h1 id="3-行为描述"><a href="#3-行为描述" class="headerlink" title="3. 行为描述"></a>3. 行为描述<a name="03"><a></h1><p>在 <a href="https://josh-gao.top/posts/fd2ca242.html#3-%E7%A7%8D%E6%8F%8F%E8%BF%B0%E6%96%B9%E6%B3%95">Part 2</a> 中介绍过行为描述的概念。所谓行为描述，是指用语言描述电路的行为。行为描述的语句有两种：<code>initial</code> 和 <code>always</code> 语句。</p>
<h2 id="3-1-行为描述的语句格式"><a href="#3-1-行为描述的语句格式" class="headerlink" title="3.1. 行为描述的语句格式"></a>3.1. 行为描述的语句格式</h2><p><code>initial</code> 和 <code>always</code> 的后面一般跟语句或语句组（statement group)。语句可以是：非阻塞过程赋值、阻塞过程赋值、连续过程赋值或高级编程语句。在以后会一一介绍。</p>
<h3 id="3-1-1-initial-或-always-过程块（procedual-block）"><a href="#3-1-1-initial-或-always-过程块（procedual-block）" class="headerlink" title="3.1.1. initial 或 always 过程块（procedual block）"></a>3.1.1. <code>initial</code> 或 <code>always</code> 过程块（procedual block）</h3><p><code>initial</code> 语句在 0 仿真时间执行，而且只执行一次；<code>always</code> 语句同样在 0 仿真时间开始执行，但是它将一直循环执行。这样的特点单单从它们的命名上就能看得出来：一个是 <code>initial</code>，就是初始化一次的意思；另一个是 <code>always</code>，就是总在运行的意思。</p>
<p>下面利用 <code>initial</code> 和 <code>always</code> 语句各自的特点，产生一个时钟发生器的模型。</p>
<figure class="highlight verilog"><figcaption><span>ClkGen.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="meta-keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"><span class="keyword">module</span> ClkGen (clk);</span><br><span class="line"></span><br><span class="line"><span class="keyword">output</span> clk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span> clk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span>             <span class="comment">// 将 clk 初始化为 0</span></span><br><span class="line">    clk = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span>              <span class="comment">// 每 5ns 将 clk 翻转一次</span></span><br><span class="line">    #<span class="number">5</span> clk = ~clk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>在 0 时刻，<code>initial</code> 和 <code>always</code> 语句同时执行，顺序随机。假设先运行 <code>initial</code> 语句，那么 <code>clk</code> 变量被赋值为 0，这时 <code>initial</code> 语句进程将永远被挂起，再也不会执行。</p>
<p>然后，开始运行 <code>always</code> 语句。该 <code>always</code> 语句每隔 <code>5ns</code> 将 <code>clk</code> 信号翻转一次，一直不停地运行，这样就产生了一个周期是 <code>10ns</code> 的时钟信号。</p>
<blockquote>
<p>在以上代码中，0 时刻，<code>initial</code> 和 <code>always</code> 语句同时执行，顺序随机，这样就存在一个冲突的问题。假设先执行的是 <code>always</code> 语句， <code>clk</code> 就不会被初始化为 0。</p>
</blockquote>
<h3 id="3-1-2-过程块中的语句种类"><a href="#3-1-2-过程块中的语句种类" class="headerlink" title="3.1.2. 过程块中的语句种类"></a>3.1.2. 过程块中的语句种类</h3><p>在 <code>initial</code> 和 <code>always</code> 过程块中可以直接跟语句或者语句组。直接跟的语句可以是非阻塞过程赋值、阻塞过程赋值、连续过程赋值或高级编程语句。语句组可以是：<code>begin ... end</code> 和 <code>fork ... join</code> 两种。</p>
<p>语句组中可以有其他几种语句类型，而高级编程语句中也可以有语句组，它们可以互相嵌套，完成非常复杂的逻辑功能描述。</p>
<p>下面是 <code>always</code> 过程块中直接跟阻塞赋值语句：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span>              <span class="comment">// 每 5ns 将 clk 翻转一次</span></span><br><span class="line">    #<span class="number">5</span> clk = ~clk;</span><br></pre></td></tr></table></figure>
<p>下面的代码描述了语句组和高级编程语句的互相嵌套：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) </span><br><span class="line"><span class="keyword">begin</span>                               <span class="comment">// 语句组</span></span><br><span class="line">    <span class="keyword">if</span> (~rst_n)                     <span class="comment">// 高级编程语句</span></span><br><span class="line">    <span class="keyword">begin</span>                           <span class="comment">// 语句组</span></span><br><span class="line">        reg_A &lt;= <span class="number">0</span>;                 <span class="comment">// 非阻塞赋值语句</span></span><br><span class="line">        reg_B &lt;= <span class="number">0</span>;                 <span class="comment">// 非阻塞赋值语句</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span>                            <span class="comment">// 高级编程语句</span></span><br><span class="line">    <span class="keyword">begin</span>                           <span class="comment">// 语句组</span></span><br><span class="line">        reg_A &lt;= input_A;           <span class="comment">// 非阻塞赋值语句</span></span><br><span class="line">        reg_B &lt;= input_B;           <span class="comment">// 非阻塞赋值语句</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>从上例中可以看出，高级编程语句里面可以嵌套过程赋值语句，或者其他高级编程语句。</p>
<h3 id="3-1-3-时序控制（Timing-Control）"><a href="#3-1-3-时序控制（Timing-Control）" class="headerlink" title="3.1.3. 时序控制（Timing Control）"></a>3.1.3. 时序控制（Timing Control）</h3><p>在行为描述中，有几种方式对设计模型进行时序控制，它们是：</p>
<ul>
<li>事件语句（<code>@</code>）；</li>
<li>延时语句（<code>#</code>）；</li>
<li>等待语句。</li>
</ul>
<p>当执行 <code>initial</code> 或 <code>always</code> 语句块时遇到一个事件语句（<code>@</code>）、延时语句（<code>#</code>），或其表达式值为假（false）的等待语句时，语句块（或称为进程）的执行将被挂起（suspended)。直到发生该事件，或者已经过了指定延迟的时间单位数，或者等待语句表达式变为真（ture）时，才重新执行 <code>initial</code> 或 <code>always</code> 语句块。这个过程就是时序控制。Verilog 的行为描述中，正是利用这几种时序控制语句来实现各种各样的逻辑功能。</p>
<h4 id="3-1-3-1-事件语句（-）的用法"><a href="#3-1-3-1-事件语句（-）的用法" class="headerlink" title="3.1.3.1. 事件语句（@）的用法"></a>3.1.3.1. 事件语句（<code>@</code>）的用法</h4><div align="center">
  <img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-30-josh-verilog-part-3/2020-11-30-josh-verilog-part-3-060-DFlipFlop.png!600px"/>
</div>

<p>要实现上图中这样一个 D 触发器，通常用以下代码：</p>
<figure class="highlight verilog"><figcaption><span>TYP_DFF.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> TYP_DFF (clk, D, Q);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span> clk, D;</span><br><span class="line"><span class="keyword">output</span> Q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span> Q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">    Q &lt;= D;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>在 0 仿真时刻，<code>always</code> 语句块开始执行。当遇到 <code>@ (posedge clk)</code> 语句时，该进程被挂起。等待 <code>clk</code> 的上升沿到来，才重新激活该进程。当 <code>clk</code> 的上升沿出现后，将 <code>D</code> 的值赋给 <code>Q</code>，<code>always</code> 语句块执行完成。</p>
<p>由于 <code>always</code> 语句的特点，<code>always</code> 语句马上开始重新执行，当遇到 <code>@ (posedge clk)</code> 语句时，进程再一次挂起，等待 <code>clk</code> 的上升沿到来，才继续往下执行。</p>
<p>这样，在 <code>always</code> 语句中使用 <code>@</code> 事件语句很好地模拟了触发器的行为。综合工具会马上将上述代码映射成上图中的 D 触发器。</p>
<p>同样的道理，采用如下的代码也可以得到一样的 D 触发器功能：</p>
<figure class="highlight verilog"><figcaption><span>TYP_DFF.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> TYP_DFF (clk, D, Q);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span> clk, D;</span><br><span class="line"><span class="keyword">output</span> Q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span> Q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> <span class="keyword">begin</span></span><br><span class="line">    @(<span class="keyword">posedge</span> clk)</span><br><span class="line">    Q &lt;= D;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>当有多个条件语句时，一般将它们用 <code>or</code> 分隔开。例如，要实现一个带异步复位端的 D 触发器可以采用如下代码：</p>
<figure class="highlight verilog"><figcaption><span>TYP_DFF.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> TYP_DFF (clk, D, Q, rst);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span> clk, D, rst;</span><br><span class="line"><span class="keyword">output</span> Q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span> Q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">posedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (rst)</span><br><span class="line">        Q &lt;= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        Q &lt;= D;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>当出现 <code>clk</code> 或 <code>rst</code> 的下降沿时，才会触发 <code>always</code> 语句。</p>
<h4 id="3-1-3-2-延时语句（-）的用法"><a href="#3-1-3-2-延时语句（-）的用法" class="headerlink" title="3.1.3.2. 延时语句（#）的用法"></a>3.1.3.2. 延时语句（<code>#</code>）的用法</h4><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span>              <span class="comment">// 每 5ns 将 clk 翻转一次</span></span><br><span class="line">    #<span class="number">5</span> clk = ~clk;</span><br></pre></td></tr></table></figure>
<p>这里 <code>always</code> 的语句开始执行时，马上遇到 <code>#5</code>，<code>always</code> 语句块挂起。直到 <code>5ns</code> 以后才恢复执行，这时将 <code>clk</code> 取反。当再次执行 <code>always</code> 时，动作与上一次完全一致。这里，模拟了一个周期为 <code>10ns</code> 的时钟。</p>
<p>当然，这种写法一般用于仿真激励的产生，仅仅用于仿真。由于综合工具会将延时语句 <code>#5</code> 忽略，所以如上的代码无法综合成一个 <code>10ns</code> 周期的时钟发生器电路。</p>
<p>以下代码利用延时语句产生一个复位信号：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    rst_n =<span class="number">1</span>;</span><br><span class="line">    #<span class="number">5</span> rst_n = <span class="number">0</span>;</span><br><span class="line">    #<span class="number">100</span> rst_n=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>当以上 <code>initial</code> 语句开始运行时，首先将 <code>rst_n</code> 赋值为 <code>1</code>。当遇到 <code>#5</code> 时，该 <code>initial</code> 的执行过程被暂时挂起，等待 <code>5ns</code> 后恢复执行，<code>rst_n</code> 被置 <code>0</code>，处于复位状态。然后，遇到 <code>#100</code>，等待 <code>100ns</code> 以后再恢复执行，<code>rst_n</code> 被置为 <code>1</code>。这时，<code>initial</code> 语句块被永远挂起，再也不会执行。于是，就产生了一个 <code>100ns</code> 的复位信号。</p>
<h4 id="3-1-3-3-等待语句的用法"><a href="#3-1-3-3-等待语句的用法" class="headerlink" title="3.1.3.3. 等待语句的用法"></a>3.1.3.3. 等待语句的用法</h4><p>下面分析一下等待语句如何做时序控制：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> MY_LATCH (Strobe, D, Q);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span> Strobe, D;</span><br><span class="line"><span class="keyword">output</span> Q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span> Q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">wait</span> (Strobe == <span class="number">1</span>);</span><br><span class="line">    Q = D;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>该语句表示，当 <code>always</code> 语句开始执行后，遇到 <code>wait()</code> 语句，如果括号内的变量不为真，则该进程被挂起，直到 <code>(Strobe == 1)</code> 为真，<code>always</code> 才继续往下执行，将 <code>D</code> 的值赋值给 <code>Q</code>，这样就模拟了一个电平敏感的锁存器。</p>
<p>要注意的是，目前多数综合工具还不支持 <code>wait</code> 语句，因此这个锁存器的功能只能在仿真时用，不能实现为具体的电路。</p>
<h2 id="3-2-过程赋值语句"><a href="#3-2-过程赋值语句" class="headerlink" title="3.2. 过程赋值语句"></a>3.2. 过程赋值语句</h2><p>所谓过程赋值语句就是在 <code>initial</code> 和 <code>always</code> 语句块中的赋值语句。赋值对象只能是寄存器变量类型。右边的表达式可以是任意操作符的表达式。</p>
<h3 id="3-2-1-阻塞赋值"><a href="#3-2-1-阻塞赋值" class="headerlink" title="3.2.1. 阻塞赋值"></a>3.2.1. 阻塞赋值</h3><p>阻塞赋值的语法如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">寄存器变量 = 表达式;</span><br></pre></td></tr></table></figure>
<p>所谓“阻塞赋值”，实际上有两层含义：</p>
<ol>
<li><p>右边表达式的计算和对左边寄存器变量的赋值是一个统一的原子操作中的两个动作。<strong>这两个动作之间不能插人任何其他的动作</strong>。</p>
</li>
<li><p>如果多个阻塞赋值语句顺序出现在 <code>begin. .. end</code> 语句中，<strong>前面的语句在执行时，将完全阻塞后面的语句，直到前面语句的赋值完成以后，才会执行下一句的右边表达式计算</strong>。例如 <code>begin m = n; n = m; end</code> 语句中，当 <code>m</code> 被完全赋值以后，再开始执行 <code>n=m</code>，将 <code>m</code> 的新值赋给 <code>n</code>。这样执行的结果就是的初始值不变，而且与 <code>n</code> 相等。</p>
</li>
</ol>
<p>由于阻塞賦值的这一特点，通常会建议在对组合逻辑建模的时候，采用阻塞賦值，先看一段代码：</p>
<p><a name="一个组合逻辑"></a></p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">wire</span> A_in, B_in, C_in;</span><br><span class="line"><span class="keyword">reg</span> Temp, D_out;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">always</span> @(A_in <span class="keyword">or</span> B_in <span class="keyword">or</span> C_in) <span class="keyword">begin</span></span><br><span class="line">    Temp = A_in &amp; B_in;             <span class="comment">// 阻塞赋值</span></span><br><span class="line">    D_out = Temp | C_in;            <span class="comment">// 阻塞赋值</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>设计者的根本目的是得到如下图所示的电路。</p>
<div align="center">
  <img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-30-josh-verilog-part-3/2020-11-30-josh-verilog-part-3-070-ACombinationalLogic.png!700px"/>
</div>

<p>在以上代码仿真时，正是利用了阻塞赋值的这一特点才模拟了该组合逻辑的行为。</p>
<p>首先，任何一个输人发生变化，<code>D_out</code> 必然发生变化。因此，在 <code>always</code> 的敏感列表中，包括 <code>A_in</code>，<code>B_in</code> 和 <code>C_in</code>。在内部计算时，首先将 <code>A_in</code> 和 <code>B_in</code> 相与，得到一个中间结果 <code>Temp</code>。等 <code>Temp</code> 被完全赋值后，才开始执行下一个语句：将 <code>Temp</code> 的新值与 <code>C_in</code> 相或，得到 <code>D_out</code> 的值。我们也许可以感受到，这个 <code>always</code> 语句非常精确地模拟了上图中电路的行为。</p>
<p>另外，有一点会使得初学者产生较大的疑问。为什么 Verilog 规定只有寄存器（register）类型的变量才能够在过程赋值语句中被赋值呢？有时候在Verilog中定义的寄存器变量，在综合时并不一定映射成一个实在的触发器硬件。比如在以上的例子中，<code>Temp</code> 和 <code>D_out</code> 被定义成 <code>reg</code> 变量，而综合结果它们却还是组合逻辑，并不是存储单元。</p>
<p>在 Verilog  语言中，寄存器变量的特点是需要在仿真运行器件上保持它的值，也就是说，这个变量在仿真时需要占据内存空间。</p>
<p>在以上的 <code>always</code> 实例中，<code>always</code> 语句块只对 <code>A_in</code> 等 3 个输人变化敏感。如果没有这 3 个变量的变化事件，<code>Temp</code> 和 <code>D_out</code> 变量将需要保存其值，因此它们必须被定义为寄存器类型变量。但是，它们在综合之后，并不对应硬件锁存器或者触发器。</p>
<h3 id="3-2-2-非阻塞赋值"><a href="#3-2-2-非阻塞赋值" class="headerlink" title="3.2.2. 非阻塞赋值"></a>3.2.2. 非阻塞赋值</h3><p>非阻寒赋值的语法如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">寄存器变量 &lt;= 表达式;</span><br></pre></td></tr></table></figure>
<p>它的特点是在执行该语句时，首先计算右边的表达式，然后并不立刻对左边的变量赋值。由于这个赋值操作在当前仿真时间事件队列中的优先级比较低，因此<strong>将赋值推迟到当前仿真时刻的后期运行</strong>。关于具体非阻塞赋值的右式计算和左式更新是何时完成的，请参考后续内容。</p>
<p>与阻塞赋值不同的是，如果多个非阻塞赋值语句顺序出现在 <code>begin ... end</code> 语句中，前面语句的执行，并不会阻塞后面语句的执行。前面语句的计算完成，还没有赋值时，就会执行下一句的右边表达式计算。例如 <code>begin m &lt;= n; n &lt;= m; end</code> 语句中，最后的结果是将m与n值互换了。</p>
<p>如果想要采用如下代码来描述<a href="#一个组合逻辑">前述组合逻辑电路</a>的功能：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">wire</span> A_in, B_in, C_in;</span><br><span class="line"><span class="keyword">reg</span> Temp, D_out;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">always</span> @(A_in <span class="keyword">or</span> B_in <span class="keyword">or</span> C_in) <span class="keyword">begin</span></span><br><span class="line">    Temp &lt;= A_in &amp; B_in;            <span class="comment">// 非阻塞赋值</span></span><br><span class="line">    D_out &lt;= Temp | C_in;           <span class="comment">// 非阻塞赋值</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>如果使用仿真工具去仿真这段代码，就会发现它的功能并不是所想要的功能。比如当 <code>A_in</code> 发生变化，执行 <code>always</code> 语句，其中 <code>Temp &lt;= A_in &amp; B_in;</code> 这句话并没有立刻对 <code>Temp</code> 赋值，而是放在当前仿真时刻的后期才开始执行 <code>Temp</code> 的更新。这样，当执行 <code>D_out &lt;=Temp | C_in;</code> 表达式的右式计算事件时，<code>Temp</code> 的值还是<br>旧的值，因此这时 <code>D_out</code> 并不会发生变化。</p>
<p>大家也许可以尝试将如上的代码用综合工具综合一下，可能同样会得到<a href="#一个组合逻辑">前述组合逻辑电路</a>的情况。这是由于一些综合工具可以容忍用户的这些代码缺陷。这就造成了 RTL 仿真和综合的结果不一致的现象。</p>
<p>为什么会造成这个现象呢？因为 RTL 的仿真器严格按照 Verilog 的仿真语义执行 RTL 的仿真过程，而综合工具通常只是根据用户的代码推断设计者的意图，然后生成相应的电路结构。因此，综合的过程有一定的主观推断性，并不严格遵守 Verilog 的语义，不同的综合工具判决标准也不一样。</p>
<p>这种情况是每一个设计都应该尽量避免的，因为仿真和综合结果不一致说明源代码中很可能有隐患，不符合 Verilog 的语义，会错过许多 bug，增加设计的不稳定性。</p>
<p>所以保证仿真器和综合器都能正确理解设计的代码，是非常关键的。</p>
<p><strong>通常利用非阻塞赋值的特点来对时序逻辑进行建模。</strong></p>
<p>代码如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">    q1 &lt;= d;</span><br><span class="line">    q2 &lt;= q1;</span><br><span class="line">    q3 &lt;= q2;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>其实现结果如下图：</p>
<div align="center">
  <img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-30-josh-verilog-part-3/2020-11-30-josh-verilog-part-3-080-ThreeFlowStateRegister.png!sign"/>
</div>

<p>正是利用了语句之间的非阻塞性，才实现了这个 3 级流水线的逻辑功能。</p>
<h3 id="3-2-3-过程连续赋值"><a href="#3-2-3-过程连续赋值" class="headerlink" title="3.2.3. 过程连续赋值"></a>3.2.3. 过程连续赋值</h3><p>在 Verilog 语言中，还有一种过程赋值语句叫做“过程连续赋值”，它们也是出现在 <code>always</code> 和 <code>initial</code> 语句块中的。</p>
<p>过程连续赋值主要有两种：</p>
<ul>
<li><code>assign</code> 与 <code>deassign</code>：在过程语句块中对寄存器变量强制赋值和放开；</li>
<li><code>force</code> 与 <code>release</code>：在过程语句块中对寄存器和线网进行强制赋值和放开。</li>
</ul>
<p>例如，在下面的代码实例中用 <code>assign</code> 和 <code>deassign</code> 描述了一个带异步清零端的 D 触发器。</p>
<figure class="highlight verilog"><figcaption><span>DEF.V</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> DEF(D, clr, clk, Q);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span> D, clr, clk;</span><br><span class="line"><span class="keyword">output</span> Q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span> Q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(clr) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!clr)</span><br><span class="line">        <span class="keyword">assign</span> Q = <span class="number">0</span>;       <span class="comment">// D 的值对 Q 无效, 将 Q 强制为 0</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">deassign</span> Q;         <span class="comment">// 将强制的 Q 值放开</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">negedge</span> clk)</span><br><span class="line">    Q = D;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>这里不再对过程连续赋值进行过多阐述，有兴趣可以参考其他文献。</p>
<h2 id="3-3-语句组"><a href="#3-3-语句组" class="headerlink" title="3.3. 语句组"></a>3.3. 语句组</h2><p>语句组是两条以上语句的组合，它们看起来像一个独立的语句。语句组也是出现在 <code>initial</code> 和 <code>always</code> 的过程块中的。</p>
<p>根据其中语句的执行顺序，语句组可以分为“顺序语句组”和“并行语句组”两种。</p>
<h3 id="3-3-1-顺序语句组-begin-end"><a href="#3-3-1-顺序语句组-begin-end" class="headerlink" title="3.3.1. 顺序语句组 begin ... end"></a>3.3.1. 顺序语句组 <code>begin ... end</code></h3><p>在顺序语句组中，其中的语句是一条一条顺序执行的。比如下面的语句：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @(A_in <span class="keyword">or</span> B_in <span class="keyword">or</span> C_in) <span class="keyword">begin</span></span><br><span class="line">    Temp = A_in &amp; B_in;                 <span class="comment">// 阻塞赋值</span></span><br><span class="line">    D_out = Temp | C_in;                <span class="comment">// 阻塞赋值</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>首先执行第一句，将 <code>A_in</code> 和 <code>B_in</code> 相与，然后将结果赋给 <code>Temp</code> 变量；再执行第一句，将新的 <code>Temp</code> 值 <code>C_in</code> 相或，结果立刻赋给 <code>D_out</code>。</p>
<p>当然，这里是同时利用了 <code>begin ... end</code> 语句组和阻塞赋值的特点，才实现了用户想要的逻辑功能。</p>
<p>再比如要产生一个值序列：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">initial</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    DataBin = <span class="number">0</span>;</span><br><span class="line">    #<span class="number">6</span> DataBin = <span class="number">0</span>;</span><br><span class="line">    #<span class="number">4</span> DataBin = <span class="number">1</span>;</span><br><span class="line">    #<span class="number">2</span> DataBin = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>由于语句是顺序执行的，产生的波形如下图所示。</p>
<div align="center">
  <img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-30-josh-verilog-part-3/2020-11-30-josh-verilog-part-3-090-SequentialWave.png!500px"/>
</div>

<h3 id="3-3-2-并行语句组-fork-join"><a href="#3-3-2-并行语句组-fork-join" class="headerlink" title="3.3.2. 并行语句组 fork ... join"></a>3.3.2. 并行语句组 <code>fork ... join</code></h3><p>在<code>fork ... join</code> 语句组中，语句是并行执行的。将上一小节的代码改写如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">initial</span></span><br><span class="line"><span class="keyword">fork</span></span><br><span class="line">    DataBin = <span class="number">0</span>;</span><br><span class="line">    #<span class="number">6</span> DataBin = <span class="number">0</span>;</span><br><span class="line">    #<span class="number">4</span> DataBin = <span class="number">1</span>;</span><br><span class="line">    #<span class="number">2</span> DataBin = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">join</span></span><br></pre></td></tr></table></figure>
<p>由于其中的所有语句并行执行，也就是以上 4 条语句都是从 0 时刻开始同时执行的，产生的波形如下图。</p>
<div align="center">
  <img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-30-josh-verilog-part-3/2020-11-30-josh-verilog-part-3-100-ParallelWave.png!500px"/>
</div>

<h3 id="3-3-3-语句组的标识符"><a href="#3-3-3-语句组的标识符" class="headerlink" title="3.3.3. 语句组的标识符"></a>3.3.3. 语句组的标识符</h3><p>语句组可以有标识符，也可以没有。</p>
<p>当一个语句组有标识符时，在语句组内部可以定义局部变量，而不会传递到语句组的外部。然而，在仿真语义上，这个变量是静态变量，它的值在整个仿真运行周期中是不变的，但是不会与其他语句组中同一个名称的变量发生冲突。例如：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span> i;              <span class="comment">// always 语句以外的 i 变量</span></span><br><span class="line"><span class="keyword">always</span> @(...)</span><br><span class="line"><span class="keyword">begin</span>: SORT</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">integer</span> i;          <span class="comment">// 语句组内部的土变量</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>;i &lt;= <span class="number">7</span>; i = i + <span class="number">1</span>)</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>在 <code>always</code> 以外的i变量和 <code>always</code> 里面定义的i变量属于<strong>两个不同的变量，并不冲突</strong>。它们在仿真的时候将占用两块不同的内存，类似于 C 语言中的静态局部变量。</p>
<h2 id="3-4-高级编程语旬"><a href="#3-4-高级编程语旬" class="headerlink" title="3.4. 高级编程语旬"></a>3.4. 高级编程语旬</h2><h3 id="3-4-1-为什么需要编程语句"><a href="#3-4-1-为什么需要编程语句" class="headerlink" title="3.4.1. 为什么需要编程语句"></a>3.4.1. 为什么需要编程语句</h3><p>Verilog 作为硬件描述语言，最重要的特性就是其设计层次比较高，不仅停留在晶体管级和门级，而是可以在更高的层次如 RTL 级甚至是行为级描述硬件系统的行为，或者编写测试激励。</p>
<p>为了达到提高描述能力、提高抽象层次，Verilog 语言从 C 语言等编程语言中借鉴了一语句，同时也创造了一些语句，例如 <code>if</code>、<code>case</code>、<code>while</code>、<code>for</code>、<code>repeat</code> 和 <code>forever</code> 等。这些语句被称为高级编程语句。有了这些语句 Verilog 才可以描述比较复杂的电路行为。</p>
<p>编程语句只能出现在 <code>initial</code> 和 <code>always</code> 的过程块中。编程语句中可以嵌套其他的语句，比如过程赋值语句或者其他编程语句。</p>
<p>高级编程语分为3大类：</p>
<ul>
<li><code>if ... else</code> 语句；</li>
<li>case语句；</li>
<li>循环语句：<code>forever</code>、<code>repeat</code>、<code>while</code>、<code>for</code>。</li>
</ul>
<p>下面将逐一介绍。</p>
<h3 id="3-4-2-if-else-语句"><a href="#3-4-2-if-else-语句" class="headerlink" title="3.4.2. if ... else 语句"></a>3.4.2. <code>if ... else</code> 语句</h3><p><code>if</code> 语句后面跟语句或语句组（<code>begin ... end</code> 或 <code>fork ... join</code>)。常和 <code>else</code> 搭配来实现不同条件的各种情况。<code>if</code> 也可以单独使用，没有 <code>else</code> 配合。</p>
<p>现考虑以下代码：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @(sel_a <span class="keyword">or</span> sel_b <span class="keyword">or</span> a <span class="keyword">or</span> b <span class="keyword">or</span> c) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (sel_a)</span><br><span class="line">        q = a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (sel_b)</span><br><span class="line">        q = b;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        q = c;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>它要实现的逻辑如下图。</p>
<div align="center">
  <img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-30-josh-verilog-part-3/2020-11-30-josh-verilog-part-3-110-IfElseStatement.png!600px"/>
</div>

<p>在 <code>if ... else</code> 语句中，条件是从上到下逐条检查的。因此，当满足一个条件时，就执行其后的语句，跳过 <code>else</code> 后面的语句、当所有条件都不满足，便执行最后一条 <code>else</code> 后面的语句。因此 <code>if ... else</code> 语句实际上是有优先级顺序的。</p>
<p>实际在上例中使用了 <code>if ... else</code> 优先级编码的特点，<code>sel_a</code> 的判断优先级最高，因此在逻辑中的级数要明显少一些，参考上图。如果 <code>sel_a</code> 为关键路径的话，就可以利用这样的优先级编码提高设计的性能。</p>
<p>在使用 <code>if ... else</code> 语句时，<strong>尤其是用在组合逻辑中，需要注意不要引入 Latch 电路</strong>。先来看如下的代码：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @(sel <span class="keyword">or</span> a <span class="keyword">or</span> b <span class="keyword">or</span> c) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (sel == <span class="number">2&#x27;b00</span>)</span><br><span class="line">        q = a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (sel == <span class="number">2&#x27;b01</span>)</span><br><span class="line">        q = b;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (sel == <span class="number">2&#x27;b10</span>)</span><br><span class="line">        q = c;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>由于，最后一个条件 <code>sel == 2&#39;b11</code> 的语句没有被显式地写出，言下之意是，当 <code>sel</code> 为 <code>2&#39;b11</code> 时，<code>q</code> 值需要保持不变。这个代码在综合时自然就会产生锁存器，如下图。</p>
<div align="center">
  <img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-30-josh-verilog-part-3/2020-11-30-josh-verilog-part-3-120-CombinationalLogicwithLatch.png!800px"/>
</div>

<p><strong>锁存器在数字同步逻辑设计中应该尽量避免。因为锁存器容易引起竞争冒险，同时静态时序分析工具也不好分析穿过锁存器的路径。</strong></p>
<p>在下面的代码中，己经明确写出：当 <code>se</code> 为 <code>2&#39;b11</code> 时，<code>q</code> 值不关心，赋值为 <code>x</code>。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @(sel <span class="keyword">or</span> a <span class="keyword">or</span> b <span class="keyword">or</span> c) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (sel == <span class="number">2&#x27;b00</span>)</span><br><span class="line">        q = a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (sel == <span class="number">2&#x27;b01</span>)</span><br><span class="line">        q = b;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (sel == <span class="number">2&#x27;b10</span>)</span><br><span class="line">        q = c;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        q = <span class="number">1&#x27;bx</span>;       <span class="comment">// 当 sel 为 2&#x27;b11 时, q 值不关心</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>既然不关心 <code>sel</code> 为 <code>2&#39;b11</code> 时 <code>q</code> 的值，那么有的综合工具就顺手将 <code>sel</code> 等于 <code>2&#39;b11</code> 时 <code>q</code> 的值也赋值为 <code>c</code>，这样就避免了锁存器的产生。实现电路如下图。</p>
<div align="center">
  <img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-30-josh-verilog-part-3/2020-11-30-josh-verilog-part-3-130-CombinationalLogicwithoutLatch.png!sign"/>
</div>

<p><span id="无锁存器的组合逻辑电路"></span></p>
<p>然而，在描述时序逻辑时，通常将利用 <code>if</code> 语句的隐式条件对带时钟使能的 D 触发器建模。代码如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (~rst_n)</span><br><span class="line">        sum &lt;= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (en)</span><br><span class="line">        sum &lt;= a + b;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>以上语句表示在时钟正沿来临时，如果 <code>en</code> 为 1，则将 <code>a + b</code> 的值付给 <code>sum</code>。言下之意：如果 <code>en</code> 为 0，那么 <code>sum</code> 保持原值不变。因此，这里综合工具会把代码综合成一个时钟使能的寄存器，如图3一14所示。</p>
<div align="center">
  <img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-30-josh-verilog-part-3/2020-11-30-josh-verilog-part-3-140-DFlipFlopClock.png!800px"/>
</div>

<p>其中，<code>en</code> 信号时 D 触发器的时钟使能端，<code>rst_n</code> 是 D 触发器的异步清零信号。</p>
<h3 id="3-4-3-case-语句"><a href="#3-4-3-case-语句" class="headerlink" title="3.4.3. case 语句"></a>3.4.3. <code>case</code> 语句</h3><p><code>case</code> 语句的功能同正一类似，但是又有很大的不同。它后面也可以跟语句或语句组（<code>begin ... end</code> 或 <code>fork ... join</code>）。</p>
<p>如下例：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @(sel <span class="keyword">or</span> a <span class="keyword">or</span> b <span class="keyword">or</span> c) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">case</span>(sel)</span><br><span class="line">        <span class="number">2&#x27;b00</span>: q = a;</span><br><span class="line">        <span class="number">2&#x27;b01</span>: q = b;</span><br><span class="line">        <span class="number">2&#x27;b10</span>: q = c;</span><br><span class="line">        <span class="keyword">default</span>: q = <span class="number">1&#x27;bx</span>；</span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>在 <code>case</code> 语句中，<code>default:</code> 一条描述了所有没有明确说明的其他可能情况。比如，这里的 <code>default</code> 就包含了 <code>sel</code> 为 <code>2&#39;b11</code>、<code>2&#39;bzz</code> 和 <code>2&#39;bxx</code> 等情况。</p>
<p>以上的代码将实现如上的<a href="#无锁存器的组合逻辑电路">无锁存器的组合逻辑电路</a>。</p>
<p>与 <code>if ... else</code> 语句不同的是，在 <code>case</code> 语句中，所有被判断的分支条件都具有一样的优先级。</p>
<p>与 <code>if ... else</code> 类似的是，语句同样需要考虑所有可能的情况，否则将会产生不想要的锁存器。如果将代码改为：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @(sel <span class="keyword">or</span> a <span class="keyword">or</span> b <span class="keyword">or</span> c) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">case</span>(sel)</span><br><span class="line">        <span class="number">2&#x27;b00</span>: q = a;</span><br><span class="line">        <span class="number">2&#x27;b01</span>: q = b;</span><br><span class="line">        <span class="number">2&#x27;b10</span>: q = c;</span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>这样，将会产生与如上的<a href="#带锁存器的组合逻辑电路">带锁存器的组合逻辑电路</a>。这是设计者不愿意看到的。</p>
<p>对于 <code>case</code> 语句，有两个派生语句，即 <code>casez</code> 及 <code>casex</code>。</p>
<p><code>casez</code> 语句将分支条件中所有的 <code>z</code> 看作“不关心”的值，而不看作任何逻辑值。条件中的 <code>z</code> 可以改写为 <code>?</code>，如下例：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">casez</span> (encoder)</span><br><span class="line">    <span class="number">4&#x27;b1</span>???: hign_lvl = <span class="number">3</span>;</span><br><span class="line">    <span class="number">4&#x27;b01</span>??: hign_lvl = <span class="number">2</span>;</span><br><span class="line">    <span class="number">4&#x27;b001</span>?: hign_lvl = <span class="number">1</span>;</span><br><span class="line">    <span class="number">4&#x27;b0001</span>: high_lvl = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">default</span>: high_lvl = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">endcase</span></span><br></pre></td></tr></table></figure>
<p>这里，如果 <code>encoder</code> 为 <code>4b&#39;1zzz</code> 则 <code>high_lvl</code> 取值为 3。</p>
<p><code>casex</code> 语句将分支条件中所有的x和z看作“不关心”的值，而不看作任何逻辑值。如下例：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">casex</span> (encoder)</span><br><span class="line">    <span class="number">4&#x27;b1xxx</span>: hign_lvl = <span class="number">3</span>;</span><br><span class="line">    <span class="number">4&#x27;b01xx</span>: hign_lvl = <span class="number">2</span>;</span><br><span class="line">    <span class="number">4&#x27;b001x</span>: hign_lvl = <span class="number">1</span>;</span><br><span class="line">    <span class="number">4&#x27;b0001</span>: high_lvl = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">default</span>: high_lvl = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">endcase</span></span><br></pre></td></tr></table></figure>
<p>这里，如果 <code>encoder</code> 为 <code>4&#39;b1xzx</code>，则 <code>high-lvl</code> 取值为 3。</p>
<h3 id="3-4-4-循环语句"><a href="#3-4-4-循环语句" class="headerlink" title="3.4.4. 循环语句"></a>3.4.4. 循环语句</h3><p>循环语句一般用于重复的操作。</p>
<p>循环语句后面可以跟语句或语句组（<code>begin ... end</code> 或 <code>fork ... join</code>)。</p>
<ol>
<li><p><code>forever</code> 循环：永远执行</p>
 <figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    clk = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">forever</span> #<span class="number">25</span> clk = ~clk;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p> 以上语句产生了一个周期为 50 个时间单位的时钟。</p>
</li>
<li><p><code>repeat</code> 循环：执行固定的次数</p>
 <figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (rotate == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">repeat</span> (<span class="number">8</span>)</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        tmp = data[<span class="number">15</span>];</span><br><span class="line">        data = &#123;data&lt;&lt;<span class="number">1</span>, temp&#125;;</span><br><span class="line">    <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p> 以上语句中，当为 1 时，重复对 <code>data</code> 数据做8次循环左移。</p>
</li>
<li><p><code>while</code> 循环：当表达式为真时执行</p>
 <figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (count &lt; <span class="number">101</span>) <span class="keyword">begin</span></span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;Count = %d&quot;</span>, count);</span><br><span class="line">        count = count + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p> 在 <code>while</code> 语句中，只要后面的条件满足，就持续执行该语句，直到条件不满足，跳出循环。这里，将 <code>count</code> 从 0 递增到 101，逐步打印出来。</p>
</li>
<li><p><code>for</code> 循环：从初始值开始，如果表达式为真就执行</p>
 <figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span> i;          <span class="comment">// 为 for 循环声明索引</span></span><br><span class="line"><span class="keyword">always</span> @(inp <span class="keyword">or</span> cnt) <span class="keyword">begin</span></span><br><span class="line">    result[<span class="number">7</span>:<span class="number">4</span>] = <span class="number">0</span>;</span><br><span class="line">    result[<span class="number">3</span>:<span class="number">0</span>] = inp;</span><br><span class="line">    <span class="keyword">if</span> (cnt == <span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">4</span>; i &lt;= <span class="number">7</span>; i = i + <span class="number">1</span>)</span><br><span class="line">            result[i] = result[i-<span class="number">4</span>];</span><br><span class="line">        result[<span class="number">3</span>:<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p> <code>for</code> 语句开始执行直到 <code>i</code> 大于 7，跳出循环。如上代码实现了一个位的左移器。</p>
</li>
</ol>
<p>简单介绍了 Verilog 中的高级编程语句，只要对 C 语言有一定基础，就能迅速掌握其中的用法。</p>
<h1 id="4-结构化描述"><a href="#4-结构化描述" class="headerlink" title="4. 结构化描述"></a>4. 结构化描述</h1><p>结构化描述就是在设计中<strong>实例化已有的功能模块</strong>，这些功能模块包括：门原语、用户自定义原语（UDP）、其他模块（module）。以下是结构化描述的3种实例类型：实例化其他模块、实例化门及实例化UDP。</p>
<p>下例是由两个半加器组成的全加器的模型，其中所有模块都采用了结构化描述方法。</p>
<figure class="highlight verilog"><figcaption><span>HalfAdd.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> HalfAdd(X, Y, sum, C_out);                   <span class="comment">// 半加器模块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span> X;</span><br><span class="line"><span class="keyword">input</span> Y;</span><br><span class="line"><span class="keyword">output</span> sum;</span><br><span class="line"><span class="keyword">output</span> C_out;</span><br><span class="line"></span><br><span class="line"><span class="comment">// assign sum = X ^ Y;</span></span><br><span class="line"><span class="comment">// assign C_out = X &amp; Y;</span></span><br><span class="line"><span class="keyword">xor</span> u_xor(sum, X, Y);                               <span class="comment">// 门级原语实例</span></span><br><span class="line"><span class="keyword">and</span> u_and(C_out, X, Y);                             <span class="comment">// 门级原语实例</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span> </span><br></pre></td></tr></table></figure>
<figure class="highlight verilog"><figcaption><span>FullAdd.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> FullAdd(X, Y, C_in, sum, C_out);             <span class="comment">// 全加器模块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span> X;</span><br><span class="line"><span class="keyword">input</span> Y;</span><br><span class="line"><span class="keyword">input</span> C_in;</span><br><span class="line"><span class="keyword">output</span> sum;</span><br><span class="line"><span class="keyword">output</span> C_out;</span><br><span class="line"></span><br><span class="line"><span class="keyword">wire</span> HalfAdd_A_sum;</span><br><span class="line"><span class="keyword">wire</span> HalfAdd_A_Cout;</span><br><span class="line"><span class="keyword">wire</span> HalfAdd_B_Cout;</span><br><span class="line"></span><br><span class="line"><span class="comment">// assign C_out = HalfAdd_A_Cout | HalfAdd_B_Cout;</span></span><br><span class="line"><span class="keyword">or</span> u_or(C_out, HalfAdd_A_Cout, HalfAdd_B_Cout);     <span class="comment">// 门级原语实例</span></span><br><span class="line"></span><br><span class="line">HalfAdd u_HalfAdd_A(                                <span class="comment">// 半加器实例 A</span></span><br><span class="line">    <span class="variable">.X</span>      (C_in),</span><br><span class="line">    <span class="variable">.Y</span>      (Y),</span><br><span class="line">    <span class="variable">.sum</span>    (HalfAdd_A_sum),</span><br><span class="line">    <span class="variable">.C_out</span>  (HalfAdd_A_Cout)</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">HalfAdd u_HalfAdd_B(                                <span class="comment">// 半加器实例 B</span></span><br><span class="line">    <span class="variable">.X</span>      (C_in),</span><br><span class="line">    <span class="variable">.Y</span>      (HalfAdd_A_sum),</span><br><span class="line">    <span class="variable">.sum</span>    (sum),</span><br><span class="line">    <span class="variable">.C_out</span>  (HalfAdd_B_Cout)</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line"><span class="keyword">endmodule</span> </span><br></pre></td></tr></table></figure>
<p>上例已将<a href="#半加器代码">原半加器代码</a>中的语句改为门原语的实例化。在全加器的模块中，有两个半加器模块的实例和一个 <code>or</code> 门原语的实例。</p>
<p>在以上代码中，实例化的 <code>or</code> 门原语是 Verilog 语言自带的电路，实例化的半加器模块则是用户自己设计的模块。</p>
<p>实现电路如下图。</p>
<div align="center">
  <img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-30-josh-verilog-part-3/2020-11-30-josh-verilog-part-3-150-FullAdder.png!sign"/>
</div>

<p>以上内容提到了实例化基本门和其他模块。</p>
<p>关于 UDP，它是用户自定义的原语，由于应用不广泛，其功能基本上可以由模块替代，因此不再介绍。</p>
<h2 id="4-1-实例化模块的方法"><a href="#4-1-实例化模块的方法" class="headerlink" title="4.1. 实例化模块的方法"></a>4.1. 实例化模块的方法</h2><p>在结构化描述中，需要将模块实例与外部信号相连接。下面谈谈模块实例的端口连接规则。</p>
<p>先看一个模块内部输入/输出/双向端口的内部属性：</p>
<ul>
<li><strong><code>input</code>：在模块内部默认是一个线网类型；</strong></li>
<li><strong><code>output</code>：在模块内部是一个寄存器（在过程赋值语句中被赋值）或者线网类型；</strong></li>
<li><strong><code>inout</code>：在模块内部默认是一个线网类型，是双向信号，一般定义为 <code>tri</code>。</strong></li>
</ul>
<p>当这个模块被实例化时，与之相连的信号类型如下：</p>
<ul>
<li><strong>与模块 <code>input</code> 端口相连：可以是一个线网或者寄存器；</strong></li>
<li><strong>与模块 <code>output</code> 端口相连：一定是驱动到一个线网；</strong></li>
<li><strong>与模块 <code>inout</code> 端口相连：输入时从一个线网驱动来，输出时驱动到一个线网。</strong></li>
</ul>
<p>初学者经常犯这样一个错误，将寄存器变量驱动 <code>inout</code> 端口，导致编译出错。因为，只有线网类型可以驱动 <code>inout</code> 端口。</p>
<p>下图清楚地了模块端口在内部和外部的类型。</p>
<div align="center">
  <img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-30-josh-verilog-part-3/2020-11-30-josh-verilog-part-3-160-ModuleConnection.png!sign"/>
</div>

<p>下面举例说明模块内部和外部的端口：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">HalfAdd u_HalfAdd_A(                                <span class="comment">// 半加器实例 A</span></span><br><span class="line">    <span class="variable">.X</span>      (C_in),</span><br><span class="line">    <span class="variable">.Y</span>      (Y),</span><br><span class="line">    <span class="variable">.sum</span>    (HalfAdd_A_sum),</span><br><span class="line">    <span class="variable">.C_out</span>  (HalfAdd_A_Cout)</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>
<p>点 <code>.</code> 后面紧跟的信号是 <code>HalfAdd</code> 内的端口名称，而括号中的信号是上一层 <code>FullAdd</code> 模块中的驱动源或被驱动信号。</p>
<p>模块实例的端口对应方式有以下两种：名称对应及位置对应。</p>
<p>所谓名称对应是指：将模块实例外部的信号直接对应于模块的端口名称。在实例化 <code>HalfAdd</code> 时就是采用了名称对应的方法。</p>
<p>在这种端口对应方式下，端口对应的顺序可以是任意的。在没有对应外部信号的时候，可以将端口后面的括号留空。如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">模块 实例名称(</span><br><span class="line">    .模块端口名称           (实例外部信号),</span><br><span class="line">    .模块端口名称           (实例外部信号),</span><br><span class="line">    .模块端口名称           (),             <span class="comment">//无对应信号</span></span><br><span class="line">    ...);</span><br></pre></td></tr></table></figure>
<p>位置对应方式就是在模块实例化的时候外部的信号需要按照该模块端口声明的顺序一一对应。例如：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> HalfAdd(X, Y, sum, C_out);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>在实例化该模块的时候，可以使用：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">HaIfAdd u_HalfAdd(E_X, E_Y, E_sum, E_C_out);</span><br></pre></td></tr></table></figure>
<p>其中 <code>E_X</code>、<code>E_Y</code>、<code>E_sum</code> 和 <code>E_C_out</code> 分别对应 <code>HalfAdd</code> 的端口 <code>X</code>、<code>Y</code>、<code>sum</code> 和 <code>C_out</code>，严格按照<code>HalfAdd</code> 模块的端口位置顺序。如果在没有对应外部信号的时候，就需要将位置留空。例如：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">HaIfAdd u_HalfAdd(E_X, E_Y, , E_C_out);</span><br></pre></td></tr></table></figure>
<p>其中 <code>E_X</code>、<code>E_Y</code> 和 <code>E_C_out</code> 分别对应 <code>HaIfAdd</code> 的端口 <code>X</code>、<code>Y</code> 和 <code>C_out</code>，模块端口 <code>sum</code> 没有对应的外部信号。</p>
<h2 id="4-2-参数"><a href="#4-2-参数" class="headerlink" title="4.2. 参数"></a>4.2. 参数</h2><p>在本小节中将讨论可参数化的模块。</p>
<h3 id="4-2-1-参数定义"><a href="#4-2-1-参数定义" class="headerlink" title="4.2.1. 参数定义"></a>4.2.1. 参数定义</h3><p><code>module</code> 中的参数一般是定义其中常量的工具。</p>
<p>如下的代码中定义了半加器的“与门”和“异或门”的延时分别为 2 和 4 个时间单位：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> half_adder(co, sum, a, b)</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span> a, b;</span><br><span class="line"><span class="keyword">output</span> co, sum;</span><br><span class="line"></span><br><span class="line"><span class="keyword">parameter</span> and_delay = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">parameter</span> xor_delay = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">and</span> #and_delay u1(co, a, b);</span><br><span class="line"><span class="keyword">xor</span> #xor_delay u2(sum, a, b);</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>实际上，在 Verilog 语言中，<strong>当实例化模块时用户可以修改模块中的参数</strong>，用来实现不同的特性。这个定制过程是通过“新参数直接带入”或“参数重定义”完成的。</p>
<p>Verilog 模块参数的这一特性非常有用，用户可以定义一个通用的模块，其具有缺省的参数值，然后通过改变参数来做成不同的实例模块。</p>
<p>例如，可以设计一个通用的 RAM 模块，将其位宽和地址深度定义为参数。在具体使用时，如果需要用到不同的位宽和深度，用户则可以通过改变模块中的参数实现。</p>
<h3 id="4-2-2-参数的定制"><a href="#4-2-2-参数的定制" class="headerlink" title="4.2.2. 参数的定制"></a>4.2.2. 参数的定制</h3><p>参数的用户定制有两种方法：</p>
<ol>
<li>通过 <code>defparam</code> 关键字对模块中的参数重新定义；</li>
<li>参数直接在实例化模块时代入。</li>
</ol>
<p>有意思的是，两家最大的 PLD 供应商 Altera 和 Xilinx 的通用模块定制恰好分别采用了这两种方法。<br>比如 Altera 的 Quartus II 开发环境中，用 MegaWiard 工具定制一个宽 8 深 32 位的单口 RAM 时，将产生如下的代码：</p>
<figure class="highlight verilog"><figcaption><span>ran_w8_d32.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> ran_w8_d32(address, clock, data, wren, q);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span> [<span class="number">4</span>:<span class="number">0</span>] address;</span><br><span class="line"><span class="keyword">input</span>       clock;</span><br><span class="line"><span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>] data;</span><br><span class="line"><span class="keyword">input</span>       wren;</span><br><span class="line"><span class="keyword">output</span>      q;</span><br><span class="line"></span><br><span class="line">altsyncram altsyncram_component(</span><br><span class="line">    <span class="variable">.wren_a</span>        (wren),</span><br><span class="line">    <span class="variable">.clock0</span>        (clock),</span><br><span class="line">    <span class="variable">.address_a</span>     (address),</span><br><span class="line">    <span class="variable">.data_a</span>        (data),</span><br><span class="line">    <span class="variable">.q_a</span>           (q),</span><br><span class="line">    <span class="variable">.aclr0</span>         (<span class="number">1&#x27;b0</span>),</span><br><span class="line">    <span class="variable">.aclr1</span>         (<span class="number">1&#x27;b0</span>),</span><br><span class="line">    <span class="variable">.q_b</span>           (),</span><br><span class="line">    <span class="variable">.clocken1</span>      (<span class="number">1&#x27;b1</span>),</span><br><span class="line">    <span class="variable">.clocken0</span>      (<span class="number">1&#x27;b0</span>),</span><br><span class="line">    <span class="variable">.data_b</span>        (<span class="number">1&#x27;b1</span>),</span><br><span class="line">    <span class="variable">.rden_b</span>        (<span class="number">1&#x27;b1</span>),</span><br><span class="line">    <span class="variable">.address_b</span>     (<span class="number">1&#x27;b1</span>),</span><br><span class="line">    <span class="variable">.wren_b</span>        (<span class="number">1&#x27;b0</span>),</span><br><span class="line">    <span class="variable">.byteena_b</span>     (<span class="number">1&#x27;b0</span>),</span><br><span class="line">    <span class="variable">.addressstall_a</span>(<span class="number">1&#x27;b0</span>),</span><br><span class="line">    <span class="variable">.byteena_a</span>     (<span class="number">1&#x27;b1</span>),</span><br><span class="line">    <span class="variable">.addressstall_b</span>(<span class="number">1&#x27;b0</span>),</span><br><span class="line">    <span class="variable">.clocken1</span>      (<span class="number">1&#x27;b1</span>)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line"><span class="keyword">defparam</span></span><br><span class="line">    altsyncram_component<span class="variable">.clock_enable_input_a</span> = <span class="string">&quot;BYPASS&quot;</span>,</span><br><span class="line">    altsyncram_component<span class="variable">.clock_enable_output_a</span> = <span class="string">&quot;BYPASS&quot;</span>,</span><br><span class="line">    altsyncram_component<span class="variable">.intended_device_family</span> = <span class="string">&quot;Stratix II&quot;</span>,</span><br><span class="line">    altsyncram_component<span class="variable">.lpm_hint</span> = <span class="string">&quot;ENABLE_RUNTIME_MOD = NO&quot;</span>,</span><br><span class="line">    altsyncram_component<span class="variable">.lpm_type</span> = <span class="string">&quot;altsyncram&quot;</span>,</span><br><span class="line">    altsyncram_component<span class="variable">.numwords_a</span> = <span class="number">32</span>,               <span class="comment">// 32 个字</span></span><br><span class="line">    altsyncram_component<span class="variable">.operation_mode</span> = <span class="string">&quot;SINGLE_PORT&quot;</span>,</span><br><span class="line">    altsyncram_component<span class="variable">.outdata_aclr_a</span> = <span class="string">&quot;NONE&quot;</span>,</span><br><span class="line">    altsyncram_component<span class="variable">.outdata_reg_a</span> = <span class="string">&quot;UNREGISTERED&quot;</span>,</span><br><span class="line">    altsyncram_component<span class="variable">.power_up_uninitialized</span> = <span class="string">&quot;FALSE&quot;</span>,</span><br><span class="line">    altsyncram_component<span class="variable">.ram_block_type</span> = <span class="string">&quot;M4K&quot;</span>,</span><br><span class="line">    altsyncram_component<span class="variable">.widthad_a</span> = <span class="number">5</span>,                 <span class="comment">// 5 位地址</span></span><br><span class="line">    altsyncram_component<span class="variable">.width_a</span> = <span class="number">8</span>,                   <span class="comment">// 8 位宽的数据</span></span><br><span class="line">    altsyncram_component<span class="variable">.width_byteena_a</span> = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>其中，<code>altsyncram</code> 是 Altera 的块 RAM 的通用模型。它可以在 Altera 的仿真文件“alteramf.v”中找到。</p>
<p><code>altsyncram-component</code> 是实例名称，<code>.</code> 后面是参数的名称，定义的参数值，有的是字符串，有的是整数。</p>
<p>在 <code>defparam</code> 关键字后面的是参数重定义的语句：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">altsyncram_component<span class="variable">.width_a</span> = <span class="number">8</span>,               <span class="comment">// 8 位宽的数据</span></span><br></pre></td></tr></table></figure>
<p>以上就是将 <code>altsyncram-component</code> 中的参数 <code>width_a</code> 重新定义为 8。</p>
<p>使用 <code>defparam</code> 的方法重新定义参数时，可以根据需要对部分的参数重新定义，其他的会保留模块的缺省值。</p>
<p>用 Xilinx 设计工具 ISE 中的 CORE Generator 产生一个单端口 8 位宽、32 位深的 RAM。注意观察，其中RAM的参数是如何带入的：</p>
<figure class="highlight verilog"><figcaption><span>ram_w8_d32.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> ram_w8_d32(addr, clk, din, dout, we)</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span> [<span class="number">4</span>:O] addr;</span><br><span class="line"><span class="keyword">input</span>       clk;</span><br><span class="line"><span class="keyword">input</span> [<span class="number">7</span>:O] din.</span><br><span class="line"><span class="keyword">output</span> [<span class="number">7</span>:<span class="number">0</span>] dout;</span><br><span class="line"><span class="keyword">input</span> we;</span><br><span class="line"></span><br><span class="line"><span class="comment">// synopsys translate_off</span></span><br><span class="line">BLKMEMSP_V6_1 #(</span><br><span class="line">    <span class="number">5</span>,                  <span class="comment">// c_addr_width</span></span><br><span class="line">    <span class="string">&quot;0&quot;</span>,                <span class="comment">// c_default_data</span></span><br><span class="line">    <span class="number">32</span>,                 <span class="comment">// c_depth</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">// c_enable_rlocs</span></span><br><span class="line">    <span class="number">1</span>,                  <span class="comment">// c_has_default_data</span></span><br><span class="line">    <span class="number">1</span>,                  <span class="comment">// c_has_din</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">// c_has_en</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">// c_has_limit_data_pitch</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">// c_has_nd</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">// c_has_rdy</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">// c_has_rfd</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">// c_has_sinit</span></span><br><span class="line">    <span class="number">1</span>,                  <span class="comment">// c_has_we</span></span><br><span class="line">    <span class="number">18</span>,                 <span class="comment">// c_limit_data_pitch</span></span><br><span class="line">    <span class="string">&quot;mif_file_16_1&quot;</span>,    <span class="comment">// c_em_init_file</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">// c_pipe_stages</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">// c_reg_inputs</span></span><br><span class="line">    <span class="string">&quot;0&quot;</span>,                <span class="comment">// c_sinit_value</span></span><br><span class="line">    <span class="number">8</span>,                  <span class="comment">// c_width</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">// c_write_mode</span></span><br><span class="line">    <span class="string">&quot;0&quot;</span>,                <span class="comment">// c_ybottom_addr</span></span><br><span class="line">    <span class="number">1</span>,                  <span class="comment">// c_yclk_is_rising</span></span><br><span class="line">    <span class="number">1</span>,                  <span class="comment">// c_yen_is_high</span></span><br><span class="line">    <span class="string">&quot;hierarchy1&quot;</span>,       <span class="comment">// c_hierarchy</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">// c_ymake_bmm</span></span><br><span class="line">    <span class="string">&quot;32kx1&quot;</span>,            <span class="comment">// c_yprimitive_type</span></span><br><span class="line">    <span class="number">1</span>,                  <span class="comment">// c_ysinit_is_high</span></span><br><span class="line">    <span class="string">&quot;1024&quot;</span>,             <span class="comment">// c_ytop_addr</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">// c_yuse_single_primitive</span></span><br><span class="line">    <span class="number">1</span>,                  <span class="comment">// c_ywe_is_high</span></span><br><span class="line">    <span class="number">1</span>                   <span class="comment">// c_yydisable_warnings</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">inst(</span><br><span class="line">    <span class="variable">.ADDR</span> (addr),</span><br><span class="line">    <span class="variable">.CLK</span>  (clk),</span><br><span class="line">    <span class="variable">.DIN</span>  (din),</span><br><span class="line">    <span class="variable">.DOUT</span> (dout),</span><br><span class="line">    <span class="variable">.WE</span>   (we),</span><br><span class="line">    <span class="variable">.EN</span>   (),</span><br><span class="line">    <span class="variable">.ND</span>   (),</span><br><span class="line">    <span class="variable">.RFD</span>  (),</span><br><span class="line">    <span class="variable">.RDY</span>  (),</span><br><span class="line">    <span class="variable">.SINIT</span>()</span><br><span class="line">    );</span><br><span class="line"><span class="comment">// synopsys translate_on</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>其中 <code>BLKMEMSP_V6_1</code> 是 Xilinx 的块状RAM的通用模型。<code>inst</code> 是用户实例名称。用户需要在通用RAM类型的基础上，通过参数带入实现。采用 <code>#(...)</code> 方法来实现参数逐个覆盖。</p>
<p>使用上面这种参数直接带入法时，要注意一点，所有的参数都需要全部按顺序列出来，不能遗漏，也不能颠倒顺序，否则就容易对应不上。</p>
<h1 id="5-设计层次"><a href="#5-设计层次" class="headerlink" title="5. 设计层次"></a>5. 设计层次</h1><p>在前面几节中，介绍了 Verilog 的描述方式。<br>Verilog 语言是一种强大的硬件描述语言，可以支持多个设计层次。在这里将进行简单的介绍。</p>
<h2 id="5-1-系统级和行为级"><a href="#5-1-系统级和行为级" class="headerlink" title="5.1. 系统级和行为级"></a>5.1. 系统级和行为级</h2><p>Verilog 语言作为一种用户工具，提供给用户许多描述硬件的手段，如前面所述：数据流描述、行为描述（<code>always</code> 和 <code>initial</code> 语句）、结构化描述。同时，不同用户可以根据自己的需要，在不同抽象层次上对硬件进行描述。有如下设计层次金字塔供参考。</p>
<div align="center">
  <img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-30-josh-verilog-part-3/2020-11-30-josh-verilog-part-3-170-DesignLevelPyramid.png!600px"/>
</div>

<p>下面简单介绍几种不同角色的工作特点，以及它们所处的设计层次：</p>
<p>系统构架师：在目前业界主流的设计方法学中，系统构架师（System Architect）通常用高级语言，如SystemC，来描述一个系统的规格，仿真整个系统的功能和性能等。这种早期的设计和探索往往不涉及到具体的实现细节，甚至于软件和硬件的划分都没有开始。系统构架师也可以采用 Verilog 来描述系统的功能，它们往往不考虑硬件实现的细节。因而称这种设计层次为系统级或算法级。</p>
<p>逻辑设计工程师：他们利用前面所讲的 Verilog 各种描述手段，设计 RTL 级的代码，精确到时钟周期。逻辑设计工程师的代码，通过综合工具的综合，可以转换为 Verilog 的门级网表，其中所有的功能块都是由基本的门单元组成的。</p>
<p>物理设计工程师：他们将这些门级网表进行布局和布线，做成实际的芯片。</p>
<p>验证工程师：他们负责对设计的电路进行验证，他们编写的代码主要是用来产生激励，这些激励大部分需要的抽象层次更高，以使仿真的效率更高。然后在工具中对电路进行仿真，检查响应结果。这些代码不会实现为具体癭件，有些并不需要精确到时钟周期，而只是在软件的仿真工具中运行，实现一定的功能即可，称这种描述层次为行为级。</p>
<p>这里的行为级描述，不同于 <a href="#03">3. 行为描述</a>中所述的“行为描述方式”。这里特指一种描述的抽象层次。</p>
<p>下面举一个实例说明 RTL 级和行为级的区别，要实现的状态机一部分如下图所示。</p>
<div align="center">
  <img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-30-josh-verilog-part-3/2020-11-30-josh-verilog-part-3-180-ASimpleHandshakingStateMachine.png!500px"/>
</div>

<p>上图中只有两个状态，当在左边的状态时，<code>REQ</code> 输出 1；当在右边的状态时，<code>REQ</code> 输出 0。<code>ACK</code> 是状态机的输人信号，决定了状态的跳转。</p>
<p>如果是让一个 RTL 设计工程师来设计，他马上就会与硬件实现的细节联系起来，很可能就会用如下代码实现：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">/************************</span></span><br><span class="line"><span class="comment">RTL 描述</span></span><br><span class="line"><span class="comment">************************/</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>] curr_sm;</span><br><span class="line"><span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>] next_sm;              <span class="comment">// 定义状态寄存器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">parameter</span> ...;</span><br><span class="line">state0 = <span class="number">2&#x27;b01</span>;</span><br><span class="line">state1 = <span class="number">2&#x27;b10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// state registers</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">posedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (rst)</span><br><span class="line">        curr_sm &lt;= ...;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        curr_sm &lt;= next_sm;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// next state logic</span></span><br><span class="line"><span class="keyword">always</span> @(curr_sm <span class="keyword">or</span> ACK) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">case</span>(curr_sm)</span><br><span class="line">        ...</span><br><span class="line">        state0: <span class="keyword">begin</span></span><br><span class="line">            REQ = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (ACK == <span class="number">1</span>)</span><br><span class="line">                next_sm = state1;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                next_sm = state0;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        state1: <span class="keyword">begin</span></span><br><span class="line">            REQ = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (ACK == <span class="number">0</span>)</span><br><span class="line">                next_sm = ...;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                next_sm = state1;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>然而，如果让一个逻辑验证工程师来设计这个状态机，他不考虑硬件实现的细节，只需要在语义上满足要求即可。甚至可以不出现状态寄存器。如下例：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">/************************</span></span><br><span class="line"><span class="comment">行为描述</span></span><br><span class="line"><span class="comment">************************/</span></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    ...</span><br><span class="line">    REQ = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">wait</span> (ACK == <span class="number">1</span>);</span><br><span class="line">    REQ = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">wait</span> (ACK == <span class="number">0</span>);</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>从上例中可以看出，逻辑验证工程师设计的方式十分简单，仅仅利用了 <code>begin ... end</code> 语句组的顺序执行特性，同时利用 <code>wait</code> 语句来实现状态的转移。这是典型的行为级设计风格，也是逻辑验证工程师们所追求的思维方式。</p>
<h2 id="5-2-RTL-级"><a href="#5-2-RTL-级" class="headerlink" title="5.2. RTL 级"></a>5.2. RTL 级</h2><p>所谓寄存器传输级（RTL级），就是描述电路的时候，只需要关注寄存器本身，以及寄存器到寄存器之间的逻辑功能，而不用关心寄存器和组合逻辑的实现细节（具体用了多少逻辑门等）。</p>
<p>随着逻辑综合工具的兴起，工程师才可以从 RTL 级进行电路设计了，而不需要像传统设计方法一样从门级电路搭起。它们的 RTL 设计代码将直接通过逻辑综合工具，综合成门级的设计网表，通常是由基本的门单元组成的。逻辑综合是 EDA 流程的重要组成部分。</p>
<p>Verilog 设计电路最常用的设计层次就是 RTL 级。在 RTL 描述时，设计者需要关注寄存器的行为，其中保存着数据；同时需要关注寄存器和寄存器之间的组合逻辑功能，是否能满足功能需求和时序需求。RTL 级模型是严格精确到时钟周期的模型。</p>
<p>后续会重点介绍 RTL 设计的方法和技巧。</p>
<blockquote>
<p>RTL 级是 HDL 语言最重要的概念之一，RTL 级是综合器最常用的设计输入层次。目前使用 FPGA/CPLD 等可编程逻辑器件时，设计输入都为 RTL 级。这是因为门级输入过于繁琐；而对于行为级和系统级设计输入，很多综合器不支持，并容易产生综合歧义。</p>
</blockquote>
<h2 id="5-3-门级"><a href="#5-3-门级" class="headerlink" title="5.3. 门级"></a>5.3. 门级</h2><p>在 Verilog 语义中，使用一些基本的门原语可以直接描述电路的门级功能。例如：</p>
<figure class="highlight verilog"><figcaption><span>HalfAdd.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> HalfAdd(X, Y, sum, C_out);                   <span class="comment">// 半加器模块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span> X;</span><br><span class="line"><span class="keyword">input</span> Y;</span><br><span class="line"><span class="keyword">output</span> sum;</span><br><span class="line"><span class="keyword">output</span> C_out;</span><br><span class="line"></span><br><span class="line"><span class="keyword">xor</span> u_xor(sum, X, Y);                               <span class="comment">// 门级原语实例</span></span><br><span class="line"><span class="keyword">and</span> u_and(C_out, X, Y);                             <span class="comment">// 门级原语实例</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span> </span><br></pre></td></tr></table></figure>
<p>其中直接调用了 <code>xor</code> 和 <code>and</code> 的两个 Verilog 门原语。</p>
<p>门级设计就是指在逻辑门一级将电路搭出来。特别是对于大设计来说，这种设计非常耗时、效率低下，同时容易出错。但是对于一些逻辑容量较小，性能和面积要求非常高的设计，有时还采用门级设计，以满足一些特殊的需求。</p>
<p>门级设计类似于软件中的汇编语言设计，非常精确，但是耗时耗力。</p>
<h2 id="5-4-晶体管级"><a href="#5-4-晶体管级" class="headerlink" title="5.4. 晶体管级"></a>5.4. 晶体管级</h2><p>逻辑门是由一个个晶体管组成的。在 Verilog 语言中，有用于直接描述 NMOS 和 PMOS 的原语。这里不过多叙述，有兴趣可查阅相关资料。</p>
<h2 id="5-5-混合描述"><a href="#5-5-混合描述" class="headerlink" title="5.5. 混合描述"></a>5.5. 混合描述</h2><p>Verilog 支持不同设计层次的混描述。</p>
<p>实际上，这些描述层次之间没有严格的界限。这里只是想将概念描述清楚，这一点对初学者非常重要。</p>
<hr>
<p>在本篇笔记中，重点介绍了 Verilog 的 3 种描述方式以及 Verilog 可以应用的设计层次。至此，大家应该能感受到 Verilog 语言是一种非常灵活、强大的硬件描述语言。</p>
]]></content>
      <categories>
        <category>Verilog</category>
        <category>Josh 的学习笔记</category>
        <category>Verilog</category>
        <category>Verilog 设计</category>
      </categories>
      <tags>
        <tag>Verilog</tag>
        <tag>HDL</tag>
        <tag>Verilog 语法</tag>
        <tag>描述方式</tag>
        <tag>谁急层次</tag>
      </tags>
  </entry>
  <entry>
    <title>Josh 的学习笔记之 Verilog（Part 4 —— RTL 概念与常用 RTL 建模）</title>
    <url>/posts/ecb88422.html</url>
    <content><![CDATA[<p>Verilog HDL 的基本功能之一是描述可综合的硬件电路。如何合理使用 Verilog HDL 描述高性能的可综合电路是 Verilog 系列学习笔记的目的，也是后续要讨论的主要问题。</p>
<p>本文介绍了 RTL 和综合的基本概念，通过常用 RTL 电路模型来对可综合的 RTL 级描述方式建立整体性的认识。力图通过范例，逐步引导初学者建立可综合 RTL 子集的概念。</p>
<h1 id="1-RTL-和综合"><a href="#1-RTL-和综合" class="headerlink" title="1. RTL 和综合"></a>1. RTL 和综合</h1><p>从<a href="https://josh-gao.top/posts/fd117896.html#5-%E8%AE%BE%E8%AE%A1%E5%B1%82%E6%AC%A1">《Part 3——描述方式和设计层次》的第 5 小节</a>可知，HDL 语言是分层次的。</p>
<div class="note default">
            <p>最常用的层次概念有系统级（System Level）或功能模块级（Functional Model Level）、行为级（BehavioraI Level）、寄存器传输级（RTL，Register Transfer Level）和门级（Gate Level）等。</p>
          </div>
<a id="more"></a>
<p>其中寄存器传输级（RTL，Register Transfer Level）指：<strong><span class="label default"> 不关注寄存器和组合逻辑的细节（如使用了多少逻辑门，逻辑门之间的连接拓扑结构等），通过描述寄存器到寄存器之间的逻辑功能描述电路的 HDL 层次</span></strong>。RTL 级是比门级更高的抽象层次，使用 RTL 级语言描述硬件电路一般比门级描述电路简单、高效得多。</p>
<p>RTL 级语言的最重要特性就是：<span class="label primary">RTL 级描述是可综合的描述层次</span>。</p>
<p>综合（Synthesize）指：<strong>将 HDL 语言、原理图等设计输人翻译成由与、或、非门等基本逻辑单元组成的门级连接（网表），并根据设计目标与要求（约束条件）优化所生成的逻辑连接，输出门级网表文件</strong>。RTL 级综合指将 RTL 级源代码翻译并优化为门级网表。</p>
<p>随着综合工具的不断智能化，使用RTL级语言描述硬件电路越来越方便。特别是在可编程逻辑器件（PLD，主要指 FPGA 和 CPLD）设计领域，最重要的代码设计层次就是 RTL 级。</p>
<h1 id="2-RTL-级的基本要素和设计步骤"><a href="#2-RTL-级的基本要素和设计步骤" class="headerlink" title="2. RTL 级的基本要素和设计步骤"></a>2. RTL 级的基本要素和设计步骤</h1><p>典型的 RTL 设计包含以下3个部分：</p>
<ol>
<li><p>时钟域描述</p>
<p> 描述设计所使用的所有时钟，时钟之间的主从与派生关系，时钟域之间的转换。</p>
</li>
<li><p>时序逻辑描述（寄存器描述）</p>
<p> 根据时钟沿的变换，描述寄存器之间的数据传输方式。</p>
</li>
<li><p>组合逻辑描述</p>
<p> 描述电平敏感信号的逻辑组合方式与逻辑功能。</p>
</li>
</ol>
<p>RTL 描述中时序逻辑和组合逻辑的连接关系和拓扑结构决定了设计的性能，如何调整时序逻辑、组合逻辑的连接关系和拓扑结构以达到最佳的性能就是后面讨论的编码风格（Coding Style）的核心。</p>
<p>工程师们设计 RTL 级代码的顺序各种各样，推荐使用如下的设计步骤：</p>
<ol>
<li><p><strong>功能定义与模块划分</strong></p>
<p> 根据系统功能的定义和模块划分准则（详见Part 5 第 4 节）划分各个功能模块。</p>
</li>
<li><p><strong>定义所有模炔的接口</strong></p>
<p> 首先清晰定义每个模块的接口，完成每个模块的信号列表。这种思路也和 Modular Design（模块化设计方法）一致，利于模块重用、调试、修改。</p>
</li>
<li><p><strong>设计的时钟域</strong></p>
<p> 根据设计的时钟复杂程度定义时钟之间的派生关系，分析设计中有哪些时钟域，是否存在异步时钟域之间的数据交换。对于 PLD 设计，还需确认全局时钟和是否使用 PLL/DLL 完成时钟的分频、倍频、移相等功能，哪些时钟使用全局资源布线，哪些时钟使用第二全局时钟资源布线。</p>
<p> 全局时钟资源的特点是：几乎没有 CIock Skew（时钟偏斜），有一定的 Clock Delay（时钟延迟），驱动能力最强；第二全局时钟的特点是：有较小的 CIock Skew，较小的 CIock DeIay，时钟驱动能力较强。</p>
</li>
<li><p><strong>考虑设计的关键路径</strong></p>
<p> 关键路径是指设计中时序要求最难以满足的路径。设计的时序要求主要体现在频率、建立时间、保持时间等时序指标上。在设计初期，设计者可以根据系统的频率要求，粗略地分析出设计的时序难点（如最高频率的路径，计数器的最低位，包含复杂组合逻辑的时序路径等），通过一些时序优化手段（如 Pipeline、Retiming、逻辑复制等，这些时序优化手段在 Part 5 第 7 节有详细介绍）<strong>从代码上缓解设计的时序压力</strong>，这种方法比单依靠综合与布局布线工具的自动优化有效得多。</p>
</li>
<li><p><strong>顶层设计</strong></p>
<p> 常用的设计方法有两种，一种是自顶而下的设计方法，即先描述设计的顶层，然后描述设计的每个子模块；另一种是由底向上的设计方法，即首先描述设计的子模块，最后定义设计的顶层。RTL 设计推荐使用自顶而下的设计方法，因为这种设计方法与模块规划的顺序一致，而且更利于进行 Modular Design（模块化设计方法），并行开展设计工作，提高模块重用率。</p>
</li>
<li><p><strong>FSM 设计</strong></p>
<p> 有限状态机（FSM）是逻辑设计的最重要内容之一。Part 6 主要讨论如何写好 FSM。</p>
</li>
<li><p><strong>时序逻辑设计</strong></p>
<p> 首先根据时钟域规划好寄存器组，然后描述各个寄存器组之间的数据传输方式。</p>
</li>
<li><p><strong>组合逻辑设计</strong></p>
<p> 一般来说，<strong>大段的组合逻辑最好与时序逻辑分开描述</strong>，这样更利于时序约束和时序分析，使综合器和布局布线器达到更好的优化效果。</p>
</li>
</ol>
<h1 id="3-常用-RTL-级建模"><a href="#3-常用-RTL-级建模" class="headerlink" title="3. 常用 RTL 级建模"></a>3. 常用 RTL 级建模</h1><h2 id="3-1-非阻塞赋值、阻塞赋值、连续赋值"><a href="#3-1-非阻塞赋值、阻塞赋值、连续赋值" class="headerlink" title="3.1. 非阻塞赋值、阻塞赋值、连续赋值"></a>3.1. 非阻塞赋值、阻塞赋值、连续赋值</h2><p>有很多文章论述阻塞赋值和非阻塞赋值的概念，<a href="https://josh-gao.top/posts/fd117896.html#3-2-%E8%BF%87%E7%A8%8B%E8%B5%8B%E5%80%BC%E8%AF%AD%E5%8F%A5">《Part 3——描述方式和设计层次》的 3.2 小节</a>详细讨论了因不当使用阻塞赋值和非阻塞赋值引起的仿真与设计意图不一致。为了避免不当使用阻塞賦值和非阻塞赋值而造成的种种歧义和错误，这里推荐：</p>
<ol>
<li><p><strong>对于时序逻辑，即 <code>always</code> 模块的敏感表为==沿敏感信号==（多为时钟或复位的正沿或负沿），统一使用非阻塞賦值 <code>&lt;=</code></strong>。例如：</p>
 <figure class="highlight verilog"><figcaption><span>// cnt1.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment">时序逻辑中使用非阻塞赋值。</span></span><br><span class="line"><span class="comment">******************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> cnt1 (clock, cnt_out);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span>        clock;</span><br><span class="line"><span class="keyword">output</span> [<span class="number">3</span>:<span class="number">0</span>] cnt_out;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] cnt_out;</span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clock)</span><br><span class="line">    cnt_out &lt;= cnt_out + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>对于 <code>always</code> 模块的敏感表为==电平敏感==信号的组合逻辑，统一使用阻塞賦值</strong>。例如：<br><span id="cnt2.v"></span></p>
 <figure class="highlight verilog"><figcaption><span>cnt2.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment">always 模块的敏感表为电平敏感信号的组合逻辑, 使用阻塞赋值。请注意, 此例</span></span><br><span class="line"><span class="comment">&quot;cnt_out_plus&quot;虽然被指定为 reg 型, 但是实现时是纯组合逻辑。</span></span><br><span class="line"><span class="comment">******************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> cnt2 (cnt_out, cnt_out_plus);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span>  [<span class="number">3</span>:<span class="number">0</span>] cnt_out;</span><br><span class="line"><span class="keyword">output</span> [<span class="number">3</span>:<span class="number">0</span>] cnt_out_plus;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] cnt_out_plus;</span><br><span class="line"><span class="keyword">always</span> @(cnt_out)</span><br><span class="line">    cnt_out_plus = cnt_out + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>对于 <code>assign</code> 关键字描述的==组合逻辑==，称为连续赋值语句，统一使用 <code>=</code>，变量被定义为 <code>wire</code> 型信号</strong>。例如：</p>
 <figure class="highlight verilog"><figcaption><span>cnt3.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment">assign 描述的组合逻辑。&quot;cnt_out_plus&quot;被定义为 wire 型信号。</span></span><br><span class="line"><span class="comment">******************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> cnt3 (cnt_out, cnt_out_plus);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span>  [<span class="number">3</span>:<span class="number">0</span>] cnt_out;</span><br><span class="line"><span class="keyword">output</span> [<span class="number">3</span>:<span class="number">0</span>] cnt_out_plus;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</span></span><br><span class="line"><span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] cnt_out_plus;</span><br><span class="line"><span class="keyword">assign</span> cnt_out_plus = cnt_out + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<div class="note danger">
            <p>在 2 和 3 中，为什么不采用类似例 1 中的 <code>cnt_out &lt;= cnt_out + 1;</code> 呢？因为，<strong>这样会产生组合逻辑环</strong>。组合逻辑环是同步时序逻辑设计的大忌，它会使得时序路径无法被工具所分析，<strong>因不同的芯片的延时差异，而造成逻辑功能不稳定</strong>。有些已经完成很久的设计，在换了芯片批次后，逻辑功能不正确，大多数都是由组合逻辑环造成的。</p>
          </div>
<p>对于初学者而言，以上几点是必须遵循的法则，详细原因可以参考<a href="https://josh-gao.top/posts/fd117896.html">《Part 3 —— 描述方式和设计层次》</a>和 Part 5 的论述。</p>
<h2 id="3-2-寄存器电路建模"><a href="#3-2-寄存器电路建模" class="headerlink" title="3.2. 寄存器电路建模"></a>3.2. 寄存器电路建模</h2><p>寄存器和组合逻辑是数字逻辑电路的两大基本要素。寄存器一般和同步时序逻辑关联，其特点为仅当时钟的沿（上升沿或下降沿）到达时，才有可能发生输出的改变。根据实现目标不同，寄存器的建模结构略有不同，需要注意如下要点：</p>
<ol>
<li><p><strong>寄存器信号声明</strong>：<strong>寄存器定义是 <code>reg</code> 型</strong>。</p>
 <div class="note info">
            <p>请注意，这个命题的反命题不一定成立。<strong>某些信号虽然被定义为 <code>reg</code> 型，但是最终综合实现结果并不是寄存器</strong>，如上述例子 <a href="#cnt2.v">cnt2.v</a> 中 <code>cnt_out_plus</code> 虽然被指定为 <code>reg</code> 型，但是实现时是纯组合逻辑。<strong>只有定义为 <code>reg</code> 型，且 <code>always</code> 的敏感表为 <code>posedge</code> 或 <code>negedge</code> 沿敏感操作时，该信号才是寄存器</strong>。在<a href="https://josh-gao.top/posts/fd2ca242.html">《Part 2 —— Verilog 语言基础》</a>和<a href="https://josh-gao.top/posts/fd117896.html">《Part 3 —— 描述方式和设计层次》</a>也有相关内容描述这个问题。</p>
          </div>
</li>
<li><p><strong>时钟输入</strong>：在每个时钟的正沿或负沿对数据进行处理。数据的正沿或负沿起作用，是在 <code>always</code> 的敏感表中通过 <code>posedge</code> 和 <code>negedge</code> 指定的。</p>
 <figure class="highlight verilog"><figcaption><span>cnt4.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment">指定寄存器的触发沿是时钟的下降沿。</span></span><br><span class="line"><span class="comment">******************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> cnt4 (clock, cnt_out);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span>        clock;</span><br><span class="line"><span class="keyword">output</span> [<span class="number">3</span>:<span class="number">0</span>] cnt_out;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] cnt_out;</span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">negedge</span> clock)</span><br><span class="line">    cnt_out &lt;= cnt_out + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>异步复位/置位</strong>：绝大多数目标器件的寄存器模型都包含异步复位/置位端。异步复位／置位是指无论时钟沿是否有效，当复位/置位信号有效沿到达时，复位/置位立即发挥功能。指定异步复位/置位时，<strong>只需在 <code>always</code> 的敏感表中加人复位/置位信号的有效沿即可</strong>。下例描述的异步复位电路是最常用的寄存器复位形式之一。</p>
 <figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment">最常用的异步复位电路, 设异步复位信号&quot;reset_&quot;是低有效信号(也即下降沿开始复位)。用户可</span></span><br><span class="line"><span class="comment">以在 begin/end 结构之间填人复杂的用户逻辑。</span></span><br><span class="line"><span class="comment">******************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// reg_counter.v</span></span><br><span class="line"><span class="keyword">module</span> reg_counter (clock, reset_, cnt_reg_s, cnt_reg_a);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span>        clock;</span><br><span class="line"><span class="keyword">input</span>        reset_;</span><br><span class="line"><span class="keyword">output</span> [<span class="number">3</span>:<span class="number">0</span>] cnt_reg_s;</span><br><span class="line"><span class="keyword">output</span> [<span class="number">3</span>:<span class="number">0</span>] cnt_reg_a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] cnt_reg_s;  <span class="comment">//asynchronous reset</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clock <span class="keyword">or</span> <span class="keyword">negedge</span> reset_)</span><br><span class="line">    <span class="keyword">if</span> (!reset_)</span><br><span class="line">        cnt_reg_s &lt;= <span class="number">4&#x27;b0000</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        cnt_reg_s [<span class="number">2</span>:<span class="number">0</span>] &lt;= cnt_reg_s [<span class="number">2</span>:<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">        cnt_reg_s [<span class="number">3</span>]   &lt;= ~cnt_reg_s [<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="comment">// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] cnt_reg_a;  <span class="comment">//synchronous reset</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clock)</span><br><span class="line">    <span class="keyword">if</span> (!reset_)</span><br><span class="line">        cnt_reg_a &lt;= <span class="number">4&#x27;b0000</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        cnt_reg_a [<span class="number">2</span>:<span class="number">0</span>] &lt;= cnt_reg_a [<span class="number">2</span>:<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">        cnt_reg_a [<span class="number">3</span>]   &lt;= ~cnt_reg_a [<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>同步复位/置位</strong>：任何寄存器都可实现同步复位/置位功能。指定同步复位/置位时，<strong><code>always</code> 的敏感表中仅有时钟沿信号</strong>，当同步复位/置位信号变化时，同步复位/置位并不立即发生，仅仅当时钟沿采到同步复位/置位的有效电平时，才会在时钟沿到达时刻进行复位/置位操作。</p>
 <figure class="highlight verilog"><figcaption><span>reg_counter.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment">常用的同步复位电路, 设异步复位信号&quot;reset_&quot;是低电平有效信号。请比较上例, 对比 always </span></span><br><span class="line"><span class="comment">的敏感表。</span></span><br><span class="line"><span class="comment">******************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> reg_counter (clock, reset_, cnt_reg_s, cnt_reg_a);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span>        clock;</span><br><span class="line"><span class="keyword">input</span>        reset_;</span><br><span class="line"><span class="keyword">output</span> [<span class="number">3</span>:<span class="number">0</span>] cnt_reg_s;</span><br><span class="line"><span class="keyword">output</span> [<span class="number">3</span>:<span class="number">0</span>] cnt_reg_a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] cnt_reg_s;  <span class="comment">//asynchronous reset</span></span><br><span class="line"><span class="keyword">always</span> @ (<span class="keyword">posedge</span> clock <span class="keyword">or</span> <span class="keyword">negedge</span> reset_)</span><br><span class="line">    <span class="keyword">if</span> (!reset_)</span><br><span class="line">        cnt_reg_s &lt;= <span class="number">4&#x27;b0000</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        cnt_reg_s [<span class="number">2</span>:<span class="number">0</span>] &lt;= cnt_reg_s [<span class="number">2</span>:<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">        cnt_reg_s [<span class="number">3</span>]   &lt;= ~cnt_reg_s [<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] cnt_reg_a;  <span class="comment">//synchronous reset</span></span><br><span class="line"><span class="keyword">always</span> @ (<span class="keyword">posedge</span> clock)</span><br><span class="line">    <span class="keyword">if</span> (!reset_)</span><br><span class="line">        cnt_reg_a &lt;= <span class="number">4&#x27;b0000</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        cnt_reg_a [<span class="number">2</span>:<span class="number">0</span>] &lt;= cnt_reg_a [<span class="number">2</span>:<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">        cnt_reg_a [<span class="number">3</span>]   &lt;= ~cnt_reg_a [<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="comment">// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>关于同步复位和异步复位的优缺点，在 <a href="#0309">3.9 小节</a> 有详细介绍。</p>
</blockquote>
</li>
<li><p><strong>同时使用时钟上升和下降沿的问题</strong>：有时因为数据采样或调整数据相位等需求，设计者会在一个 <code>always</code> 的敏感表中同时使用时钟的 <code>posedge</code> 和 <code>negedge</code>，或者在两个 <code>always</code> 的敏感表中分别使用时钟的 <code>posedge</code> 和 <code>negedge</code> 对某些寄存器电路操作。在这两种描述下，当时钟上沿或下沿到达时，该寄存器电路都会做相应的操作。<strong>这个双沿电路往往可以等同于使用了原时钟的倍频时钟的单沿操作电路</strong>。对于实现在 PLD 的设计而言，同时使用时钟的上、下沿往往是不推荐的，因为 PLD 内嵌的 PLL/DLL 和一些时钟电路往往只能对时钟的一个沿保证非常好的指标，而另个沿的抖动、偏斜、斜率等指标不见得非常优化，有时同时使用时钟的正负沿会因时钟的抖动、偏斜、占空比、斜率等问题造成一定的性能恶化。因此推荐的做法是：将原时钟通过 PLL/DLL 倍频，然后使用倍频时钟的单沿（如上升沿）进行操作。但是电路设计不可一概而论，如果必须使用时钟的双沿对同一个寄存器操作时，请设计者明确此时相当于使用了倍频时钟。</p>
 <figure class="highlight verilog"><figcaption><span>clock_edge.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment">某电路使用 50MHz 时钟双沿操作相当于使用同相位 100MHz 倍频时钟操作。</span></span><br><span class="line"><span class="comment">******************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> clock_edge (clk_50M, clk_100M, rst_, cnt1, cnt2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span>        clk_50M, clk_100M, rst_;</span><br><span class="line"><span class="keyword">output</span> [<span class="number">3</span>:<span class="number">0</span>] cnt1, cnt2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</span></span><br><span class="line"><span class="keyword">reg</span>    [<span class="number">3</span>:<span class="number">0</span>] cnt_temp1, cnt_temp2;</span><br><span class="line"><span class="keyword">wire</span>   [<span class="number">3</span>:<span class="number">0</span>] cnt1;</span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk_50M <span class="keyword">or</span> <span class="keyword">negedge</span> rst_ )</span><br><span class="line">    <span class="keyword">if</span> (!rst_)</span><br><span class="line">        cnt_temp1 &lt;= <span class="number">4&#x27;b0000</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cnt_temp1 &lt;= cnt_temp2 + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">negedge</span> clk_50M <span class="keyword">or</span> <span class="keyword">negedge</span> rst_ )</span><br><span class="line">    <span class="keyword">if</span> (!rst_)</span><br><span class="line">        cnt_temp2 &lt;= <span class="number">4&#x27;b0000</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cnt_temp2 &lt;= cnt_temp1 + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> cnt1 = (clk_50M)? cnt_temp2 : cnt_temp1;</span><br><span class="line"><span class="comment">// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span>    [<span class="number">3</span>:<span class="number">0</span>] cnt2;</span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk_100M <span class="keyword">or</span> <span class="keyword">negedge</span> rst_ )</span><br><span class="line">    <span class="keyword">if</span> (!rst_)</span><br><span class="line">        cnt2 &lt;= <span class="number">4&#x27;b0000</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cnt2 &lt;= cnt2 + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p> 这里相当于使用与 50MHz 时钟 <code>clk_50M</code> 同相位的 2 倍频时钟 <code>cIk_100M</code> 进行累加计算，等效描述如下：</p>
 <figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">reg</span>    [<span class="number">3</span>:<span class="number">0</span>] cnt2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk_100M <span class="keyword">or</span> <span class="keyword">negedge</span> rst_ )</span><br><span class="line">    <span class="keyword">if</span> (!rst_)</span><br><span class="line">        cnt2 &lt;= <span class="number">4&#x27;b0000</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cnt2 &lt;= cnt2 + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p> 以上代码综合后，对应的电路结构如<a href="#图4-1">图 4-1</a> 所示。</p>
<p> <a name="图4-1"></a></p>
 <div align="center">
   <img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-12-02-josh-verilog-part-4/2020-12-02-josh-verilog-part-4-010-RegisterCircuitModeling-01.png!900px" alt="某双沿加法电路与等价倍频时钟单沿加法电路结构示意图"/>
 </div>

<p> RTL 仿真波形如<a href="#图4-2">图 4-2</a> 所示。</p>
<p> <a name="图4-2"></a></p>
 <div align="center">
   <img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-12-02-josh-verilog-part-4/2020-12-02-josh-verilog-part-4-020-RegisterCircuitModeling-02.png!900px" alt="某双沿加法电路与等价倍频时钟单沿加法电路仿真波型图"/>
 </div>

<p> 通过这个例子可以看出 ，某些使用双沿操作的电路等价于使用倍频时钟的单沿电路，也就是说，这些电路使用了时钟的双沿触发寄存器，则相当于提高了设计频率，提高了设计要求的时序难度。对于这些电路，在附加时序约束和进行时序分析时一定要考虑充分。</p>
</li>
</ol>
<h2 id="3-3-组合逻辑建模"><a href="#3-3-组合逻辑建模" class="headerlink" title="3.3. 组合逻辑建模"></a>3.3. 组合逻辑建模</h2><p>组合逻辑是逻辑电路设计的另一重要组成部分。组合逻辑的特点是输出的变化仅仅和输入的电平相关，而与时钟沿无关。RTL 级常用组合逻辑的建模有两种：第一种是 <code>always</code> 模块的敏感表为电平敏感信号的电路；第二种是 <code>assign</code> 等关键字描述的组合逻辑电路。</p>
<ol>
<li><p><strong><code>always</code> 模块的敏感表为电平敏感信号的组合逻辑电路</strong></p>
<p> 这种形式描述组合逻辑电路应用非常广泛，如果不考虑代码的复杂性，几乎任何组合逻辑电路都可以用这种方式建模。<code>always</code> 模块的敏感表为所有判定条件和输入信号，<strong>在使用这种结构描述组合逻辑时一定要将敏感表列写完整</strong>。在 <code>always</code> 模块中可以使用 <code>if ... else</code>、<code>case</code>、<code>for</code> 循环等各种 RTL 关键字结构。下面以某组合逻辑译码电路为例，说明这种组合逻辑建模方式。如前所述，在这种组合逻辑 <code>always</code> 模块中．推荐使用阻塞赋值 <code>=</code>，虽然信号被定义为 <code>reg</code> 型，但是最终综合实现结果并不是寄存器，而是组合逻辑，定义为 <code>reg</code> 型仅是纯语法需要而已。</p>
 <figure class="highlight verilog"><figcaption><span>decode_cmb.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment">某组合逻辑译码电路。</span></span><br><span class="line"><span class="comment">******************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> decode_cmb (addr, CS, cs1, cs2, cs3, cs4);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span>  [<span class="number">7</span>:<span class="number">0</span>]      addr;         <span class="comment">// only the 2 MSB bits used</span></span><br><span class="line"><span class="keyword">input</span>             CS;           <span class="comment">// Low effect</span></span><br><span class="line"><span class="keyword">output</span> cs1, cs2, cs3, cs4;      <span class="comment">// Low effect</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</span></span><br><span class="line"><span class="keyword">reg</span>    cs1, cs2, cs3, cs4;</span><br><span class="line"><span class="keyword">parameter</span> chip1_decode = <span class="number">2&#x27;b00</span>,</span><br><span class="line">          chip2_decode = <span class="number">2&#x27;b01</span>,</span><br><span class="line">          chip3_decode = <span class="number">2&#x27;b10</span>,</span><br><span class="line">          chip4_decode = <span class="number">2&#x27;b11</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(CS <span class="keyword">or</span> addr)</span><br><span class="line">    <span class="keyword">if</span> (CS)</span><br><span class="line">        &#123;cs1, cs2, cs3, cs4&#125; = <span class="number">4&#x27;b1111</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">case</span> (addr[<span class="number">7</span>:<span class="number">6</span>])</span><br><span class="line">            chip1_decode: &#123;cs1, cs2, cs3, cs4&#125; = <span class="number">4&#x27;b0111</span>;</span><br><span class="line">            chip2_decode: &#123;cs1, cs2, cs3, cs4&#125; = <span class="number">4&#x27;b1011</span>;</span><br><span class="line">            chip3_decode: &#123;cs1, cs2, cs3, cs4&#125; = <span class="number">4&#x27;b1101</span>;</span><br><span class="line">            chip4_decode: &#123;cs1, cs2, cs3, cs4&#125; = <span class="number">4&#x27;b1110</span>;</span><br><span class="line">        <span class="keyword">endcase</span>                       </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="comment">// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p> 综合后对应的结构示意图如下<a href="#图4-3">图 4-3</a> 所示。</p>
<p> <a name="图4-3"></a></p>
 <div align="center">
   <img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-12-02-josh-verilog-part-4/2020-12-02-josh-verilog-part-4-030-CombinatorialLogictModeling.png!700px" alt="某组合逻辑译码电路的结构示意图"/>
 </div>
</li>
<li><p><code>assign</code> 等语句描述的组合逻辑电路</p>
<p> 这种形式描述组合逻辑电路适用于描述那些相对简单的组合逻辑。信号一般被定义为 <code>wire</code> 型，常用的 <code>assign</code> 结构除了直接赋值逻辑表达式外，还可以使用 <code>?</code> 语句。</p>
 <figure class="highlight verilog"><figcaption><span>decode_cmb2.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment">使用 assign 结构描述该组合逻辑译码电路。</span></span><br><span class="line"><span class="comment">******************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> decode_cmb2 (addr, CS, cs1, cs2, cs3, cs4);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span>  [<span class="number">7</span>:<span class="number">0</span>]      addr;           <span class="comment">// only the 2 MSB bits used</span></span><br><span class="line"><span class="keyword">input</span>             CS;             <span class="comment">// Low effect</span></span><br><span class="line"><span class="keyword">output</span> cs1, cs2, cs3, cs4;        <span class="comment">// Low effect</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</span></span><br><span class="line"><span class="keyword">wire</span>   cs1, cs2, cs3, cs4;</span><br><span class="line"><span class="keyword">parameter</span> chip1_decode = <span class="number">2&#x27;b00</span>,</span><br><span class="line">          chip2_decode = <span class="number">2&#x27;b01</span>,</span><br><span class="line">          chip3_decode = <span class="number">2&#x27;b10</span>,</span><br><span class="line">          chip4_decode = <span class="number">2&#x27;b11</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> cs1 = (!CS &amp;&amp; (addr[<span class="number">7</span>:<span class="number">6</span>] == chip1_decode))? <span class="number">0</span> : <span class="number">1</span> ;  </span><br><span class="line"><span class="keyword">assign</span> cs2 = (!CS &amp;&amp; (addr[<span class="number">7</span>:<span class="number">6</span>] == chip2_decode))? <span class="number">0</span> : <span class="number">1</span> ;  </span><br><span class="line"><span class="keyword">assign</span> cs3 = (!CS &amp;&amp; (addr[<span class="number">7</span>:<span class="number">6</span>] == chip3_decode))? <span class="number">0</span> : <span class="number">1</span> ;  </span><br><span class="line"><span class="keyword">assign</span> cs4 = (!CS &amp;&amp; (addr[<span class="number">7</span>:<span class="number">6</span>] == chip4_decode))? <span class="number">0</span> : <span class="number">1</span> ;  </span><br><span class="line"><span class="comment">// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p> 该描述方式实现的电路同<a href="#图4-3">图 4-3 某组合逻辑译码电路的结构示意图</a>。</p>
</li>
</ol>
<div class="note ">
            <p>可以看到，对于简单的组合逻辑使用 <code>assign</code> 和 <code>?</code> 语句比较清晰。但是如果所描述的组合逻辑过于复杂，则需要很多条 <code>assign</code> 语句或者嵌套的 <code>?</code> 语句来描述，不易解读，此时推荐使用第一种组合逻辑建模方法。</p>
          </div>
<h2 id="3-4-双线端口与三态信号建模"><a href="#3-4-双线端口与三态信号建模" class="headerlink" title="3.4. 双线端口与三态信号建模"></a>3.4. 双线端口与三态信号建模</h2><p>前面谈到所有的<strong>双向总线（既作输出又作输出的总线）应该在顶层模块定义为三态信号，禁止在顶层以外的其他子层次定义双向端口</strong>。某些早期 EDA 软件和器件支持在子模块定义双向总线，实例化三态信号，其实从理论上讲任何子模块中定义的三态信号都可以迁移到顶层来。实际上，很多流行的综合工具也是对子模块定义的三态信号综合为选择器，将子模块例化的三态信号迁移到顶层。</p>
<p>为了避免仿真和综合实现结果不一致，并便于维护，强烈建议仅在顶层定义双向总线和例化的三态信号，禁止在除顶层以外的其他层次赋值高阻态 <code>Z</code>，在顶层将双向信号分为输人信号和输出信号两种类型，然后根据需要分别传递到不同的子模块中。这样做的另一个好处是便于描述仿真激励。</p>
<p>以下介绍几种典型的双向信号和三态信号的描述方法。</p>
<ol>
<li><p>为了清晰起见，在顶层可以将一个双向总线分成输人和输出两条总线，然后分别引入子模块使用。</p>
 <figure class="highlight verilog"><figcaption><span>bibus.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment">将双向总线 data_bus 分为输人总线 data_in 和输出总线 data_in, 然后分别使用。</span></span><br><span class="line"><span class="comment">******************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> bibus (clk, rst, sel, data_bus, addr);</span><br><span class="line"><span class="keyword">input</span>       clk, rst, sel;</span><br><span class="line"><span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>] addr;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</span></span><br><span class="line"><span class="keyword">inout</span> [<span class="number">7</span>:<span class="number">0</span>] data_bus;</span><br><span class="line"><span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] data_in, data_out;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> data_in = data_bus;</span><br><span class="line"><span class="keyword">assign</span> data_bus = (sel) ? data_out : <span class="number">8&#x27;bZ</span>;</span><br><span class="line"><span class="comment">// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑</span></span><br><span class="line"></span><br><span class="line">decode decode_inst (</span><br><span class="line">    <span class="variable">.clock</span> (clk),</span><br><span class="line">    <span class="variable">.reset</span> (rst),</span><br><span class="line">    <span class="variable">.data_bus_in</span> (data_in),</span><br><span class="line">    <span class="variable">.addr_bus</span> (addr),</span><br><span class="line">    <span class="variable">.data_bus_out</span> (data_out)</span><br><span class="line">    );</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p> 简单的三态信号用 <code>assign</code> 语法描述，如上述 <code>bibus.v</code> 代码中，描述三态总线为：</p>
 <figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> data_bus = (sel) ? data_out : <span class="number">8&#x27;bZ</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果三态总线的使能关系比较复杂，不是单一信号，此时可以使用嵌套的问号表达式，或者使用语句描述（当然也可以用 <code>if ... else</code> 结构）。</p>
 <figure class="highlight verilog"><figcaption><span>complex_bibus.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment">双向总线 databus 的输出由 3 个使能信号 sel1、sel2、se13共同确定, 下述代码中中使用嵌</span></span><br><span class="line"><span class="comment">套的问号表达式描述了该三态总线的使能选择。</span></span><br><span class="line"><span class="comment">******************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> complex_bibus (clk, rst, sel1, sel2, sel3, data_bus, addr);</span><br><span class="line"><span class="keyword">input</span>       clk, rst;</span><br><span class="line"><span class="keyword">input</span>       sel1, sel2, sel3;</span><br><span class="line"><span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>] addr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] data_in;</span><br><span class="line"><span class="comment">//wire [7:0] data_out;         //use wire type</span></span><br><span class="line"><span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] decode_out;</span><br><span class="line"><span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] cnt_out;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> data_in = data_bus;</span><br><span class="line"></span><br><span class="line">decode decode_inst (</span><br><span class="line">    <span class="variable">.clock</span> (clk),</span><br><span class="line">    <span class="variable">.reset</span> (rst),</span><br><span class="line">    <span class="variable">.data_bus_in</span> (data_in),</span><br><span class="line">    <span class="variable">.addr_bus</span> (addr),</span><br><span class="line">    <span class="variable">.data_bus_out</span> (decode_out)</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">counter counter_inst (</span><br><span class="line">    <span class="variable">.clock</span> (clk),</span><br><span class="line">    <span class="variable">.reset</span> (rst),</span><br><span class="line">    <span class="variable">.data_bus_in</span> (data_in),</span><br><span class="line">    <span class="variable">.cnt_out</span> (cnt_out)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line"><span class="comment">// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</span></span><br><span class="line"><span class="keyword">inout</span> [<span class="number">7</span>:<span class="number">0</span>] data_bus;</span><br><span class="line"><span class="keyword">assign</span> data_bus = (sel1)? decode_out : ((sel2)? cnt_out : ((sel3)? <span class="number">8&#x27;b11111111</span>: </span><br><span class="line">    <span class="number">8&#x27;bZZZZZZZZ</span>));</span><br><span class="line"><span class="comment">// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p> 但是如果使能情况更复杂，就不宜再使用上述 <code>complex-bibus.v</code> 中嵌套的问号表达式了。更清晰的描述方法是 <code>case</code> 语句，</p>
</li>
<li><p>通过 <code>case</code> 语句可以清晰地罗列每种使能组合情况下的输出情况。</p>
 <figure class="highlight verilog"><figcaption><span>complex_bibus2.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment">这种描述需要使到组合逻辑的模块，此时需要引人中间变量 data_out，并定义为 reg 型，</span></span><br><span class="line"><span class="comment">******************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> complex_bibus2 (clk, rst, sel1, sel2, sel3, data_bus, addr);</span><br><span class="line"><span class="keyword">input</span>       clk, rst;</span><br><span class="line"><span class="keyword">input</span>       sel1, sel2, sel3;</span><br><span class="line"><span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>] addr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> data_in = data_bus;</span><br><span class="line"></span><br><span class="line">decode decode_inst (</span><br><span class="line">    <span class="variable">.clock</span> (clk),</span><br><span class="line">    <span class="variable">.reset</span> (rst),</span><br><span class="line">    <span class="variable">.data_bus_in</span> (data_in),</span><br><span class="line">    <span class="variable">.addr_bus</span> (addr),</span><br><span class="line">    <span class="variable">.data_bus_out</span> (decode_out)</span><br><span class="line">    );</span><br><span class="line">                    </span><br><span class="line">counter counter_inst (</span><br><span class="line">    <span class="variable">.clock</span> (clk),</span><br><span class="line">    <span class="variable">.reset</span> (rst),</span><br><span class="line">    <span class="variable">.data_bus_in</span> (data_in),</span><br><span class="line">    <span class="variable">.cnt_out</span> (cnt_out)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line"><span class="comment">// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</span></span><br><span class="line"><span class="keyword">inout</span> [<span class="number">7</span>:<span class="number">0</span>] data_bus;</span><br><span class="line"></span><br><span class="line"><span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] data_in;</span><br><span class="line"><span class="keyword">reg</span>  [<span class="number">7</span>:<span class="number">0</span>] data_out;    <span class="comment">//use reg type, but not registers</span></span><br><span class="line"><span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] decode_out;</span><br><span class="line"><span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] cnt_out;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(decode_out <span class="keyword">or</span> cnt_out <span class="keyword">or</span> sel1 <span class="keyword">or</span> sel2 <span class="keyword">or</span> sel3) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">case</span> (&#123;sel1, sel2, sel3&#125;)</span><br><span class="line">        <span class="number">3&#x27;b100</span>:  data_out = decode_out;</span><br><span class="line">        <span class="number">3&#x27;b010</span>:  data_out = cnt_out;</span><br><span class="line">        <span class="number">3&#x27;b001</span>:  data_out = <span class="number">8&#x27;b11111111</span>;</span><br><span class="line">        <span class="keyword">default</span>: data_out = <span class="number">8&#x27;bZZZZZZZZ</span>;         </span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">             </span><br><span class="line"><span class="keyword">assign</span> data_bus = data_out;                    </span><br><span class="line"><span class="comment">// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p> 请注意，虽然输出的中间变量 <code>data_out</code>，被定义为 <code>reg</code> 型，但是在物理实现时它并不是寄存器，而是纯组合逻辑。引人这个变量的原因是 <code>inout</code> 类型的信号只能被定义为 <code>wire</code> 或 <code>tri</code> 型，不能在组合逻辑的 <code>always</code> 模块中直接赋值。</p>
 <figure class="highlight verilog"><figcaption><span>counter.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment">三态实例中调用的子模块</span></span><br><span class="line"><span class="comment">******************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> counter (clock,</span><br><span class="line">                reset,</span><br><span class="line">                data_bus_in,</span><br><span class="line">                cnt_out</span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span>        clock, reset;</span><br><span class="line"><span class="keyword">input</span>  [<span class="number">7</span>:<span class="number">0</span>] data_bus_in;</span><br><span class="line"><span class="keyword">output</span> [<span class="number">7</span>:<span class="number">0</span>] cnt_out;</span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span>    [<span class="number">7</span>:<span class="number">0</span>] cnt_out;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clock <span class="keyword">or</span> <span class="keyword">posedge</span> reset)</span><br><span class="line">    <span class="keyword">if</span> (reset)</span><br><span class="line">        cnt_out &lt;= <span class="number">8&#x27;b00000000</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cnt_out &lt;= data_bus_in + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
 <figure class="highlight verilog"><figcaption><span>decode.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment">三态实例中调用的子模块</span></span><br><span class="line"><span class="comment">******************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> decode (clock, reset, data_bus_in, addr_bus, data_bus_out);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span>        clock, reset;</span><br><span class="line"><span class="keyword">input</span>  [<span class="number">7</span>:<span class="number">0</span>] data_bus_in;</span><br><span class="line"><span class="keyword">input</span>  [<span class="number">7</span>:<span class="number">0</span>] addr_bus;</span><br><span class="line"></span><br><span class="line"><span class="keyword">output</span> [<span class="number">7</span>:<span class="number">0</span>] data_bus_out;</span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span>    [<span class="number">7</span>:<span class="number">0</span>] data_bus_out;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clock <span class="keyword">or</span> <span class="keyword">posedge</span> reset)</span><br><span class="line">    <span class="keyword">if</span> (reset)</span><br><span class="line">        data_bus_out &lt;= <span class="number">8&#x27;b00000000</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">case</span> (addr_bus)</span><br><span class="line">            <span class="number">8</span>&#x27;b <span class="number">11110000</span>: data_bus_out &lt;= <span class="number">8&#x27;b00001111</span>;</span><br><span class="line">            <span class="number">8</span>&#x27;b <span class="number">00001111</span>: data_bus_out &lt;= <span class="number">8&#x27;b11110000</span>;</span><br><span class="line">            <span class="number">8</span>&#x27;b <span class="number">10100000</span>: data_bus_out &lt;= <span class="number">8&#x27;b11111111</span>;</span><br><span class="line">            <span class="keyword">default</span>:      data_bus_out &lt;= data_bus_in;</span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">                 </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="3-5-mux-建模"><a href="#3-5-mux-建模" class="headerlink" title="3.5. mux 建模"></a>3.5. mux 建模</h2><p>mux 也是一种组合逻辑电路，它的常用建模方式也有两种：对于简单的 mux，可以直接用 <code>assign</code> 和 <code>?</code> 表达式建模，对于复杂的 mux，则需要使用 <code>always</code> 和 <code>if ... else</code>、<code>case</code> 等条件判断语句建模。</p>
<ol>
<li><p><strong>简单的 mux 用 <code>?</code> 表达式建模。信号被定义为 <code>wire</code> 型，<code>?</code> 表达式的判断条件是的选择端。</strong></p>
 <figure class="highlight verilog"><figcaption><span>mux.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment">使用&quot;?&quot;表达式描述一个 2 选 1 的 mux。</span></span><br><span class="line"><span class="comment">******************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> mux (en, a, b, mux_out);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span>        en;</span><br><span class="line"><span class="keyword">input</span>        a, b;</span><br><span class="line"><span class="keyword">output</span>       mux_out;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</span></span><br><span class="line"><span class="keyword">wire</span> mux_out;</span><br><span class="line"><span class="keyword">assign</span> mux_out = (en)? a : b;</span><br><span class="line"><span class="comment">// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>复杂的 mux 用 <code>case</code> 或嵌套的 <code>if ... else</code> 建模。信号被定义为 <code>reg</code> 型，每个<code>case</code> 或 <code>if ... else</code> 的条件分支即一路 mux 的选择输出。</strong></p>
 <figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment">使用 case 描述一个 4 选 1 的 mux。</span></span><br><span class="line"><span class="comment">******************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// mux2.v</span></span><br><span class="line"><span class="keyword">module</span> mux2 (en, a, b, c, d, mux_out);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span>  [<span class="number">1</span>:<span class="number">0</span>] en;</span><br><span class="line"><span class="keyword">input</span>        a, b, c, d;</span><br><span class="line"><span class="keyword">output</span>       mux_out;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</span></span><br><span class="line"><span class="keyword">reg</span> mux_out;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(en <span class="keyword">or</span> a <span class="keyword">or</span> b <span class="keyword">or</span> c <span class="keyword">or</span> d)</span><br><span class="line">    <span class="keyword">case</span>(en)</span><br><span class="line">        <span class="number">2&#x27;b00</span>:  mux_out = a;</span><br><span class="line">        <span class="number">2&#x27;b01</span>:  mux_out = b;</span><br><span class="line">        <span class="number">2&#x27;b10</span>:  mux_out = c;</span><br><span class="line">        <span class="number">2&#x27;b11</span>:  mux_out = d;</span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="comment">// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="3-6-存储器建模"><a href="#3-6-存储器建模" class="headerlink" title="3.6. 存储器建模"></a>3.6. 存储器建模</h2><p>逻辑电路设计经常使用一些单口 RAM，双口 RAM 和 ROM 等存储器。Verilog 语法中基本的存储单元定义格式为：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">reg</span> [datawidth] MemoryName [addresswidth];</span><br></pre></td></tr></table></figure>
<p>例如，定义一个数据位宽为 8bit，地址为 63 位的 RAM8x64，则可定义为：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] RAM8x64 [<span class="number">0</span>:<span class="number">63</span>];</span><br></pre></td></tr></table></figure>
<p>在使用存储单元时，不能直接操作存储器的某地址的某位，如想取地址为 <code>32</code> 的第 2 位和高两位，但是这两种描述都是错误的。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">RAM8x64 [<span class="number">32</span>][<span class="number">2</span>]</span><br><span class="line">RAM8x64 [<span class="number">32</span>][<span class="number">6</span>:<span class="number">7</span>]</span><br></pre></td></tr></table></figure>
<p>正确的操作方法是：<strong>先将存储单元赋值给某个寄存器，然后再对该寄存器的某位进行相关操作</strong>。如下例所示。</p>
<figure class="highlight verilog"><figcaption><span>ram_basic.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment">一个简单的 8 位宽, 64 位地址 RAM 的读/写电路，读的时候，先将 RAM8x64 某地址的数据读</span></span><br><span class="line"><span class="comment">到 mem_data 寄存器，然后就可以对寄存器的任意位进行相关操作。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">******************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> ram_basic (clk, CS, WR, addr, data_in, data_out, en);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span>         clk;</span><br><span class="line"><span class="keyword">input</span>         CS;           <span class="comment">// CS = 1, RAM enable</span></span><br><span class="line"><span class="keyword">input</span>         WR;           <span class="comment">// WR =1 then WRite enable; WR = 0 then read enable</span></span><br><span class="line"><span class="keyword">input</span>         en;           <span class="comment">// data_out enable, convert the data sequency</span></span><br><span class="line"><span class="keyword">input</span>  [<span class="number">5</span>:<span class="number">0</span>]  addr;</span><br><span class="line"><span class="keyword">input</span>  [<span class="number">7</span>:<span class="number">0</span>]  data_in;</span><br><span class="line"><span class="keyword">output</span> [<span class="number">7</span>:<span class="number">0</span>]  data_out;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] RAM8x64 [<span class="number">0</span>:<span class="number">63</span>];</span><br><span class="line"><span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] mem_data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk)</span><br><span class="line">    <span class="keyword">if</span> (WR &amp;&amp; CS)           <span class="comment">// write</span></span><br><span class="line">        RAM8x64 [addr] &lt;= data_in [<span class="number">7</span>:<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (~WR &amp;&amp; CS)     <span class="comment">// read</span></span><br><span class="line">        mem_data &lt;= RAM8x64 [addr]; </span><br><span class="line">      </span><br><span class="line"><span class="keyword">assign</span> data_out = (en)? mem_data[<span class="number">7</span>:<span class="number">0</span>] : &#123;~mem_data[<span class="number">7</span>], mem_data[<span class="number">6</span>:<span class="number">0</span>]&#125;;</span><br><span class="line"><span class="comment">// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>上面讲解的仅仅是 Verilog 语法建模存储单元的一般方法。而对于 PLD 设计、由于几乎所有的 FPGA 都内嵌有 RAM 资源，则<strong>并不推荐使用 Verilog 直接建模 RAM</strong>。FPGA 内嵌的 RAM 资源大致分为两类：块RAM（BIock RAM）资源和分布式 RAM 资源（Distributed RAM，是一种基于特殊底层逻辑单元，通过查找表和触发器实现的 RAM 结构）。PLD中使用存储结构的基本方法有两大类：</p>
<ul>
<li><p>第一种方法是：通过器件商的开发平台中内嵌的 <strong>IP 生成器</strong>，在图形化界面中直接选择存储器类型（如双口 RAM、单口 RAM、ROM、分布式 RAM 等），配置存储器参数，生产相应 IP，然后在用户逻辑中直接调用该 IP 即可。这种设计方法是 PLD 设计中推荐的方法，因为器件商最了解 PLD 的底层硬件结构，通过 IP 生成器，可以自动地选择使用 PLD 内嵌的 RAM 资源，并生成存储器的粘合逻辑（glue logic），方便、高效、可靠。</p>
</li>
<li><p>第二种方法是：直接根据上面的描述用 Verilog 语言建模存储器，由综合器根据代码描述类推并优化存储器结构，调用器件内嵌的硬件存储器资源。这种方法有两个问题：第一是要清晰合理地在代码中描述存储器，有一定的设计难度；第二是最终实现结果在很大的程度上取决于综合器的类推算法，有一定的不确定性。这种方法经常使用在两个场合；第一是 PLD 本身没有块 RAM 或分布式 RAM 等专用存储单元（如 CPLD 等）；第二是用户非常熟悉综合器的类推算法，并能通过综合器的相关约束属性指定所需使用的底层硬件 RAM 资源。</p>
</li>
</ul>
<h2 id="3-7-简单的时钟分频电路"><a href="#3-7-简单的时钟分频电路" class="headerlink" title="3.7. 简单的时钟分频电路"></a>3.7. 简单的时钟分频电路</h2><p>时钟电路是 PLD 设计的核心。在 Part 5 介绍了同步时序电路的相关知识，并介绍了如何处理一些常用时钟电路设计。</p>
<p>对于 PLD 设计而言，由于大多数 PLD（特别是FPGA）都内嵌有专用 PLL/DLL 模块，通过这些内嵌的 PLL 或 DLL，可以实现灵活的分频/倍频（一般可实现小数分频倍频）、移相等调整与运算。所以这类 PLD 设计时钟电路的方法如上小节一样，都推荐使用器件商的开发平台中内嵌的 IP 生成器，在图形化界面中直接配置 PLL/DLL 的参数，生产相应的 IP，然后在用户逻辑中直接调用该IP即可。</p>
<p>这里介绍的一般时钟分频电路建模方法，适用于没有上述内嵌 PLL/DLL 时钟电路（如 CPLD、ASIC 设计等），或内嵌 PLL/DLL 资源不能满足所需时钟关系时的一些处理方法。</p>
<p>一般来说，PLD 中的<strong>主要时钟处理为分频和移相</strong>。偶数分频十分简单，只需用高速时钟做一个同小计数器，然后在相应的位抽头即可。奇数分频电路相对复杂一些。移相的基本方法是通过高速时钟调整相位，或者通过时钟反向调整相位。</p>
<ol>
<li><p><strong>偶数分频 + 相位控制</strong></p>
 <figure class="highlight verilog"><figcaption><span>clk_div_phase.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment">将一个 200kHz 时钟做 2 分频、4 分频、8 分频, 要求分频后的 3 个时钟同相, 而且与源时</span></span><br><span class="line"><span class="comment">钟近似同相。在这个设计中, 因为输人时钟速率很低, 仅有 200kHz, 而一般 PLD 内嵌的 PLL </span></span><br><span class="line"><span class="comment">的输入频率下限都在 MHz 级，所以无法使用 PLL 完成分频与相位调整要求。另外对于低速时</span></span><br><span class="line"><span class="comment">钟的分频，使用计数器既能满足时序要求，也比较节约器件资源。</span></span><br><span class="line"><span class="comment">******************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> clk_div_phase (rst, clk_200K, clk_100K, clk_50K, clk_25K);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span>        clk_200K;</span><br><span class="line"><span class="keyword">input</span>        rst;</span><br><span class="line"><span class="keyword">output</span>       clk_100K, clk_50K, clk_25K;</span><br><span class="line"><span class="keyword">wire</span>         clk_100K, clk_50K, clk_25K;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">2</span>:<span class="number">0</span>] cnt;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk_200K <span class="keyword">or</span> <span class="keyword">negedge</span> rst)</span><br><span class="line">    <span class="keyword">if</span> (!rst)</span><br><span class="line">        cnt &lt;= <span class="number">3&#x27;b000</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cnt &lt;= cnt + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> clk_100K = ~cnt [<span class="number">0</span>];</span><br><span class="line"><span class="keyword">assign</span> clk_50K  = ~cnt [<span class="number">1</span>];</span><br><span class="line"><span class="keyword">assign</span> clk_25K  = ~cnt [<span class="number">2</span>];</span><br><span class="line"><span class="comment">// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p> 这个设计的<strong>难点在于如何调整所有时钟的相位关系</strong>。本例巧妙地通过对计数器每个 bit 的反向，完成了所有分频后时钟的相位调整，保证了3个分频后时钟的相位严格同相。对硬件结构比较清晰则会发现，这 3 个派生时钟与源时钟相比有一个非常小的相位差，<strong>这个相位差是由寄存器的固有 $T_{\mathrm{co}}$（延迟）和计数器累加的组合逻辑造成的</strong>，一般来说在 PLD 中寄存器固有 $T_{\mathrm{co}}$ 的典型值为 1~2ns，而简单的加法运算的组合逻辑门延迟也约为 ns 级，这两个延迟的总和与时钟周期相比微乎其微。如果忽略这个 ns 级的延迟，则通过每个分频时钟的反向，使 3 个分频时钟与源时钟同相，也就是说这 4 个时钟有共同的上升沿。</p>
</li>
<li><p><strong>奇数分频</strong></p>
 <figure class="highlight verilog"><figcaption><span>clk_3div.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment">对源时钟做 3 分频, 要求 3 分频时钟占空比为50％。</span></span><br><span class="line"><span class="comment">******************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> clk_3div (clk, reset, clk_out);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span>       clk, reset;</span><br><span class="line"><span class="keyword">output</span>      clk_out;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>]   state;</span><br><span class="line"><span class="keyword">reg</span>         clk1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> reset)</span><br><span class="line">    <span class="keyword">if</span>(!reset)</span><br><span class="line">        state &lt;= <span class="number">2&#x27;b00</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">case</span>(state)</span><br><span class="line">            <span class="number">2&#x27;b00</span>:  state &lt;=  <span class="number">2&#x27;b01</span>;</span><br><span class="line">            <span class="number">2&#x27;b01</span>:  state &lt;=  <span class="number">2&#x27;b11</span>;</span><br><span class="line">            <span class="number">2&#x27;b11</span>:  state &lt;=  <span class="number">2&#x27;b00</span>;</span><br><span class="line">            <span class="keyword">default</span>:state &lt;=  <span class="number">2&#x27;b00</span>;</span><br><span class="line">        <span class="keyword">endcase</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">negedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> reset)</span><br><span class="line">    <span class="keyword">if</span>(!reset)</span><br><span class="line">        clk &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        clk1 &lt;= state[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> clk_out = state[<span class="number">0</span>] &amp; clk1;</span><br><span class="line"><span class="comment">// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span> </span><br></pre></td></tr></table></figure>
<p> 3 分频、5 分频等奇数分频时钟可以使用 <code>case</code> 结构或简单的状态机（FSM）描述，设计<strong>难点在于如何通过组合逻辑调整分频时钟的占空比。</strong></p>
</li>
</ol>
<h2 id="3-8-串-并转换建模"><a href="#3-8-串-并转换建模" class="headerlink" title="3.8. 串/并转换建模"></a>3.8. 串/并转换建模</h2><p>数据流串/并转换的实现方法多种多样，根据数据的排序和数量的要求，可以选用移位寄存器、RAM 等实现。对于<strong>数量比较小的设计可以采用移位寄存器</strong>完成串/并转换；对于<strong>排列顺序有规定的串/并转换，可以用 <code>case</code> 语句判断实现</strong>；对于<strong>复杂的串/并转换，还可以用状态机实现</strong>。</p>
<figure class="highlight verilog"><figcaption><span>srl2pal.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment">简单的串行到并行转换, 数据排列顺序是高位在前。</span></span><br><span class="line"><span class="comment">******************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> srl2pal (clk, rst, srl_in, pal_out);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span>        clk;</span><br><span class="line"><span class="keyword">input</span>        rst;</span><br><span class="line"><span class="keyword">input</span>        srl_in;</span><br><span class="line"><span class="keyword">output</span> [<span class="number">7</span>:<span class="number">0</span>] pal_out;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</span></span><br><span class="line"><span class="keyword">reg</span>    [<span class="number">7</span>:<span class="number">0</span>] pal_out;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst)</span><br><span class="line">    <span class="keyword">if</span> (!rst)</span><br><span class="line">        pal_out &lt;= <span class="number">8&#x27;b0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pal_out &lt;= &#123;pal_out,srl_in&#125;;</span><br><span class="line"><span class="comment">// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="3-9-同步复位和异步复位"><a href="#3-9-同步复位和异步复位" class="headerlink" title="3.9. 同步复位和异步复位"></a>3.9. 同步复位和异步复位<a name="0309"></a></h2><p>复位电路是每个数字逻辑电路的最重要组成部分之一。复位的目的有两个方面：第一是仿真的时候使电路进入初始状态或者其他预知状态；第二是对于综合实现的真实电路，通过复位使电路进入初始状态或者其他预知状态。一般来说，逻辑电路的任何一个寄存器，存储器结构和其他逻辑单元都必须要附加复位逻辑以保证电路能够从错误状态中恢复，可靠地工作。</p>
<p><strong>常用的复位信号为低电平有效信号，在应用时外部引脚接==上拉电阻==，这样能增加复位电路的抗干扰性能。</strong></p>
<p>复位方式大致分为两类：同步复位和异步复位。这两种复位方式各有优缺点，因而应用场合不同。</p>
<h3 id="3-9-1-同步复位"><a href="#3-9-1-同步复位" class="headerlink" title="3.9.1. 同步复位"></a>3.9.1. 同步复位</h3><p>所谓同步复位是指：当复位信号变化时，并<strong>不立即生效，只有当有效时钟沿采样到已变化的复位信号后，才对所有寄存器复位</strong>。同步复位的应用要点如下：</p>
<h4 id="3-9-1-1-同步复位电路建模"><a href="#3-9-1-1-同步复位电路建模" class="headerlink" title="3.9.1.1. 同步复位电路建模"></a>3.9.1.1. 同步复位电路建模</h4><ol>
<li><p>指定<strong>同步复位时，<code>always</code> 的敏感表中仅有时钟沿信号</strong>，仅仅当时钟沿采到同步复位的有效电平时，才会在时钟沿到达时刻进行复位操作。如果目标器件或可用库中的触发器本身包含同步复位端口，则在实现时可用直接调用同步复位端。然而很多目标器件（如 PLD）和 ASIC 库的触发器本身并不包含同步复位端口，则复位信号与输入信号组成某种组合逻辑（比如复位低电平有效，则复位与输人信号两者相与即可），然后输入至寄存器的输入端。为了提高复位电路的优先级，一般在电路描述时使用带有优先级的 <code>if ... else</code> 结构，复位电路在第一个 <code>if</code> 下描述，其他电路在 <code>else</code> 或 <code>else ... if</code> 分支中描述。</p>
 <figure class="highlight verilog"><figcaption><span>syn_rst.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment">同步复位电路建模。</span></span><br><span class="line"><span class="comment">******************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> syn_rst (clk, rst_, cnt1, cnt2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span>        clk;</span><br><span class="line"><span class="keyword">input</span>        rst_;</span><br><span class="line"><span class="keyword">output</span> [<span class="number">4</span>:<span class="number">0</span>] cnt1 , cnt2;</span><br><span class="line"><span class="keyword">reg</span>    [<span class="number">4</span>:<span class="number">0</span>] cnt1 , cnt2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk)</span><br><span class="line">    <span class="keyword">if</span> (!rst_) <span class="keyword">begin</span></span><br><span class="line">        cnt1 &lt;= <span class="number">4&#x27;b0</span>;</span><br><span class="line">        cnt2 &lt;= <span class="number">4&#x27;b0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (cnt1 &lt; <span class="number">2&#x27;b11</span>)</span><br><span class="line">            cnt1 &lt;= cnt1 + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cnt1 &lt;= cnt1;                </span><br><span class="line">        cnt2 &lt;= cnt1 - <span class="number">1</span>;      </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="comment">// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>很多目标器件（如 FPGA 和 CPLD）和 ASIC 库的触发器本身并不包含同步复位端口，则同步复位会被实现为如<a href="#图4-4">图 4-4</a> 所示的结构。</p>
<p> <a name="图4-4"></a></p>
 <div align="center">
   <img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-12-02-josh-verilog-part-4/2020-12-02-josh-verilog-part-4-040-SynchronousReset-01.png!600px" alt="同步复位实现结构示意图"/>
 </div>

</li>
</ol>
<h4 id="3-9-1-2-同步复位的优点"><a href="#3-9-1-2-同步复位的优点" class="headerlink" title="3.9.1.2. 同步复位的优点"></a>3.9.1.2. 同步复位的优点</h4><ul>
<li><p>同步复位利于基于周期机制的仿真器进行仿真。</p>
</li>
<li><p>使用同步复位可以设计 100% 的同步时序电路，利于时序分析，其综合结果的频率往往较高。</p>
</li>
<li><p>同步复位仅在时钟的有效沿生效，可以<strong>有效地避免因复位电路毛刺造成的亚稳态和错误</strong>。在进行复位和释放复位信号时，都是仅当时钟沿采到复位信号电平变化时才进行相关操作，如果复位信号树的组合逻辑出现了某种毛刺，此时时钟沿采样到毛刺的概率非常低，通过时钟沿采样，可以十分有效地过滤复位电路组合逻辑产生的毛刺，增强电路稳定性。</p>
<div class="note info">
            <p>同步时序电路的概念参见 Part 5 2.1 小节；亚稳态的概念参见 Part 5 2.2 小节。</p>
          </div>
</li>
</ul>
<h4 id="3-9-1-3-同步复位的缺点"><a href="#3-9-1-3-同步复位的缺点" class="headerlink" title="3.9.1.3. 同步复位的缺点"></a>3.9.1.3. 同步复位的缺点</h4><ul>
<li><p>很多目标器件（如 FPGA 和 CPLD）和 ASIC 库的触发器本身并不包含同步复位端口，使用同步复位会增加更多逻辑资源。</p>
</li>
<li><p>同步复位的最大问题在于必须保证复位信号的有效时间足够长，从而才能保证所有触发器都有效地复位。由于仅当时钟沿采样到复位信号时才会进行复位操作，所以<strong>同步复位信号的持续时间起码要大于设计的最长时钟周期</strong>，以保证所有时钟的有效沿都能采样到同步复位信号。其实仅仅保证同步复位信号的持续时间大于最慢的时钟周期还是不够的，设计中<strong>还要考虑到同步复位信号树通过所有相关组合逻辑路径的延时以及由于时钟布线产生的偏斜（skew）</strong>，只有同步复位大于时钟最大周期加上同步信号穿过的组合逻辑路径延迟加上时钟偏斜时，才能保证同步复位可靠、彻底。同步复位实现结构如下图所示，假设同步复位逻辑树组合逻辑的延时为 $\mathtt{t1}$，复位信号传播路径的最大延迟为 $\mathtt{t2}$，最慢时钟的周期为 $\mathtt{Period max}$，时钟的 skew 为 $\mathtt{(clk2 - clk1)}$，则同步复位的周期 $\mathtt{Tsyn_rst}$ 应该满足下述公式：</p>
<script type="math/tex; mode=display">
\mathtt{Tsyn\_rst > Period max + \left(clk2 - clk1 \right) + t1 + t2}</script></li>
</ul>
<p><a name="图4-5"></a></p>
<div align="center">
  <img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-12-02-josh-verilog-part-4/2020-12-02-josh-verilog-part-4-050-SynchronousReset-02.png!800px" alt="同步复位实现结构示意图"/>
</div>

<h3 id="3-9-2-异步复位"><a href="#3-9-2-异步复位" class="headerlink" title="3.9.2. 异步复位"></a>3.9.2. 异步复位</h3><h4 id="3-9-2-1-异步复位电路建模"><a href="#3-9-2-1-异步复位电路建模" class="headerlink" title="3.9.2.1. 异步复位电路建模"></a>3.9.2.1. 异步复位电路建模</h4><ol>
<li><p>指定异步复位时，只需在 <code>always</code> 的敏感表中加入复位信号的有效沿即可，当复位信号有效沿到达时，无论时钟沿是否有效，复位立即发挥功能。</p>
 <figure class="highlight verilog"><figcaption><span>asyn_rst.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment">异步复位电路建模。</span></span><br><span class="line"><span class="comment">******************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> asyn_rst (clk, rst_, cnt1, cnt2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span>        clk;</span><br><span class="line"><span class="keyword">input</span>        rst_;</span><br><span class="line"><span class="keyword">output</span> [<span class="number">4</span>:<span class="number">0</span>] cnt1 , cnt2;</span><br><span class="line"><span class="keyword">reg</span>    [<span class="number">4</span>:<span class="number">0</span>] cnt1 , cnt2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_)</span><br><span class="line">    <span class="keyword">if</span> (!rst_) <span class="keyword">begin</span></span><br><span class="line">        cnt1 &lt;= <span class="number">4&#x27;b0</span>;</span><br><span class="line">        cnt2 &lt;= <span class="number">4&#x27;b0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (cnt1 &lt; <span class="number">2&#x27;b11</span>)</span><br><span class="line">        cnt1 &lt;= cnt1 + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cnt1 &lt;= cnt1;                </span><br><span class="line">    cnt2 &lt;= cnt1 - <span class="number">1</span>;      </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="comment">// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>大多数目标器件（如 FPGA 和 CPLD）和 ASIC 库的触发器都包含异步复位端口，异步复位会被直接接到触发器的异步复位端口。同步复位实现结构如<a href="#图4-6">图 4-6</a> 所示。</p>
</li>
</ol>
<p><a name="图4-6"></a></p>
<div align="center">
  <img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-12-02-josh-verilog-part-4/2020-12-02-josh-verilog-part-4-060-AsynchronousReset-01.png!500px" alt="异步复位实现结构示意图"/>
</div>

<h4 id="3-9-2-2-异步复位的优点"><a href="#3-9-2-2-异步复位的优点" class="headerlink" title="3.9.2.2. 异步复位的优点"></a>3.9.2.2. 异步复位的优点</h4><ul>
<li><p>由于多数目标器件（如FPGA 和 CPLD）和 ASIC 库的触发器都包含异步复位端口，异步复位会节约逻辑资源。</p>
</li>
<li><p>异步复位设计简单。</p>
</li>
<li><p>对于大多数 FPGA, 都有专用的全局异步复位/置位资源（GSR, Global Set Reset），使用GSR 资源，异步复位到达所有寄存器的偏斜（skew）最小。</p>
</li>
</ul>
<h4 id="3-9-2-3-异步复位的缺点"><a href="#3-9-2-3-异步复位的缺点" class="headerlink" title="3.9.2.3. 异步复位的缺点"></a>3.9.2.3. 异步复位的缺点</h4><ul>
<li><p>异步复位的作用和释放与时钟沿没有直接关系，在异步复位生效时问题并不明显，但是当异步复位释放时，如果异步复位信号释放时间和时钟的有效沿到达时间几乎一致，则容易造成触发器输出为<strong>亚稳态</strong>，造成逻辑错误。</p>
</li>
<li><p>另外，如果异步复位逻辑树的组合逻辑产生了<strong>毛刺</strong>，则毛刺的有效沿会使触发器误复位，造成逻辑错误。</p>
</li>
</ul>
<h4 id="3-9-2-4-推荐的复位电路设计方式"><a href="#3-9-2-4-推荐的复位电路设计方式" class="headerlink" title="3.9.2.4. 推荐的复位电路设计方式"></a>3.9.2.4. 推荐的复位电路设计方式</h4><ol>
<li><p>推荐的复位电路设计方式是异步复位，同步释放。这种方式，可以有效地继承异步复位设计简单的优势，并克服异步复位的上述风险与缺陷。</p>
</li>
<li><p>在 FPGA/CPLD 等可编程逻辑器件设计中，使用异步复位，同步释放可以节约器件资源，并获得稳定可靠地复位效果，是推荐的复位设计方式。</p>
</li>
</ol>
<figure class="highlight verilog"><figcaption><span>asyn_rst_syn_release.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment">异步复位，同步释放电路建模。异步复位，同步释放的具体设计方法很多，关键是如何保证同步</span></span><br><span class="line"><span class="comment">地释放复位信号，本例举例的方法是在复位信号释放时，用系统时钟采样后再将复位信号送到寄</span></span><br><span class="line"><span class="comment">存器的异步复位端。</span></span><br><span class="line"><span class="comment">******************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> asyn_rst_syn_release(clk, rst_, cnt1, cnt2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span>        clk;</span><br><span class="line"><span class="keyword">input</span>        rst_;</span><br><span class="line"><span class="keyword">output</span> [<span class="number">4</span>:<span class="number">0</span>] cnt1 , cnt2;</span><br><span class="line"><span class="keyword">reg</span>    [<span class="number">4</span>:<span class="number">0</span>] cnt1 , cnt2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</span></span><br><span class="line"><span class="comment">// reset release circuit</span></span><br><span class="line"><span class="keyword">reg</span> reset_reg;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk)</span><br><span class="line">     reset_reg &lt;= rst_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> reset_reg)</span><br><span class="line">    <span class="keyword">if</span> (!rst_) <span class="keyword">begin</span></span><br><span class="line">        cnt1 &lt;= <span class="number">4&#x27;b0</span>;</span><br><span class="line">        cnt2 &lt;= <span class="number">4&#x27;b0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (cnt1 &lt; <span class="number">2&#x27;b11</span>)</span><br><span class="line">            cnt1 &lt;= cnt1 + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cnt1 &lt;= cnt1;                </span><br><span class="line">        cnt2 &lt;= cnt1 - <span class="number">1</span>;      </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="comment">// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>上例使用时钟<strong>将外部输入的异步复位信号寄存一个节拍</strong>后，再送到触发器异步复位端口的设计方法的另一个好处在于：做 STA（静态时序分析）分析时，时序工具会自动检查同步后的异步复位信号和时钟的到达（Recovery）/撤销（Removal）时间关系，如果因布线造成的 skew 导致该到达I撤销时间不能满足，STA工具会上报该路径，帮助设计者进一步分析问题。异步部位同步化电路如<a href="#图4-7">图 4-7</a> 所示。</p>
<p><a name="图4-7"></a></p>
<div align="center">
  <img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-12-02-josh-verilog-part-4/2020-12-02-josh-verilog-part-4-070-AsynchronousReset-02.png!500px" alt="异步复位同步化"/>
</div>

<h2 id="3-10-用-case-和-if-else-建模"><a href="#3-10-用-case-和-if-else-建模" class="headerlink" title="3.10. 用 case 和 if ... else 建模"></a>3.10. 用 <code>case</code> 和 <code>if ... else</code> 建模</h2><p>一般来说， <code>case</code> 语句是“平行”（Balance, Parallel）的结构，即每个 <code>case</code> 分支的条件判断和执行都是并行的，没有“优先级（Prior）” 。而 <code>if ... else</code>、<code>if ... else if ...</code> 语句可以建模<strong>无优先级</strong>的判断结构， <code>if ... if ... if ...</code> 结构可以建模具<strong>有优先级</strong>的判断结构。</p>
<p>一般来说，建立优先级结构（优先级树）会消耗组合逻辑资源，如果非设计需要，推荐使用 <code>case</code> 或 <code>if ... else</code> 建立无优先级的判断结构。但是某些设计中，有些信号要求先到达（如：关键使能信号、选择信号等），而有些信号需要后到达（如：慢速信号、有效时间较长的信号等），此时则需要使用 <code>if ... if ...</code> 结构建立具有优先级的判断结构。</p>
<p>目前综合工具的优化能力越来越强，大多数情况下可以将不必要的优先级树优化掉，综合结果是否具有优先级，很大的程度上取决于综合工具的类型、综合工具的版本、目标器件（目标库）的固有硬件结构。</p>
<p>为了形象地理解优先级判断结构建模的问题，下面使用几个简单的例子，分别使用业界最流行的两个综合工具 Synplify Pro 和 Precision RTL 分别综合，分析其综合结果的 RTL 视图和结构视图（初学者不用关心这两个综合工具的使用方法，而需要重点观察综合结果的 RTL 视图和结构视图，分析不同语句建模的区别）。</p>
<figure class="highlight verilog"><figcaption><span>case1.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment">casex语句建模</span></span><br><span class="line"><span class="comment">******************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> case1(a, b, c, d, sel0, sel1, sel2, sel3, z);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span> a, b, c, d;</span><br><span class="line"><span class="keyword">input</span> sel0, sel1, sel2, sel3;</span><br><span class="line"><span class="keyword">output</span> z;</span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span> z;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</span></span><br><span class="line"><span class="keyword">always</span> @(a <span class="keyword">or</span> b <span class="keyword">or</span> c <span class="keyword">or</span> d <span class="keyword">or</span> sel0, sel1, sel2, sel3) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">casex</span> (&#123;sel0, sel1, sel2, sel3&#125;)</span><br><span class="line">        <span class="number">4&#x27;b1xxx</span>: z = d;</span><br><span class="line">        <span class="number">4&#x27;bx1xx</span>: z = c;</span><br><span class="line">        <span class="number">4&#x27;bxx1x</span>: z = b;</span><br><span class="line">        <span class="number">4&#x27;bxxx1</span>: z = a;</span><br><span class="line">        <span class="keyword">default</span>: z = <span class="number">1&#x27;b0</span>;</span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<figure class="highlight verilog"><figcaption><span>single_if.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment">单if语句(if ... else if ... else if ...)建模</span></span><br><span class="line"><span class="comment">******************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> single_if(a, b, c, d, sel0, sel1, sel2, sel3, z);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span> a, b, c, d;</span><br><span class="line"><span class="keyword">input</span> sel0, sel1, sel2, sel3;</span><br><span class="line"><span class="keyword">output</span> z;</span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span> z;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</span></span><br><span class="line"><span class="keyword">always</span> @(a <span class="keyword">or</span> b <span class="keyword">or</span> c <span class="keyword">or</span> d <span class="keyword">or</span> sel0 <span class="keyword">or</span> sel1 <span class="keyword">or</span> sel2 <span class="keyword">or</span> sel3) <span class="keyword">begin</span></span><br><span class="line">    z = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (sel3)</span><br><span class="line">        z = d;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (sel2)</span><br><span class="line">        z = c;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (sel1)</span><br><span class="line">        z = b;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (sel0)</span><br><span class="line">        z = a;                                                    </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<figure class="highlight verilog"><figcaption><span>mult_if.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment">多if语句(if ... if ... if ...)建模</span></span><br><span class="line"><span class="comment">******************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> mult_if(a, b, c, d, sel0, sel1, sel2, sel3, z);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span> a, b, c, d;</span><br><span class="line"><span class="keyword">input</span> sel0, sel1, sel2, sel3;</span><br><span class="line"><span class="keyword">output</span> z;</span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span> z;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</span></span><br><span class="line"><span class="keyword">always</span> @(a <span class="keyword">or</span> b <span class="keyword">or</span> c <span class="keyword">or</span> d <span class="keyword">or</span> sel0 <span class="keyword">or</span> sel1 <span class="keyword">or</span> sel2 <span class="keyword">or</span> sel3) <span class="keyword">begin</span></span><br><span class="line">    z = <span class="number">0</span>;                <span class="comment">// must add default value</span></span><br><span class="line">    <span class="keyword">if</span> (sel0) z = a;</span><br><span class="line">    <span class="keyword">if</span> (sel1) z = b;</span><br><span class="line">    <span class="keyword">if</span> (sel2) z = c;</span><br><span class="line">    <span class="keyword">if</span> (sel3) z = d;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>上面的描述如果在 Synopsys 公司的 Design compiler 或 FPGA Compiler 等综合工具的较早版本下综合，多<code>if</code> 语句（<code>if ... if ... if ...</code>）综合结构如<a href="#图4-8">图 4-8</a> 所示，而单 <code>if</code> 语旬（<code>if ... else if ... else if ...</code>）和 <code>casex</code> 语句综合结构如<a href="#图4-9">图 4-9</a> 所示。从图中分析河以看到多if 语句建模结构带有优先级，这时最后一条 <code>if</code> 语句对应的 <code>sel3</code> 和 <code>d</code> 的优先级最高；而单 <code>if</code> 语句和 <code>casex</code> 语句建模时没有建立优先级。</p>
<p><a name="图4-8"></a></p>
<div align="center">
  <img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-12-02-josh-verilog-part-4/2020-12-02-josh-verilog-part-4-080-MultipleIf.png!800px" alt="多 if 语句 Design Compiler 综合结构视图"/>
</div>

<p><a name="图4-9"></a></p>
<div align="center">
  <img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-12-02-josh-verilog-part-4/2020-12-02-josh-verilog-part-4-090-SingleIf.png!800px" alt="单 if 语句和 casex 语句建模使用 Design Compiler 综合结构视图"/>
</div>

<p>但是由于综合工具的综合优化策略不同，即使对于相同的代码，其综合结果也不尽相同。为了加深理解，使用业界最流行的 PLD 综合工具 Synplify Pro 和 Precision RTL 对多 <code>if</code> 语句（<code>if ... if ... if ...</code>）、单 <code>if</code> 语句（<code>if ... else if ... else if ...</code>）和 <code>casex</code> 语句分别综合，其中多 <code>if</code> 语句的 Synplify Pro 综合结果对应的 RTL 视图和工艺结构视图分别如<a href="#图4-10">图 4-10</a>、<a href="#图4-11">图 4-11</a> 所示；多 <code>if</code> 语句的 Precision RTL 综合结果对应的 RTL 视图和工艺结构视图分别如<a href="#图4-12">图 4-12</a>、<a href="#图4-13">图 4-13</a> 所示。简单分析即可发现，这 3 种语句的 Synplify Pro 和 Precision RTL 综合结果基本一致，都没有明显的优先级结构。这是因为 Synplify Pro 和Precision RTL 这两种综合工具为了节约硬件资源，根据其优化算法．优化掉了冗余的优先级判断结构。</p>
<p><a name="图4-10"></a></p>
<div align="center">
  <img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-12-02-josh-verilog-part-4/2020-12-02-josh-verilog-part-4-100-MultipleIfSynplifyProRTLView.png!600px" alt="多 if 语句的 Synplify Pro 综合结果 RTL 视图"/>
</div>

<p><a name="图4-11"></a></p>
<div align="center">
  <img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-12-02-josh-verilog-part-4/2020-12-02-josh-verilog-part-4-110-MultipleIfSynplifyProTechView.png!800px" alt="多 if 语句的 Synplify Pro 综合结果工艺结构视图"/>
</div>

<p><a name="图4-12"></a></p>
<div align="center">
  <img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-12-02-josh-verilog-part-4/2020-12-02-josh-verilog-part-4-120-MultipleIfPrecisionRTLRTLView.png!800px" alt="多 if 语句的 Precision RTL 综合结果 RTL 视图"/>
</div>

<p><a name="图4-13"></a></p>
<div align="center">
  <img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-12-02-josh-verilog-part-4/2020-12-02-josh-verilog-part-4-130-MultipleIfPrecisionRTLTechView.png!800px" alt="多 if 语句的 Precision RTL 综合结果工艺结构视图"/>
</div>

<p>所以，从语法上讲，多 <code>if</code> 语句（<code>if ... if ... if ...</code>）可以建模具有优先级的条件判断结构，而单 <code>if</code> 语句（<code>if ... else if ... else if ...</code>）和 <code>case</code> 语旬用于建模不带优先级的条件判断。但是随着综合工具优化能力的不断增强，新型的综合工具，大多时候会自动优化掉优先级结构，以减少芯片面积，提高时序性能。条件结构的综合结果是否带有优先级不但取决于综合工具的类型和版本．还和目标器件或目标库有直接关系。</p>
<p>这里推荐初学者尽量使用 <code>case</code> 或单 <code>if</code> 语句（<code>if ... else if ... else if ...</code>）建模判断结构，这样不论何种综合工具， 一般情况下都不会产牛不必要的优先级结构。使用单 <code>if</code> 结构．如果没有为所有的 <code>if</code> 指定默认的输出，则会生成 Latch（锁存器），如将上例代码删除 <code>z=0</code> 这一默认输出，而改为下面的描述，则会生成 Latch。使用 Synplify Pro 综合的综合结果的RTL 视图和工艺结构视图分别如<a href="#图4-14">图 4-14</a> 、<a href="#图4-15">图 4-15</a> 所示。</p>
<figure class="highlight verilog"><figcaption><span>mult_if.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment">多if语句(if ... if ... if ...)建模, 未指定默认输出, 生成 Latch</span></span><br><span class="line"><span class="comment">******************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> mult_if(a, b, c, d, sel0, sel1, sel2, sel3, z);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span> a, b, c, d;</span><br><span class="line"><span class="keyword">input</span> sel0, sel1, sel2, sel3;</span><br><span class="line"><span class="keyword">output</span> z;</span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span> z;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</span></span><br><span class="line"><span class="keyword">always</span> @(a <span class="keyword">or</span> b <span class="keyword">or</span> c <span class="keyword">or</span> d <span class="keyword">or</span> sel0 <span class="keyword">or</span> sel1 <span class="keyword">or</span> sel2 <span class="keyword">or</span> sel3) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (sel0) z = a;</span><br><span class="line">    <span class="keyword">if</span> (sel1) z = b;</span><br><span class="line">    <span class="keyword">if</span> (sel2) z = c;</span><br><span class="line">    <span class="keyword">if</span> (sel3) z = d;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p><a name="图4-14"></a></p>
<div align="center">
  <img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-12-02-josh-verilog-part-4/2020-12-02-josh-verilog-part-4-140-MultipleIfSynplifyProRTLView.png!800px" alt="多 if 语句无默认输出时 Synplify Pro 综合结果 RTL 视图"/>
</div>

<p><a name="图4-15"></a></p>
<div align="center">
  <img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-12-02-josh-verilog-part-4/2020-12-02-josh-verilog-part-4-150-MultipleIfSynplifyProTechView.png!800px" alt="多 if 语句无默认输出时 Synplify Pro 综合结果工艺结构视图"/>
</div>

<p>如果生成的 Latch 并非设计者意愿，则会造成与设计意图的偏离甚至是错误。而使用完整的 <code>if. .. else</code> 或 <code>case</code>（全译码或加有 <code>default</code> 关键字）语句，则可以有效地避免无意之中生成的 Latch 。在<a href="https://josh-gao.top/posts/fd117896.html#3-4-%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E6%97%AC">《Part 3 —— 描述方式和设计层次》的 3.4 小节</a>也有防止产生不必要 Latch 的相关描述，可以参考。</p>
<h2 id="3-11-可综合的-Verilog-语法子集"><a href="#3-11-可综合的-Verilog-语法子集" class="headerlink" title="3.11. 可综合的 Verilog 语法子集"></a>3.11. 可综合的 Verilog 语法子集</h2><p>通过上节建模的感性认识，可以发现，在RTL 级建模时，使用的可综合的 Verilog 语法是整个 Verilog 语法的一个非常小的子集。其实可综合的 Verilog 常用的关键字非常有限，这恰恰体现了 Verilog 语言是硬件描述语言的本质。Verilog HDL 作为硬件描述语言，其本质在于把硬件电路流畅、合理地转换为语言形式，而使用较少的一些关键字就可以有效地将电路转换到可综合的RTL 语言结构。</p>
<p>常用的RTL 语法结构列举如下：</p>
<ul>
<li>模块声明：<code>module ... endmodule</code>；</li>
<li>端口声明：<code>input</code>、<code>output</code>、<code>inout</code>；</li>
<li>信号类型： <code>wire</code>、<code>reg</code>、<code>tri</code>等， <code>integer</code> 通常用于 <code>for</code> 语句中的索引；</li>
<li>参数定义： <code>parameter</code>；</li>
<li>运算操作符：各种逻辑操作、移位操作、算术操作符，请参考<a href="https://josh-gao.top/posts/fd2ca242.html#10-%E6%93%8D%E4%BD%9C%E6%95%B0%E3%80%81%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%92%8C%E8%A1%A8%E8%BE%BE%E5%BC%8F">《Part 2 —— Verilog 语言基础》的第 10 小节</a>；</li>
<li>比较判断： <code>case [default] endcase (casex/casez)</code>、<code>if ... else ...</code>；</li>
<li>连续赋值： <code>assign</code>、问号表达式；</li>
<li>always 模块：建模时序和组合逻辑（敏感表为电平或 <code>posedge</code> 或 <code>negedge</code> 的沿信号）；</li>
<li>语法分割符： <code>begin ... end</code>；</li>
<li>任务定义：<code>tast. .. end task</code>；</li>
<li>循环语句： <code>for</code>。</li>
</ul>
<p>这些关键字的语法在<a href="https://josh-gao.top/posts/fd2ca242.html">《Part 2 —— Verilog 语言基础》</a>和<a href="https://josh-gao.top/posts/fd117896.html">《Part 3 —— 描述方式和设计层次》</a>中都有详细介绍，请参考这部分内容。</p>
<h1 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h1><p>本篇笔记中首先介绍了 RTL 和综合的基本概念。然后摆脱长篇大论的理论说教模式，通过一个个具体范例，力图使初学者逐步建立起可综合 RTL 子集的概念。希望大家认真琢磨常用电路结构的建模方法，在实践中掌握 RTL 级设计的基本技巧。</p>
]]></content>
      <categories>
        <category>Verilog</category>
        <category>Josh 的学习笔记 - Verilog</category>
      </categories>
      <tags>
        <tag>Verilog</tag>
        <tag>HDL</tag>
        <tag>非阻塞赋值</tag>
        <tag>阻塞赋值</tag>
        <tag>组合逻辑</tag>
        <tag>三态</tag>
        <tag>同步复位</tag>
        <tag>异步复位</tag>
        <tag>条件语句</tag>
      </tags>
  </entry>
</search>
