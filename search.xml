<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>MATLAB 函数 —— rcosdesign</title>
    <url>/posts/5c45edfe.html</url>
    <content><![CDATA[<p><code>rcosdesign</code>：升余弦 FIR 脉冲成型滤波器设计</p>
<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><p><code>b = rcosdesign(beta,span,sps)</code><br><code>b = rcosdesign(beta,span,sps,shape)</code></p>
<a id="more"></a>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p><code>b = rcosdesign(beta,span,sps)</code> 返回系数 <code>b</code>，该系数对应于具有由 <code>beta</code> 指定的衰减因子的平方根升余弦 FIR 滤波器。滤波器有 <code>span</code> 个符号，每个符号包含 <code>sps</code> 个样本。 滤波器的阶次，也即 <code>sps * span</code> 必须是偶数。滤波器的能量为 1。<a href="#Examples-01">举例</a></p>
<p><code>b = rcosdesign(beta,span,sps,shape)</code> 根据 <code>shape</code> 返回不同的滤波器。当 <code>shape</code> 为 <code>sqrt</code> 时，将返回根升余弦滤波器；当 <code>shape</code> 为 <code>normal</code> 时，将返回升余弦 FIR 滤波器。<a href="#Examples-02">举例</a></p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><h2 id="设计根升余弦滤波器"><a href="#设计根升余弦滤波器" class="headerlink" title="设计根升余弦滤波器"></a>设计根升余弦滤波器<span id="Examples-01"></span></h2><p>将滚降系数设为 <code>0.25</code>，波器的符号数设为 <code>6</code>，每个符号 <code>4</code> 个采样点。验证 <code>sqrt</code> 是 <code>shape</code> 参数的默认值。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">h <span class="built_in">=</span> rcosdesign(<span class="number">0.25</span>,<span class="number">6</span>,<span class="number">4</span>);</span><br><span class="line">mx <span class="built_in">=</span> max(abs(h-rcosdesign(<span class="number">0.25</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="string">&#x27;sqrt&#x27;</span>)))</span><br></pre></td></tr></table></figure>
<blockquote>
<p><font face="Consolas">mx = 0</font><br></p>
</blockquote>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">fvtool(h,<span class="string">&#x27;Analysis&#x27;</span>,<span class="string">&#x27;impulse&#x27;</span>)</span><br></pre></td></tr></table></figure>
<div align="center">
  <img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-25-matlab-rcosdesign/2020-11-25-matlab-rcosdesign-010-DesignASquareRootRaisedCosineFilterExample-01.png?imageMogr2/thumbnail/!100p|watermark/2/text/QEpvc2ggR2Fv/fontsize/15/dissolve/60/gravity/southeast/dx/5/dy/5"/>
</div>

<h2 id="升余弦和根升余弦滤波器的脉冲响应"><a href="#升余弦和根升余弦滤波器的脉冲响应" class="headerlink" title="升余弦和根升余弦滤波器的脉冲响应"></a>升余弦和根升余弦滤波器的脉冲响应<span id="Examples-02"></span></h2><p>将升余弦滤波器与根升余弦滤波器进行比较。一个理想的（无限长）升余弦脉冲成型滤波器等效于两个级联的理想的根升余弦滤波器。因此，FIR 升余弦滤波器的脉冲响应应类似于与其自身卷积的根升余弦滤波器的脉冲响应。</p>
<p>设计一个衰减为 <code>0.25</code> 的升余弦滤波器。指定滤波器有 <code>4</code> 个符号，每个符号 <code>3</code> 个采样点。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">rf <span class="built_in">=</span> <span class="number">0.25</span>;</span><br><span class="line">span <span class="built_in">=</span> <span class="number">4</span>;</span><br><span class="line">sps <span class="built_in">=</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">h1 <span class="built_in">=</span> rcosdesign(rf,span,sps,<span class="string">&#x27;normal&#x27;</span>);</span><br><span class="line">fvtool(h1,<span class="string">&#x27;impulse&#x27;</span>)</span><br></pre></td></tr></table></figure>
<div align="center">
  <img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-25-matlab-rcosdesign/2020-11-25-matlab-rcosdesign-020-ImpulseResponsesOfNormalAndSquareRootRaisedCosineFiltersExample-01.png?imageMogr2/thumbnail/!100p|watermark/2/text/QEpvc2ggR2Fv/fontsize/15/dissolve/60/gravity/southeast/dx/5/dy/5"/>
</div>

<p><strong>升余弦滤波器在 <code>sps</code> 的整数倍处具有零值点</strong>。因此，它满足无码间串扰（ISI）的 Nyquist 准则。但是，根升余弦滤波器没有这样的特性：</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">h2 <span class="built_in">=</span> rcosdesign(rf,span,sps,<span class="string">&#x27;sqrt&#x27;</span>);</span><br><span class="line">fvtool(h2,<span class="string">&#x27;impulse&#x27;</span>)</span><br></pre></td></tr></table></figure>
<div align="center">
  <img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-25-matlab-rcosdesign/2020-11-25-matlab-rcosdesign-030-ImpulseResponsesOfNormalAndSquareRootRaisedCosineFiltersExample-02.png?imageMogr2/thumbnail/!100p|watermark/2/text/QEpvc2ggR2Fv/fontsize/15/dissolve/60/gravity/southeast/dx/5/dy/5"/>
</div>

<p>将根升余弦滤波器与自身进行卷积。在最大值处截断脉冲响应，使其长度与 <code>h1</code> 相同。使用最大值将响应归一化。然后，将卷积后的根升余弦滤波器与升余弦滤波器进行比较。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">h3 <span class="built_in">=</span> conv(h2,h2);</span><br><span class="line">p2 <span class="built_in">=</span> ceil(length(h3)/<span class="number">2</span>);</span><br><span class="line">m2 <span class="built_in">=</span> ceil(p2-length(h1)/<span class="number">2</span>);</span><br><span class="line">M2 <span class="built_in">=</span> floor(p2+length(h1)/<span class="number">2</span>);</span><br><span class="line">ct <span class="built_in">=</span> h3(m2:M2);</span><br><span class="line"></span><br><span class="line">stem([h1/max(abs(h1));ct/max(abs(ct))]<span class="string">&#x27;,&#x27;</span>filled<span class="string">&#x27;)</span></span><br><span class="line"><span class="string">xlabel(&#x27;</span>Samples<span class="string">&#x27;)</span></span><br><span class="line"><span class="string">ylabel(&#x27;</span>Normalized amplitude<span class="string">&#x27;)</span></span><br><span class="line"><span class="string">legend(&#x27;</span>h1<span class="string">&#x27;,&#x27;</span>h2 * h2<span class="string">&#x27;)</span></span><br></pre></td></tr></table></figure>
<div align="center">
  <img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-25-matlab-rcosdesign/2020-11-25-matlab-rcosdesign-040-ImpulseResponsesOfNormalAndSquareRootRaisedCosineFiltersExample-03.png?imageMogr2/thumbnail/!100p|watermark/2/text/QEpvc2ggR2Fv/fontsize/15/dissolve/60/gravity/southeast/dx/5/dy/5"/>
</div>

<p>卷积响应的长度是有限的，因此根升余弦滤波器与自身进行卷积得到的结果会与升余弦滤波器不一致。增加 <code>span</code> 可以在响应之间获得更紧密的一致性，并更好地符合 Nyquist 准则。</p>
<h2 id="将信号通过升余弦滤波器"><a href="#将信号通过升余弦滤波器" class="headerlink" title="将信号通过升余弦滤波器"></a>将信号通过升余弦滤波器<span id="Examples-03"></span></h2><p>本例说明如何将信号通过根升余弦滤波器。</p>
<p>指定滤波器参数。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">rolloff <span class="built_in">=</span> <span class="number">0.25</span>;     <span class="comment">% 滚降因子</span></span><br><span class="line">span <span class="built_in">=</span> <span class="number">6</span>;           <span class="comment">% 滤波器宽度（符号数）</span></span><br><span class="line">sps <span class="built_in">=</span> <span class="number">4</span>;            <span class="comment">% 每个符号的样本数</span></span><br></pre></td></tr></table></figure>
<p>生成根升余弦滤波器的系数。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">b <span class="built_in">=</span> rcosdesign(rolloff, span, sps);</span><br></pre></td></tr></table></figure>
<p>生成双极性数据向量。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">d <span class="built_in">=</span> <span class="number">2</span>*randi([<span class="number">0</span> <span class="number">1</span>], <span class="number">100</span>, <span class="number">1</span>) - <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>上采样并对数据进行滤波以实现脉冲成型。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">x <span class="built_in">=</span> upfirdn(d, b, sps);</span><br></pre></td></tr></table></figure>
<p>添加噪声。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">r <span class="built_in">=</span> x + randn(size(x))*<span class="number">0.01</span>;</span><br></pre></td></tr></table></figure>
<p>对接收到的信号进行滤波和下采样以进行匹配滤波。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">y <span class="built_in">=</span> upfirdn(r, b, <span class="number">1</span>, sps);</span><br></pre></td></tr></table></figure>
<p>有关如何使用根升余弦滤波器对信号进行插值和抽取的信息，请参见使<a href="https://ww2.mathworks.cn/help/comm/ug/interpolate-and-decimate-using-rrc-filter.html">用 RRC 滤波器进行插值和抽取</a>（Communications Toolbox）。</p>
<h1 id="输入参数"><a href="#输入参数" class="headerlink" title="输入参数"></a>输入参数</h1><h2 id="beta-滚降系数"><a href="#beta-滚降系数" class="headerlink" title="beta - 滚降系数"></a><code>beta</code> - 滚降系数</h2><p>滚降系数，指定为不大于 <code>1</code> 的<strong>实非负标量</strong>。滚降系数决定滤波器的多余带宽。滚降系数为 <code>0</code> 时为矩形滤波器（brick-wall filter），滚降因子为 <code>1</code> 时为纯升余弦滤波器。</p>
<p><strong>数据类型</strong>：<code>double</code> | <code>single</code></p>
<h2 id="span-符号数"><a href="#span-符号数" class="headerlink" title="span - 符号数"></a><code>span</code> - 符号数</h2><p>符号数，指定为<strong>正整数标量</strong>。</p>
<p><strong>数据类型</strong>：<code>double</code> | <code>single</code></p>
<h2 id="sps-每个符号的样本数"><a href="#sps-每个符号的样本数" class="headerlink" title="sps - 每个符号的样本数"></a><code>sps</code> - 每个符号的样本数</h2><p>每个符号的样本数（上采样因子），指定为<strong>正整数标量</strong>。</p>
<p><strong>数据类型</strong>：<code>double</code> | <code>single</code></p>
<h2 id="shape-升余弦滤波器的形状"><a href="#shape-升余弦滤波器的形状" class="headerlink" title="shape - 升余弦滤波器的形状"></a><code>shape</code> - 升余弦滤波器的形状</h2><p>升余弦滤波器的形状，指定为 <code>normal</code> 或 <code>sqrt</code>。</p>
<h1 id="输出参数"><a href="#输出参数" class="headerlink" title="输出参数"></a>输出参数</h1><h2 id="b-FIR-滤波器系数"><a href="#b-FIR-滤波器系数" class="headerlink" title="b - FIR 滤波器系数"></a><code>b</code> - FIR 滤波器系数</h2><p>升余弦滤波器的系数，以<strong>列向量</strong>的形式返回。</p>
<p><strong>数据类型</strong>：<code>double</code> | <code>single</code></p>
<h1 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h1><ul>
<li>如果您拥有 Communications Toolbox™ 软件的许可证，则可以执行具有流传输行为的多速率升余弦滤波。为此，请使用 System object™ 滤波器——<code>comm.RaisedCosineTransmitFilter</code> 和 <code>comm.RaisedCosineReceiveFilter</code>。</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>[1] Tranter, William H., K. Sam Shanmugan, Theodore S. Rappaport, and Kurt L. Kosbar. <em>Principles of Communication Systems Simulation with Wireless Applications.</em> Upper Saddle River, NJ: Prentice Hall, 2004.</p>
<h1 id="扩展功能"><a href="#扩展功能" class="headerlink" title="扩展功能"></a>扩展功能</h1><h2 id="C-C-代码生成"><a href="#C-C-代码生成" class="headerlink" title="C/C++ 代码生成"></a>C/C++ 代码生成</h2><blockquote>
<p>使用 MATLAB® Coder™ 生成 C 代码和 C++ 代码。</p>
<blockquote>
<p>用法说明和限制：</p>
<p>所有输入必须为常数。 如果表达式或变量的值不变，则也允许使用。</p>
</blockquote>
</blockquote>
<h1 id="另请参阅"><a href="#另请参阅" class="headerlink" title="另请参阅"></a>另请参阅</h1><p><a href="https://ww2.mathworks.cn/help/signal/ref/gaussdesign.html"><code>gaussdesign</code></a></p>
<h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p><a href="https://ww2.mathworks.cn/help/comm/ug/interpolate-and-decimate-using-rrc-filter.html">用 RRC 滤波器进行插值和抽取</a>（Communications Toolbox）</p>
<hr>
<p>在 R2013b 中推出</p>
<hr>
<p>原文参考：<a href="https://ww2.mathworks.cn/help/signal/ref/rcosdesign.html">https://ww2.mathworks.cn/help/signal/ref/rcosdesign.html</a></p>
]]></content>
      <categories>
        <category>MATLAB</category>
        <category>翻译</category>
        <category>帮助文档</category>
      </categories>
      <tags>
        <tag>MATLAB</tag>
        <tag>翻译</tag>
        <tag>成型滤波器</tag>
        <tag>滤波器</tag>
      </tags>
  </entry>
  <entry>
    <title>MATLAB 函数 —— gaussdesign</title>
    <url>/posts/a2967b00.html</url>
    <content><![CDATA[<p><code>gaussdesign</code>：高斯 FIR 脉冲成型滤波器设计</p>
<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><p><code>h = gaussdesign(bt,span,sps)</code></p>
<a id="more"></a>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p><code>h = gaussdesign(bt,span,sps)</code> 设计一个低通 FIR 高斯脉冲成型滤波器，并返回滤波器系数向量 <code>h</code>。滤波器有 <code>span</code> 个符号，每个符号包含 <code>sps</code> 个样本。滤波器的阶次，也即 <code>sps * span</code> 必须是偶数。<a href="#Examples-01">举例</a></p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><h2 id="GSM-GMSK-数字蜂窝通信系统的高斯滤波器"><a href="#GSM-GMSK-数字蜂窝通信系统的高斯滤波器" class="headerlink" title="GSM GMSK 数字蜂窝通信系统的高斯滤波器"></a>GSM GMSK 数字蜂窝通信系统的高斯滤波器<span id="Examples-01"></span></h2><p>指定用于传输比特位的调制是高斯最小频移键控（GMSK）脉冲。此脉冲的 3-dB 带宽等于比特率的 <code>0.3</code> 倍，滤波器的符号数为 <code>4</code>，每个符号 <code>8</code> 个采样点。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">bt <span class="built_in">=</span> <span class="number">0.3</span>;</span><br><span class="line">span <span class="built_in">=</span> <span class="number">4</span>;</span><br><span class="line">sps <span class="built_in">=</span> <span class="number">8</span>;</span><br><span class="line">h <span class="built_in">=</span> gaussdesign(bt,span,sps);</span><br><span class="line">fvtool(h,<span class="string">&#x27;impulse&#x27;</span>)</span><br></pre></td></tr></table></figure>
<div align="center">
  <img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-26-matlab-gaussdesign/2020-11-26-matlab-gaussdesign-010-GaussianFilterForAGSMGMSKDigitalCellularCommunicationSysExample-01.png?imageMogr2/thumbnail/!100p|watermark/2/text/QEpvc2ggR2Fv/fontsize/15/dissolve/60/gravity/southeast/dx/5/dy/5"/>
</div>

<h1 id="输入参数"><a href="#输入参数" class="headerlink" title="输入参数"></a>输入参数</h1><h2 id="bt-3-dB带宽符号时间积"><a href="#bt-3-dB带宽符号时间积" class="headerlink" title="bt - 3-dB带宽符号时间积"></a><code>bt</code> - 3-dB带宽符号时间积</h2><p>3-dB 单边带带宽（以 Hz 为单位）和符号时间（以秒为单位）的乘积，指定为<strong>正实标量</strong>。较小的 <code>bt</code> 值会产生较大的脉冲宽度。</p>
<p><strong>数据类型</strong>：<code>double</code> | <code>single</code></p>
<h2 id="span-符号数"><a href="#span-符号数" class="headerlink" title="span - 符号数"></a><code>span</code> - 符号数</h2><p>符号数，指定为<strong>正整数标量</strong>（默认为 3）。</p>
<p><strong>数据类型</strong>：<code>double</code> | <code>single</code></p>
<h2 id="sps-每个符号的样本数"><a href="#sps-每个符号的样本数" class="headerlink" title="sps - 每个符号的样本数"></a><code>sps</code> - 每个符号的样本数</h2><p>每个符号周期的样本数（上采样因子），指定为<strong>正整数标量</strong>（默认为 2）。</p>
<p><strong>数据类型</strong>：<code>double</code> | <code>single</code></p>
<h1 id="输出参数"><a href="#输出参数" class="headerlink" title="输出参数"></a>输出参数</h1><h2 id="h-FIR-滤波器系数"><a href="#h-FIR-滤波器系数" class="headerlink" title="h - FIR 滤波器系数"></a><code>h</code> - FIR 滤波器系数</h2><p>高斯脉冲成型滤波器的 FIR 系数，以<strong>行向量</strong>的形式返回。系数已被归一化，因此标称通带增益始终为 1。</p>
<p><strong>数据类型</strong>：<code>double</code> | <code>single</code></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>[1] Krishnapura, N., S. Pavan, C. Mathiazhagan, and B. Ramamurthi. “A baseband pulse shaping filter for Gaussian minimum shift keying.” <em>Proceedings of the 1998 IEEE International Symposium on Circuits and Systems</em>. Vol. 1, 1998, pp. 249–252.</p>
<p>[2] Rappaport, Theodore S. <em>Wireless Communications: Principles and Practice.</em> 2nd Ed. Upper Saddle River, NJ: Prentice Hall, 2002.</p>
<h1 id="另请参阅"><a href="#另请参阅" class="headerlink" title="另请参阅"></a>另请参阅</h1><p><a href="https://ww2.mathworks.cn/help/signal/ref/rcosdesign.html"><code>rcosdesign</code></a></p>
<hr>
<p>在 R2013b 中推出</p>
<hr>
<p>原文参考：<a href="https://ww2.mathworks.cn/help/signal/ref/gaussdesign.html">https://ww2.mathworks.cn/help/signal/ref/gaussdesign.html</a></p>
]]></content>
      <categories>
        <category>MATLAB</category>
        <category>翻译</category>
        <category>帮助文档</category>
      </categories>
      <tags>
        <tag>MATLAB</tag>
        <tag>翻译</tag>
        <tag>成型滤波器</tag>
        <tag>滤波器</tag>
      </tags>
  </entry>
  <entry>
    <title>MATLAB 函数 —— upsample（Signal Processing Toolbox）</title>
    <url>/posts/3a606c9c.html</url>
    <content><![CDATA[<p><code>upsample</code>：将采样率提高整数倍</p>
<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><p><code>y = upsample(x,n)</code><br><code>y = upsample(x,n,phase)</code></p>
<a id="more"></a>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p><code>y = upsample(x,n)</code> 通过在样本之间插入 <code>n - 1</code>个零来增加 <code>x</code> 的采样率。如果 <code>x</code> 是矩阵，则该函数将每一列视为单独的序列。<a href="#Examples-01">举例</a></p>
<p><code>y = upsample(x,n,phase)</code> 指定未采样序列所偏移的样本数。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><h2 id="提高采样率"><a href="#提高采样率" class="headerlink" title="提高采样率"></a>提高采样率<span id="Examples-01"></span></h2><p>将序列的采样率提高 <code>3</code> 倍。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">x <span class="built_in">=</span> [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>];</span><br><span class="line">y <span class="built_in">=</span> upsample(x,<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">y &#x3D; 1×12</span><br><span class="line"></span><br><span class="line">    1     0     0     2     0     0     3     0     0     4     0     0</span><br></pre></td></tr></table></figure>
<p>将序列的采样率增加 <code>3</code> 倍，并将相位偏移增加 <code>2</code>。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">x <span class="built_in">=</span> [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>];</span><br><span class="line">y <span class="built_in">=</span> upsample(x,<span class="number">3</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">y &#x3D; 1×12</span><br><span class="line"></span><br><span class="line">    0     0     1     0     0     2     0     0     3     0     0     4     0</span><br></pre></td></tr></table></figure>
<p>将矩阵的采样率提高3倍。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">x <span class="built_in">=</span> [<span class="number">1</span> <span class="number">2</span>;</span><br><span class="line">     <span class="number">3</span> <span class="number">4</span>;</span><br><span class="line">     <span class="number">5</span> <span class="number">6</span>];</span><br><span class="line">y <span class="built_in">=</span> upsample(x,<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">y &#x3D; 9×2</span><br><span class="line"></span><br><span class="line">    1     2</span><br><span class="line">    0     0</span><br><span class="line">    0     0</span><br><span class="line">    3     4</span><br><span class="line">    0     0</span><br><span class="line">    0     0</span><br><span class="line">    5     6</span><br><span class="line">    0     0</span><br><span class="line">    0     0</span><br></pre></td></tr></table></figure>
<h1 id="输入参数"><a href="#输入参数" class="headerlink" title="输入参数"></a>输入参数</h1><h2 id="x-输入数组"><a href="#x-输入数组" class="headerlink" title="x - 输入数组"></a><code>x</code> - 输入数组</h2><p>输入数组，指定为<strong>向量</strong>或<strong>矩阵</strong>。如果 <code>x</code> 是矩阵，该函数会将不同列向量视为独立的通道。</p>
<p><strong>举例</strong>：<code>cos(pi/4*(0:159)) + randn(1,160)</code> 指定加有高斯白噪声的正弦曲线。</p>
<p><strong>举例</strong>：<code>cos(pi./[4;2]*(0:159))&#39; + randn(160,2)</code> 指定一个两通道的正弦波。</p>
<h2 id="n-上采样因子"><a href="#n-上采样因子" class="headerlink" title="n - 上采样因子"></a><code>n</code> - 上采样因子</h2><p>上采样因子，指定为<strong>正整数</strong>。</p>
<p><strong>数据类型</strong>：<code>single</code> | <code>double</code></p>
<h2 id="phase-偏移量"><a href="#phase-偏移量" class="headerlink" title="phase - 偏移量"></a><code>phase</code> - 偏移量</h2><p>偏移量，指定为从 <code>0</code> 到 <code>n - 1</code> 的<strong>正整数</strong>。默认为 <code>0</code>。</p>
<p><strong>数据类型</strong>：<code>single</code> | <code>double</code></p>
<h1 id="输出参数"><a href="#输出参数" class="headerlink" title="输出参数"></a>输出参数</h1><h2 id="y-上采样数组"><a href="#y-上采样数组" class="headerlink" title="y - 上采样数组"></a><code>y</code> - 上采样数组</h2><p>上采样数组，以<strong>向量</strong>或<strong>矩阵</strong>的形式返回。<code>y</code> 有 <code>x × n</code> 个样本。</p>
<h1 id="扩展功能"><a href="#扩展功能" class="headerlink" title="扩展功能"></a>扩展功能</h1><h2 id="C-C-代码生成"><a href="#C-C-代码生成" class="headerlink" title="C/C++ 代码生成"></a>C/C++ 代码生成</h2><blockquote>
<p>使用 MATLAB® Coder™ 生成 C 代码和 C++ 代码。</p>
</blockquote>
<h1 id="另请参阅"><a href="#另请参阅" class="headerlink" title="另请参阅"></a>另请参阅</h1><p><a href="https://ww2.mathworks.cn/help/signal/ref/decimate.html"><code>decimate</code></a> | <a href="https://ww2.mathworks.cn/help/signal/ref/downsample.html"><code>downsample</code></a> | <a href="https://ww2.mathworks.cn/help/signal/ref/interp.html"><code>interp</code></a> | <a href="https://ww2.mathworks.cn/help/matlab/ref/interp1.html"><code>interp1</code></a> | <a href="https://ww2.mathworks.cn/help/signal/ref/resample.html"><code>resample</code></a> | <a href="https://ww2.mathworks.cn/help/matlab/ref/spline.html"><code>spline</code></a> | <a href="https://ww2.mathworks.cn/help/signal/ref/upfirdn.html"><code>upfirdn</code></a></p>
<hr>
<p>在 R2006a 之前推出</p>
<hr>
<p>原文参考：<a href="https://ww2.mathworks.cn/help/signal/ref/upsample.html">https://ww2.mathworks.cn/help/signal/ref/upsample.html</a></p>
]]></content>
      <categories>
        <category>MATLAB</category>
        <category>翻译</category>
        <category>帮助文档</category>
      </categories>
      <tags>
        <tag>MATLAB</tag>
        <tag>翻译</tag>
        <tag>上采样</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo NexT 主题不蒜子相关问题汇总</title>
    <url>/posts/e96c9b26.html</url>
    <content><![CDATA[<h1 id="什么是不蒜子"><a href="#什么是不蒜子" class="headerlink" title="什么是不蒜子"></a>什么是不蒜子</h1><p><a href="https://busuanzi.ibruce.info/">不蒜子</a>是 <a href="http://ibruce.info/">Bruce</a> 开发的一款轻量级的网页计数器，可以将网站访问计数直接显示在网页上。</p>
<h1 id="启用不蒜子"><a href="#启用不蒜子" class="headerlink" title="启用不蒜子"></a>启用不蒜子</h1><p>NexT 预置了不蒜子提供的网页计数功能。只需要在配置文件中启用即可。</p>
<figure class="highlight yaml"><figcaption><span>next/_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># Show Views / Visitors of the website / page with busuanzi.</span></span><br><span class="line"><span class="comment"># Get more information on http://ibruce.info/2015/04/04/busuanzi</span></span><br><span class="line"><span class="attr">busuanzi_count:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span>                          <span class="comment"># 启用不蒜子</span></span><br><span class="line">  <span class="attr">total_visitors:</span> <span class="literal">true</span>                  <span class="comment"># 网站总访客数</span></span><br><span class="line">  <span class="attr">total_visitors_icon:</span> <span class="string">fa</span> <span class="string">fa-user</span></span><br><span class="line">  <span class="attr">total_views:</span> <span class="literal">true</span>                     <span class="comment"># 网站总浏览数</span></span><br><span class="line">  <span class="attr">total_views_icon:</span> <span class="string">fa</span> <span class="string">fa-eye</span></span><br><span class="line">  <span class="attr">post_views:</span> <span class="literal">true</span>                      <span class="comment"># 文章浏览数</span></span><br><span class="line">  <span class="attr">post_views_icon:</span> <span class="string">fa</span> <span class="string">fa-eye</span></span><br></pre></td></tr></table></figure>
<h1 id="不蒜子和-Live2D-冲突的问题"><a href="#不蒜子和-Live2D-冲突的问题" class="headerlink" title="不蒜子和 Live2D 冲突的问题"></a>不蒜子和 Live2D 冲突的问题</h1><a id="more"></a>
<blockquote>
<p>Hexo 版本：5.2.0<br>NexT 版本：8.0.2<br>不蒜子版本: 2.3</p>
</blockquote>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>添加 Live2D 前的不蒜子显示情况如下。</p>
<div align="center">
  <img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-27-hexo-next-busuanzi-issues/2020-11-27-hexo-next-busuanzi-issues-010-Live2D-01.png?imageMogr2/thumbnail/!100p|watermark/2/text/QEpvc2ggR2Fv/fontsize/15/dissolve/60/gravity/southeast/dx/5/dy/5"/>
</div>

<div align="center">
  <img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-27-hexo-next-busuanzi-issues/2020-11-27-hexo-next-busuanzi-issues-020-Live2D-02.png?imageMogr2/thumbnail/!100p|watermark/2/text/QEpvc2ggR2Fv/fontsize/15/dissolve/60/gravity/southeast/dx/5/dy/5"/>
</div>

<p>添加 Live2D 后，不蒜子在页面中不显示。</p>
<div align="center">
  <img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-27-hexo-next-busuanzi-issues/2020-11-27-hexo-next-busuanzi-issues-030-Live2D-03.png?imageMogr2/thumbnail/!100p|watermark/2/text/QEpvc2ggR2Fv/fontsize/15/dissolve/60/gravity/southeast/dx/5/dy/5"/>
</div>

<div align="center">
  <img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-27-hexo-next-busuanzi-issues/2020-11-27-hexo-next-busuanzi-issues-040-Live2D-04.png?imageMogr2/thumbnail/!100p|watermark/2/text/QEpvc2ggR2Fv/fontsize/15/dissolve/60/gravity/southeast/dx/5/dy/5"/>
</div>

<h2 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h2><p>经查，添加 Live2D 后网页的不蒜子部分源码的 <code>style</code> 从 <code>&quot;display: inline;&quot;</code> 替换为了 <code>&quot;display: none;&quot;</code>。</p>
<figure class="highlight html"><figcaption><span>不蒜子不正常显示的网页源码</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item&quot;</span> <span class="attr">title</span>=<span class="string">&quot;阅读次数&quot;</span> <span class="attr">id</span>=<span class="string">&quot;busuanzi_container_page_pv&quot;</span> <span class="attr">style</span>=<span class="string">&quot;display: none;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item-icon&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fa fa-eye&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item-text&quot;</span>&gt;</span> 阅读次数：<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;busuanzi_value_page_pv&quot;</span>&gt;</span>19<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight html"><figcaption><span>不蒜子正常显示的网页源码</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item&quot;</span> <span class="attr">title</span>=<span class="string">&quot;阅读次数&quot;</span> <span class="attr">id</span>=<span class="string">&quot;busuanzi_container_page_pv&quot;</span> <span class="attr">style</span>=<span class="string">&quot;display: inline;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item-icon&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fa fa-eye&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item-text&quot;</span>&gt;</span> 阅读次数：<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;busuanzi_value_page_pv&quot;</span>&gt;</span>18<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>在网页生成引擎中修改代码，去掉不蒜子部分的 <code>id</code> 和 <code>style</code> 属性，重新生成网页即可解决该问题。若将 <code>class</code> 属性一并删除，会导不蒜子部分和前面的其他显示部分缺少分隔符，如下图。</p>
<div align="center">
  <img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-27-hexo-next-busuanzi-issues/2020-11-27-hexo-next-busuanzi-issues-050-Delimeter-01.png?imageMogr2/thumbnail/!100p|watermark/2/text/QEpvc2ggR2Fv/fontsize/15/dissolve/60/gravity/southeast/dx/5/dy/5"/>
</div>

<p>具体需要修改两个文件，<code>next/layout/_third-party/statistics/busuanzi-counter.swig</code> 中修改的是网页页脚部分的不蒜子显示，<code>next/layout/_macro/post.swig</code> 中修改的博客文章阅览数的不蒜子显示。</p>
<figure class="highlight html"><figcaption><span>next/layout/_third-party/statistics/busuanzi-counter.swig</span></figcaption><table><tr><td class="code"><pre><span class="line">&#123;%- if theme.busuanzi_count.total_visitors %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item&quot;</span> <span class="attr">id</span>=<span class="string">&quot;busuanzi_container_site_uv&quot;</span> <span class="attr">style</span>=<span class="string">&quot;display: none;&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">&#123;%- endif %&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line"></span><br><span class="line">&#123;%- if theme.busuanzi_count.total_views %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item&quot;</span> <span class="attr">id</span>=<span class="string">&quot;busuanzi_container_site_pv&quot;</span> <span class="attr">style</span>=<span class="string">&quot;display: none;&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">&#123;%- endif %&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><figcaption><span>next/layout/_macro/post.swig</span></figcaption><table><tr><td class="code"><pre><span class="line">&#123;%- if not is_index and theme.busuanzi_count.enable and theme.busuanzi_count.post_views %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item&quot;</span> <span class="attr">title</span>=<span class="string">&quot;&#123;&#123; __(&#x27;post.views&#x27;) &#125;&#125;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;busuanzi_container_page_pv&quot;</span> <span class="attr">style</span>=<span class="string">&quot;display: none;&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">&#123;%- endif %&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Blog</category>
        <category>Hexo</category>
        <category>Next</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title>Josh 的学习笔记之 Verilog（Part 1 —— 初识 HDL 设计方法）</title>
    <url>/posts/460433dd.html</url>
    <content><![CDATA[<p>本文阐述了 HDL 语言/设计方法的基本概念。主要介绍了数字系统建模方法的演变，引入了 HDL 语言的基本概念，对 Verilog HDL 和 VHDL、Verilog HDL 和 C 的联系与区别进行了说明，在最后引入了 HDL 的设计和验证流程，并对各个流程进行了简单介绍。</p>
<h1 id="1-设计方法的变迁"><a href="#1-设计方法的变迁" class="headerlink" title="1. 设计方法的变迁"></a>1. 设计方法的变迁<a name="01"></a></h1><p>随着微电子设计技术与工艺的发展，数字集成电路从电子管、晶体管、中小规模集成电路、超大规模集成电路（Very Large Scale Integrated Circuit, VLSIC）逐步发展到今天的专用集成电路（Application Specific Integrated Circuit, ASIC），愈发数字化的产品如计算机、手机、数字电视等都运用了复杂的专用数字集成电路。数字逻辑器件从简单的逻辑门到复杂的 SoC，种类繁多，提供了对复杂系统的灵活支撑。</p>
<a id="more"></a>
<p>随着数字电路系统的不断发展，系统的逻辑复杂度与规模日益增加，数字系统的设计方法也随之不断演进。早期简单的门逻辑设计阶段，EDA 工具应用范围十分有限，工程师们习惯于使用<strong>卡诺图</strong>简化设计，然后通过面包板等实验系统验证设计；系统相对复杂后，工程师们借助 EDA 工具通过原理图描述数字系统。</p>
<blockquote>
<p>原理图由元件库中的元件构成，使用 EDA（Electronic Design Automation，电子设计自动化）工具可以对原理图进行仿真并分析其性能。</p>
</blockquote>
<p>当数字系统发展到 ASIC 与 PLD（Programmable Logic Device，可编程逻辑器件） 设计阶段后，原理图不利于移植、维护费时费力等缺点逐步显现，这时需要抽象度更高、更灵活的设计方式 —— HDL（Hardware Description Language，硬件描述语言）。</p>
<p>使用 HDL 语言，可以从算法、系统级（System Level）、功能模块级（Functional Model Level）、行为级（Behavioral Level）、寄存器传输级（RTL, Register Transfer Level）、门级（Gate Level）到开关级（Switch Level）等不同层次描述数字电路系统，然后通过 EDA 工具综合、仿真并实现该系统。可以说 HDL 语言的出现是数字系统设计方法的一个重大飞跃。</p>
<p>数字电路系统设计方法的另一个重大飞跃是随着 EDA 工具的不断推陈出新发生的。早期 ASIC 和 PLD 设计时，人们需要直接描述 CMOS 的开关电路或门级电路，其设计量庞大，仿真速度也非常慢，像当今系统门数量为千万门级的 FPGA 用开关级或门级方法描述在当时是不可想象的。这时人们就希望能够使用 HDL 直接从更高的层次描述电路，然后使用 EDA 工具自动将高层次的 HDL 电路描述解析到门级，这些将大大节约设计与仿真时间，这个<strong>从高层次的电路描述通过 EDA 工具解析到门级等低层次的电路描述的过程就叫“综合”（Synthesize），或者逻辑综合</strong>。</p>
<p>综合工具能将高层次的 HDL 语言、原理图等设计描述翻译成由与、或、非门等基本逻辑单元组成的门级连接（<strong>网表</strong>）并根据设计目标与要求（约束条件）优化所生成的逻辑连接，输出门级网表文件。</p>
<p>目前最成熟的综合工具是 RTL 级综合工具，它能将 RTL 级描述翻译并优化为门级网表。综合工具的产生支撑了直接从 RTL 级描述硬件电路，这种从门级描述抽象到 RTL 级描述数字电路是设计方法的又一次伟大飞跃。</p>
<p>从上面描述可以看到 HDL 语言是分层次的，关于上述 HDL 语言设计层次的含义在 <a href="#03">3. HDL 的设计与验证流程</a>小节和 <a href="https://josh-gao.blog.csdn.net/article/details/105262549#5__1023">《Part 3——描述方式和设计层次》的 5. 设计层次</a>小节有详细论述。)</p>
<h1 id="2-Verilog-语言的特点"><a href="#2-Verilog-语言的特点" class="headerlink" title="2. Verilog 语言的特点"></a>2. Verilog 语言的特点<a name="02"></a></h1><h2 id="2-1-Verilog-的由来"><a href="#2-1-Verilog-的由来" class="headerlink" title="2.1. Verilog 的由来"></a>2.1. Verilog 的由来</h2><p>Verilog 是 Verilog HDL 的简称。</p>
<blockquote>
<p>Verilog 语言最初于1983年由 Gateway Design Automation 公司开发，于1995年接受为 IEEE 标准。</p>
</blockquote>
<p>Verilog 语言不仅定义了语法，而且对每个语法结构都清晰定义了仿真语义，从而便于仿真调试。而且 Verilog 从 C 语言继承了很多操作符和语法结构，对初学者而言易学易用。另外 Verilog 语言具有很强的扩展能力，最新的 Verilog 2001 标准<sup><a href="#fn_1" id="reffn_1">1</a></sup>大大扩展了 Verilog 的应用灵活性。</p>
<p>另外一个流行的 HDL 语言是 VHDL，其发展初期受到美国国防部支持，并于 1987 年成为 IEEE 标准。VHDL 语言的特点是描述严谨。</p>
<h2 id="2-2-Verilog-和-VHDL"><a href="#2-2-Verilog-和-VHDL" class="headerlink" title="2.2. Verilog 和 VHDL"></a>2.2. Verilog 和 VHDL</h2><p>Verilog 和 VHDL 作为最为流行的 HDL 语言，从设计能力上而言都能胜任数字电路系统的设计任务。</p>
<p>VHDL 最初用作文档来描述数字硬件的行为，因此其<strong>描述性和抽象层次更高</strong>。也就是说，VHDL 更适合描述更高层次（如行为级、系统级等）的硬件电路。</p>
<p>Verilog 最初是为了更简洁有效地描述数字硬件电路和仿真而设计的，它的许多关键字与语法集成了 C 语言的体系，因此易学易懂，接受度很广。</p>
<p>前面已经提到最流行的 HDL 语言是 Verilog 和 VHDL。在其基础上发展出了许多抽象程度更高的硬件描述语言，如 SystemVerilog、Superlog、SystemC、CoWare C，这些高级 HDL 语言的语法结枃更加丰富，更适合做系统级、功能级等高层次的设计描述和仿真。</p>
<h2 id="2-3-Verilog-和-C"><a href="#2-3-Verilog-和-C" class="headerlink" title="2.3. Verilog 和 C"></a>2.3. Verilog 和 C</h2><p>Verilog 语言是根据 C 语言发明而来的，因此 Verilog 具备了 C 语言的简洁易用的特点。Verilog 从 C 语言中借鉴了许多语法，例如预编译指令和一些高级编程语言结构。</p>
<ol>
<li><p>C 语言与 Verilog 的最大区别</p>
<p> C 语言与 Verilog 的最大区别在于 C 缺乏硬件描述的 3 个基本概念：</p>
<ul>
<li><p><strong>互连（connectivity）</strong>：硬件系统中，互连是非常重要的组成部分，而在 C 语言中并没有直接可以用来表示模块间互连的变量；而 Verilog 的 <code>wire</code> 型变量配合一些驱动结构能有效地描述网线的互连。</p>
</li>
<li><p><strong>并发（concurrency）</strong>：C 语言天生是<strong>串行</strong>的，不能描述硬件之间并发的特性，C 语言编译后，其机器指令在 CPU 的高速缓冲队列中基本是顺序执行；而 Verilog 可以有效地描述并行的硬件系统，硬件系统比软件系统速度快、实时性高的一个重要原因就是硬件系统中<strong>各个单元的运算是独立的，信号流是并行的</strong>。</p>
</li>
<li><p><strong>时间（time）</strong>：C 程序运行的时候，没有一个严格的时间概念，程序运行的时间长短取决于处理器本身的性能；而 Verilog 语言本身定义了绝对和相对的时间度量，在仿真时可以通过时间度量与周期关系描述信号直接的时间关系。</p>
</li>
</ul>
</li>
<li><p>HDL 语言的本质</p>
<p> 硬件描述语言（HDL）同软件语言（如 C、C++ 等）是有本质区别的。Verilog 作为硬件描述语言，<strong>它的本质作用在于描述硬件</strong>。Verilog 虽然采用了 C 语言形式，但是它的最终描述结果是芯片内部的实际电路。所以评判一段 HDL 代码优劣的最终标准是其描述并实现的硬件电路的性能（包括面积和速度两个方面）。评价一个设计的代码水平较高，仅仅是说这个设计由硬件向 HDL 代码这种表现形式转换得更流畅、合理。而一个设计的最终性能更大程度上取决于设计工程师所构想的硬件实现方案的效率以及合理性。</p>
<blockquote>
<p>初学者，特别是由软件转行的初学者，片面追求代码的整洁、简短，这是错误的，是与评价 HDL 的标准背道而驰的。正确的编写代码的方法是，首先要做到对所需实现的硬件电路“胸有成竹”，对该部分硬件的结构与连接十分清晰，然后再用适当的 HDL 语句表达出来即可。</p>
</blockquote>
</li>
<li><p>Verilog 与 C 的结合</p>
<p> Verilog 毕竟是硬件描述语言，在抽象层次上比 C 语言要差一些，语法不如 C 灵活，例如文件输入和输出方面，Verilog 的功能显然不如 C。为了克服 Verilog 高级抽象的缺陷，Verilog 的设计者们发明了 PLI。PLI 可以在仿真器中将 C 语言的程序和 Verilog 的程序互相通信，或者在 Verilog 中调用 C 语言的函数库，这样就大大扩展了 Verilog 语言的灵活性和高层次抽象的能力。开发时，一方面，硬件设计者使用 Verilog 进行硬件建模；另一方面，验证工程师却常常使用 C 来编写测试向量，然后通过 Verilog 的 PLI 将 Verilog 和 C 联系起来。这样，C 语言就很好地弥补了 Verilog 高层次建模的缺陷。</p>
</li>
</ol>
<h1 id="3-HDL-的设计与验证流程"><a href="#3-HDL-的设计与验证流程" class="headerlink" title="3. HDL 的设计与验证流程"></a>3. HDL 的设计与验证流程<a name="03"></a></h1><p>HDL 的基本功能就是有效地描述并仿真硬件系统。在此部分，抛开具体的 PLD 或 ASIC 设计流程，从 HDL 语言层次入手，分析典型的 HDL 设计与验证流程。基于 HDL 的设计、仿真流程如下图所示。图中，虚线框表示的步骤可以根据项目的复杂度省略，而实线框表示的步骤为必须执行的步骤。</p>
<div align="center">
  <img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-27-josh-verilog-part-1/2020-11-27-josh-verilog-part-1-010-DesignSimulationFlowChartBasedonHDL.png?imageMogr2/thumbnail/!35p|watermark/2/text/QEpvc2ggR2Fv/fontsize/15/dissolve/60/gravity/southeast/dx/5/dy/5"/>
</div>

<p>下面对一些关键设计步骤与概念进行展开。</p>
<h2 id="3-1-系统与功能模块定义（系统与功能模块级）"><a href="#3-1-系统与功能模块定义（系统与功能模块级）" class="headerlink" title="3.1. 系统与功能模块定义（系统与功能模块级）"></a>3.1. 系统与功能模块定义（系统与功能模块级）</h2><p>在大型系统的设计与实现中，首先要进行详细的系统规划和描述，此时 HDL 描述<strong>侧重于整体系统的划分和实现</strong>。对系统级的仿真侧重于对整个系统的功能和性能指标的考量。功能模块级设计时将系统整体功能划分为可实现的具体功能模块，大致确定模块间的接口，如时钟、读写信号、数据流、控制信号等。在有些情况下，还要根据系统要求，描述每个模块或进程的时序约束。另外在此层次，必须权衡整个系统多种的实现方式的优劣，选出系统性能指标优并且可以高效实现的设计方案。功能模块级仿真主要是考察每个功能的功能和基本时序情况。系统与功能模块级设计与仿真常常要借助于 C 语言和抽象程度较高的 HDL 语言描述，如 SystemC、Coware C、SystemVerilog、Superlog 等。</p>
<h2 id="3-2-行为级描述测试激励（Behavioral-Level）"><a href="#3-2-行为级描述测试激励（Behavioral-Level）" class="headerlink" title="3.2. 行为级描述测试激励（Behavioral Level）"></a>3.2. 行为级描述测试激励（Behavioral Level）</h2><p>行为级模块描述的最大特点是<strong>必须明确每个模块间的所有接口和边界</strong>。此时模块内部的功能已经明确，模块间的所有接口，顶层的输入、输出信号等在行为级已经被清晰地描述出来。在 PLD 和 ASIC 设计流程中，常用行为级描述方式编写测试激励。延时描述、监视描述等命令都是在编写测试激励过程中常用的行为级语法。行为级描述常用 HDL 语言如 Verilog 和 VHDL 等。</p>
<h2 id="3-3-寄存器传输级（RTL）"><a href="#3-3-寄存器传输级（RTL）" class="headerlink" title="3.3. 寄存器传输级（RTL）"></a>3.3. 寄存器传输级（RTL）</h2><p>寄存器传输级指不关注寄存器和组合逻辑的细节（如使用了多少逻辑门，逻辑门之间的连接拓扑结构等），<strong>通过描述寄存器到寄存器之间的逻辑功能描述电路</strong>的 HDL 层次。RTL 级是比门级更高的抽象层次，一般使用 RTL 级语言描述硬件电路比门级描述电路简单、高效得多。寄存器传输级描述的最大特点是可以直接用综合工具综合门级网表。RTL 设计直接决定着设计的功能和效率。好的 RTL 设计能在满足逻辑功能的前提下，使设计的速度和面积达到一种平衡的优化。RTL 级描述最常用的 HDL 语言是 Verilog 和 VHDL 语言。</p>
<h2 id="3-4-对-RTL-级描述进行功能仿真"><a href="#3-4-对-RTL-级描述进行功能仿真" class="headerlink" title="3.4 对 RTL 级描述进行功能仿真"></a>3.4 对 RTL 级描述进行功能仿真</h2><p>一般来说需要对 RTL 级设计进行功能仿真，仿真的目的为<strong>验证 RTL 级描述是否与设计意图一致</strong>。为了提高效率，一般功能仿真的测试激励使用行为级的 HDL 语言描述。</p>
<h2 id="3-5-逻辑综合（使用-RTL-级-EDA-工具）"><a href="#3-5-逻辑综合（使用-RTL-级-EDA-工具）" class="headerlink" title="3.5. 逻辑综合（使用 RTL 级 EDA 工具）"></a>3.5. 逻辑综合（使用 RTL 级 EDA 工具）</h2><p>RTL 级综合指<strong>将 RTL 级 HDL 语言翻译成由与、或、非门等基本逻辑单元组成的门级连接（网表），并根据设计目标与要求（约束条件）优化所生成的逻辑连接，输出门级网表文件</strong>。随着综合工具的不断智能化，使用 RTL 级语言描述硬件电路越来越方便，特别是在 PLD（主要指 FPGA 和 CPLD）设计领域，最重要的代码设计层次就是 RTL 级。</p>
<h2 id="3-6-门级（Gate-Level）"><a href="#3-6-门级（Gate-Level）" class="headerlink" title="3.6. 门级（Gate Level）"></a>3.6. 门级（Gate Level）</h2><p>由于目前 FPGA 设计大多数依靠专业综合工具完成从 RTL 级代码向门级代码的转换，所有设计者直接用 HDL 语言描述门级模型的情况越来越少，高效的综合工具将设计者从复杂繁琐的门级描述中彻底解脱出来。目前直接使用门级描述的场合一般是 ASIC 和 FPGA 设计中<strong>某些面积或时序要求较高的模块</strong>。门级描述的特点是整个设计用逻辑门实现，通过逻辑门的组合显化描述了设计的引脚、功能、时钟周期等所有信息。</p>
<h2 id="3-7-综合后门级仿真"><a href="#3-7-综合后门级仿真" class="headerlink" title="3.7. 综合后门级仿真"></a>3.7. 综合后门级仿真</h2><p>综合完成后，如果需要检查综合结果是否与原设计一致，就需要做综合后仿真。在仿真时，把综合生成的标准延时文件反标注到综合仿真模型中去，可估计门延时带来的影响。综合后仿真虽然比功能仿真精确一些，但是<strong>只能估计门延时，不能估计线延时</strong>，仿真结果<strong>与布线后的实际情况还有一定的差距</strong>，并不十分准确。这种仿真的主要目的在于<strong>检查综合器的综合结果是否与设计输入一致</strong>。目前主流综合工具日益成熟，对于一般性设计，如果设计者确信自己表述明确，没有综合歧义发生，则可以省略综合后仿真步骤。<strong>一般情况下，综合后仿真与功能仿真的仿真激励相同</strong>。</p>
<h2 id="3-8-布局规划与布局布线"><a href="#3-8-布局规划与布局布线" class="headerlink" title="3.8. 布局规划与布局布线"></a>3.8. 布局规划与布局布线</h2><p>综合的门级结果最终要映射到目标库（如 ASIC 设计）或目标器件（如 PLD 设计）。ASIC 与 PLD 设计的相关流程在此不深究 。</p>
<h2 id="3-9-布局布线后时序仿真与验证"><a href="#3-9-布局布线后时序仿真与验证" class="headerlink" title="3.9. 布局布线后时序仿真与验证"></a>3.9. 布局布线后时序仿真与验证</h2><p>将最终布局规划或布局布线的时延信息反标注到设计网表中，所进行的仿真就叫时序仿真或布局规划与布局布线后仿真，简称后仿真。布局规划与布局布线之后生成的仿真时延文件包含的时延信息最全，不仅包含门延时，还包含实际布线延时，所以时序仿真最准确，能较好地反映芯片的实际工作情况。一般来说，建议进行时序仿真步骤，通过时序仿真能检查设计时序与芯片实际运行情况是否一致，确保设计的可靠性和稳定性。时序仿真的主要目的在于发现时序违规（Timing Violation），即不满足时序约束条件或者器件固有时序规则（建立时间、保持时间等）的情况。</p>
<blockquote id="fn_1">
<sup>1</sup>. 最新的 Verilog HDL标准为 1364-2005。<a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a>
</blockquote>
]]></content>
      <categories>
        <category>Verilog</category>
        <category>Verilog 简介</category>
        <category>Josh 的学习笔记</category>
        <category>Verilog</category>
      </categories>
      <tags>
        <tag>Verilog</tag>
        <tag>HDL</tag>
        <tag>硬件描述语言</tag>
        <tag>行为级</tag>
        <tag>RTL</tag>
        <tag>寄存器传输级</tag>
      </tags>
  </entry>
  <entry>
    <title>MATLAB 函数 —— awgn</title>
    <url>/posts/2f6db45b.html</url>
    <content><![CDATA[<p><code>awgn</code>：在信号中添加高斯白斯噪声</p>
<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><p><code>out = awgn(in,snr)</code><br><code>out = awgn(in,snr,signalpower)</code></p>
<p><code>out = awgn(in,snr,signalpower,randobject)</code><br><code>out = awgn(in,snr,signalpower,seed)</code><br><code>out = awgn(___,powertype)</code></p>
<a id="more"></a>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p><code>out = awgn(in,snr)</code> 将高斯白噪声添加到矢量信号 <code>in</code> 中。此条语句假定 <code>in</code> 的功率为 0 dBW。</p>
<p><code>out = awgn(in,snr,signalpower)</code> 接受以 dBW 为单位的输入信号功率值。要使该函数在添加噪声之前测量 <code>in</code> 的功率，请将 <code>signalpower</code> 指定为 <code>measured</code>。<a href="#Examples-01">举例</a></p>
<p><code>out = awgn(in,snr,signalpower,randobject)</code> 接受满足前述两条语法，外加随机数流对象的输入组合以生成满足正态分布的随机噪声样本。有关产生可重复噪声样本的信息，请参见<a href="#tips">提示</a>。<a href="#Examples-03">举例</a></p>
<p><code>out = awgn(in,snr,signalpower,seed)</code> 指定用于初始化正态随机数生成器的种子值，该种子在添加高斯白噪声到输入信号时使用。有关产生可重复噪声样本的信息，请参见<a href="#tips">提示</a>。</p>
<p><code>out = awgn(___,powertype)</code> 除了前面任何语法中的输入自变量之外，还将可信号和噪声功率类型指定为 <code>dB</code> 或 <code>linear</code>。</p>
<p>有关 SNR 与噪声相对功率的其他度量（例如 $E_\mathrm{S}/N_0$ 和 $E_\mathrm{b}/N_0$）之间的关系，请参阅 <a href="https://ww2.mathworks.cn/help/comm/ug/awgn-channel.html#a1071501088">AWGN 信道噪声级别</a>。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><h2 id="将-AWGN-添加到锯齿波"><a href="#将-AWGN-添加到锯齿波" class="headerlink" title="将 AWGN 添加到锯齿波"></a>将 AWGN 添加到锯齿波<span id="Examples-01"></span></h2><p>创建一个锯齿波。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">t <span class="built_in">=</span> (<span class="number">0</span>:<span class="number">0.1</span>:<span class="number">10</span>)<span class="string">&#x27;;</span></span><br><span class="line"><span class="string">x = sawtooth(t);</span></span><br></pre></td></tr></table></figure>
<p>添加高斯白噪声并绘制结果。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">y <span class="built_in">=</span> awgn(x,<span class="number">10</span>,<span class="string">&#x27;measured&#x27;</span>);</span><br><span class="line">plot(t,[x y])</span><br><span class="line">legend(<span class="string">&#x27;Original Signal&#x27;</span>,<span class="string">&#x27;Signal with AWGN&#x27;</span>)</span><br></pre></td></tr></table></figure>
<div align="center">
  <img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-27-matlab-awgn/2020-11-27-matlab-awgn-010-AddAWGNToSawtoothSignalExample-01.png?imageMogr2/thumbnail/!100p|watermark/2/text/QEpvc2ggR2Fv/fontsize/15/dissolve/60/gravity/southeast/dx/5/dy/5"/>
</div>

<h2 id="AWGN-信道中的常规-QAM-调制"><a href="#AWGN-信道中的常规-QAM-调制" class="headerlink" title="AWGN 信道中的常规 QAM 调制"></a>AWGN 信道中的常规 QAM 调制<span id="Examples-02"></span></h2><p>在存在高斯噪声的情况下，使用非矩形 16 元星座发送和接收数据。绘制噪声星座图，并针对两种不同的信噪比估算误符号率（SER）。</p>
<p>根据电话线调制解调器的 V.29 标准创建一个 16-QAM 星座。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">c <span class="built_in">=</span> [-<span class="number">5</span> -<span class="number">5</span>i <span class="number">5</span> <span class="number">5</span>i -<span class="number">3</span> -<span class="number">3</span>-<span class="number">3</span>i -<span class="number">3</span>i <span class="number">3</span>-<span class="number">3</span>i <span class="number">3</span> <span class="number">3</span>+<span class="number">3</span>i <span class="number">3</span>i -<span class="number">3</span>+<span class="number">3</span>i -<span class="number">1</span> -<span class="number">1</span>i <span class="number">1</span> <span class="number">1</span>i];</span><br><span class="line">M <span class="built_in">=</span> length(c);</span><br></pre></td></tr></table></figure>
<p>生成随机符号。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">data <span class="built_in">=</span> randi([<span class="number">0</span> M-<span class="number">1</span>],<span class="number">2000</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>使用 <code>genqammod</code> 函数调制数据。由于星座图不是矩形，因此必须进行常规 QAM 调制。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">modData <span class="built_in">=</span> genqammod(data,c);</span><br></pre></td></tr></table></figure>
<p>使信号通过具有 20 dB 信噪比（SNR）的 AWGN 信道。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">rxSig <span class="built_in">=</span> awgn(modData,<span class="number">20</span>,<span class="string">&#x27;measured&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>显示接收信号的星座图和参考星座图。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">h <span class="built_in">=</span> scatterplot(rxSig);</span><br><span class="line">hold on</span><br><span class="line">scatterplot(c,[],[],<span class="string">&#x27;r*&#x27;</span>,h)</span><br><span class="line">grid</span><br><span class="line">hold off</span><br></pre></td></tr></table></figure>
<div align="center">
  <img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-27-matlab-awgn/2020-11-27-matlab-awgn-020-GeneralQAMModulationInAnAWGNChannelExample-01.png?imageMogr2/thumbnail/!100p|watermark/2/text/QEpvc2ggR2Fv/fontsize/15/dissolve/60/gravity/southeast/dx/5/dy/5"/>
</div>

<p>使用 <code>genqamdemod</code> 函数解调接收到的信号。计算误符号数和误符号率。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">demodData <span class="built_in">=</span> genqamdemod(rxSig,c);</span><br><span class="line">[numErrors,ser] <span class="built_in">=</span> symerr(data,demodData)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">numErrors &#x3D; 1</span><br><span class="line">ser &#x3D; 5.0000e-04</span><br></pre></td></tr></table></figure>
<p>使用具有 10 dB SNR 的 AWGN 信道重复传输和解调过程。计算降低 SNR 后的误符号率。不出所料，当 SNR 降低时，性能会下降。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">rxSig <span class="built_in">=</span> awgn(modData,<span class="number">10</span>,<span class="string">&#x27;measured&#x27;</span>);</span><br><span class="line">demodData <span class="built_in">=</span> genqamdemod(rxSig,c);</span><br><span class="line">[numErrors,ser] <span class="built_in">=</span> symerr(data,demodData)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">numErrors &#x3D; 462</span><br><span class="line">ser &#x3D; 0.2310</span><br></pre></td></tr></table></figure>
<h2 id="用-RandStream-产生可重复的-AWGN"><a href="#用-RandStream-产生可重复的-AWGN" class="headerlink" title="用 RandStream 产生可重复的 AWGN"></a>用 RandStream 产生可重复的 AWGN<span id="Examples-03"></span></h2><p>使用 <a href="https://ww2.mathworks.cn/help/matlab/ref/randstream.html"><code>RandStream</code></a> 和 <a href="https://ww2.mathworks.cn/help/matlab/ref/randstream.reset.html"><code>reset</code></a> 对象函数生成高斯白噪声相加的结果。</p>
<p>将 X 的功率指定为 0 dBW，添加噪声以产生 10 dB 的 SNR，并利用本地随机流。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">S <span class="built_in">=</span> RandStream(<span class="string">&#x27;mt19937ar&#x27;</span>,<span class="string">&#x27;Seed&#x27;</span>,<span class="number">5489</span>);</span><br><span class="line">sigin <span class="built_in">=</span> sqrt(<span class="number">2</span>)*sin(<span class="number">0</span>:pi/<span class="number">8</span>:<span class="number">6</span>*pi);</span><br><span class="line">sigout1 <span class="built_in">=</span> awgn(sigin,<span class="number">10</span>,<span class="number">0</span>,S);</span><br></pre></td></tr></table></figure>
<p>将 AWGN 添加到 <code>sigin</code>。 使用 <a href="https://ww2.mathworks.cn/help/matlab/ref/isequal.html"><code>isequal</code></a> 比较 <code>sigout1</code> 和 <code>sigout2</code>。 当不重置随机流时，输出不相等。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">sigout2 <span class="built_in">=</span> awgn(sigin,<span class="number">10</span>,<span class="number">0</span>,S);</span><br><span class="line">isequal(sigout1,sigout2)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ans &#x3D; logical</span><br><span class="line">   0</span><br></pre></td></tr></table></figure>
<p>重置随机流对象，将对象置为初始状态，然后再将 AWGN 添加到 <code>sigout1</code>。将 AWGN 添加到 <code>sigin</code> 并将 <code>sigout1</code> 与 <code>sigout3</code> 比较。 重置随机流后，输出相等。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">reset(S);</span><br><span class="line">sigout3 <span class="built_in">=</span> awgn(sigin,<span class="number">10</span>,<span class="number">0</span>,S);</span><br><span class="line">isequal(sigout1,sigout3)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ans &#x3D; logical</span><br><span class="line">   1</span><br></pre></td></tr></table></figure>
<h1 id="输入参数"><a href="#输入参数" class="headerlink" title="输入参数"></a>输入参数</h1><h2 id="in-输入信号"><a href="#in-输入信号" class="headerlink" title="in - 输入信号"></a><code>in</code> - 输入信号</h2><p>输入信号，指定为<strong>标量</strong>，<strong>向量</strong>或<strong>数组</strong>。假定输入信号的功率为0 dBW。</p>
<p><strong>数据类型</strong>：<code>double</code><br><strong>复数支持</strong>：是</p>
<h2 id="snr-信噪比（SNR）"><a href="#snr-信噪比（SNR）" class="headerlink" title="snr - 信噪比（SNR）"></a><code>snr</code> - 信噪比（SNR）</h2><p>信噪比（以 dB 为单位），指定为<strong>标量</strong>。</p>
<div class="note info">
            <p>注意：</p><p>加上噪声后，此函数会将相同的 <code>snr</code> 应用于完整输入信号的所有元素。阵列输入信号没有独立通道的概念。 要独立考虑多个频道，请参阅 <a href="https://ww2.mathworks.cn/help/comm/ref/comm.awgnchannel-system-object.html"><code>comm.AWGNChannel</code></a>。</p>
          </div>
<p><strong>数据类型</strong>：<code>double</code></p>
<h2 id="signalpower-信号功率"><a href="#signalpower-信号功率" class="headerlink" title="signalpower - 信号功率"></a><code>signalpower</code> - 信号功率</h2><p>信号功率，指定为<strong>标量</strong>或 <code>measured</code>。</p>
<ul>
<li><p>当 <code>signalpower</code> 为标量时，该值用作 <code>in</code> 的信号电平，以便根据 <code>snr</code> 的值确定适当的噪声电平。</p>
</li>
<li><p>当 <code>signalpower</code> 为 <code>measured</code> 时，将计算 <code>in</code> 的信号电平，以根据 <code>snr</code> 的值确定适当的噪声电平。</p>
</li>
</ul>
<div class="note info">
            <p>注意：</p><p>当指定 <code>measured</code> 时，此函数将使用完整输入信号的所有元素来计算信号功率。在计算功率时，阵列输入信号没有独立通道的概念。</p>
          </div>
<p><strong>数据类型</strong>：<code>double</code></p>
<h2 id="randobject-随机数流对象"><a href="#randobject-随机数流对象" class="headerlink" title="randobject - 随机数流对象"></a><code>randobject</code> - 随机数流对象</h2><p>随机数流对象，指定为 <a href="https://ww2.mathworks.cn/help/matlab/ref/randstream.html"><code>RandStream</code></a> 对象。 随机流对象的状态确定 <a href="https://ww2.mathworks.cn/help/matlab/ref/randn.html"><code>randn</code></a> 函数产生的数字序列。使用 <a href="https://ww2.mathworks.cn/help/matlab/ref/randstream.reset.html"><code>reset (RandStream)</code></a> 函数及其属性来配置随机流对象。</p>
<p><code>wgn</code> 使用 <a href="https://ww2.mathworks.cn/help/matlab/ref/randn.html"><code>randn</code></a> 生成正常的随机噪声样本。<a href="https://ww2.mathworks.cn/help/matlab/ref/randn.html"><code>randn</code></a> 函数使用 <a href="https://ww2.mathworks.cn/help/matlab/ref/randstream.html"><code>RandStream</code></a> 对象中的一个或多个统一值来生成每个正态值。</p>
<p>有关产生可重复噪声样本的信息，请参见<a href="#tips">提示</a>。</p>
<h2 id="seed-随机数生成器种子"><a href="#seed-随机数生成器种子" class="headerlink" title="seed - 随机数生成器种子"></a><code>seed</code> - 随机数生成器种子</h2><p>随机数生成器种子，指定为<strong>标量</strong>。</p>
<h2 id="powertype-信号功率单元"><a href="#powertype-信号功率单元" class="headerlink" title="powertype - 信号功率单元"></a><code>powertype</code> - 信号功率单元</h2><p>信号功率单元，指定为 <code>dB</code> 或 <code>linear</code>。默认为 <code>dB</code>。</p>
<ul>
<li><p>当功率类型为 <code>dB</code> 时，以 dB 为单位测量 snr，以 dBW 为单位测量信号功率。</p>
</li>
<li><p>当功率类型为 <code>linear</code> 时，<code>snr</code> 以比率进行测量，<code>signalpower</code> 以瓦特为单位。</p>
</li>
</ul>
<p>有关 SNR 与噪声相对功率的其他度量（例如 $E_\mathrm{S}/N_0$ 和 $E_\mathrm{b}/N_0$）之间的关系，请参阅 <a href="https://ww2.mathworks.cn/help/comm/ug/awgn-channel.html#a1071501088">AWGN 信道噪声级别</a>。</p>
<h1 id="输出参数"><a href="#输出参数" class="headerlink" title="输出参数"></a>输出参数</h1><h2 id="out-输出信号"><a href="#out-输出信号" class="headerlink" title="out  - 输出信号"></a><code>out</code>  - 输出信号</h2><p>输出信号，以<strong>标量</strong>，<strong>向量</strong>或<strong>数组</strong>形式返回。 返回的输出信号是添加了高斯白噪声的输入信号。</p>
<h1 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示<span id="tips"></span></h1><ul>
<li><p>要生成可重复的高斯白噪声样本，请使用以下技巧之一：</p>
<ul>
<li><p>提供静态 <code>seed</code> 值作为 <code>awgn</code> 的输入。</p>
</li>
<li><p>在将 <code>randobject</code> 传递为 <code>awgn</code> 的输入之前，请对 <code>randobject</code> 使用 <a href="https://ww2.mathworks.cn/help/matlab/ref/randstream.reset.html"><code>reset (RandSteam)</code></a> 函数。</p>
</li>
<li><p>将处于已知状态的 <code>randobject</code> 提供给 <code>awgn</code>。有关更多信息，请参见 <a href="https://ww2.mathworks.cn/help/matlab/ref/randstream.html"><code>RandStream</code></a>。</p>
</li>
</ul>
</li>
</ul>
<h1 id="扩展功能"><a href="#扩展功能" class="headerlink" title="扩展功能"></a>扩展功能</h1><h2 id="C-C-代码生成"><a href="#C-C-代码生成" class="headerlink" title="C/C++ 代码生成"></a>C/C++ 代码生成</h2><blockquote>
<p>使用 MATLAB® Coder™ 生成 C 代码和 C++ 代码。</p>
<blockquote>
<p>用法说明和限制：</p>
<p>支持代码生成，但包括 <a href="https://ww2.mathworks.cn/help/matlab/ref/randstream.html"><code>RandStream</code></a> 对象的语法除外。</p>
</blockquote>
</blockquote>
<h1 id="另请参阅"><a href="#另请参阅" class="headerlink" title="另请参阅"></a>另请参阅</h1><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p><a href="https://ww2.mathworks.cn/help/matlab/ref/randstream.html"><code>RandStream</code></a> | <a href="[RandStream](https://ww2.mathworks.cn/help/matlab/ref/randstream.html"><code>bsc</code></a>) | <a href="https://ww2.mathworks.cn/help/matlab/ref/randn.html"><code>randn</code></a> | <a href="https://ww2.mathworks.cn/help/comm/ref/wgn.html"><code>wgn</code></a></p>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p><a href="https://ww2.mathworks.cn/help/comm/ref/comm.awgnchannel-system-object.html"><code>comm.AWGNChannel</code></a></p>
<h2 id="话题"><a href="#话题" class="headerlink" title="话题"></a>话题</h2><p><a href="https://ww2.mathworks.cn/help/comm/ug/awgn-channel.html#a1071501088">AWGN Channel Noise Level</a></p>
<hr>
<p>在 R2006a 之前推出</p>
<hr>
<p>原文参考：<a href="https://ww2.mathworks.cn/help/comm/ref/awgn.html">https://ww2.mathworks.cn/help/comm/ref/awgn.html</a></p>
]]></content>
      <categories>
        <category>MATLAB</category>
        <category>翻译</category>
        <category>帮助文档</category>
        <category>信号处理</category>
        <category>噪声</category>
      </categories>
      <tags>
        <tag>MATLAB</tag>
        <tag>翻译</tag>
        <tag>高斯白噪声</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo-NexT 折腾就完事儿了</title>
    <url>/posts/b158f1b4.html</url>
    <content><![CDATA[<h1 id="瞎折腾-美化侧边栏"><a href="#瞎折腾-美化侧边栏" class="headerlink" title="瞎折腾/美化侧边栏"></a>瞎折腾/<del>美化</del>侧边栏</h1><p>在博客根目录下的 <code>source/_data</code> 文件夹中新建 <code>sidebar.swig</code> 文件。</p>
<h2 id="添加-Tag-Cloud"><a href="#添加-Tag-Cloud" class="headerlink" title="添加 Tag Cloud"></a>添加 Tag Cloud</h2><p>安装 <code>hexo-tag-cloud</code> 插件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-tag-cloud --save</span><br></pre></td></tr></table></figure>
<p>添加相关代码写入 <code>sidebar.swig</code>。不喜欢标题的把 <code>&lt;h3 class=&quot;widget-title&quot;&gt;Tag Cloud&lt;/h3&gt;</code> 去掉即可。</p>
<figure class="highlight html"><figcaption><span>source/_data/sidebar.swig</span></figcaption><table><tr><td class="code"><pre><span class="line">&#123;% if site.tags.length &gt; 1 %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/js/tagcloud.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/js/tagcanvas.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;widget-wrap&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span> <span class="attr">class</span>=<span class="string">&quot;widget-title&quot;</span>&gt;</span>Tag Cloud<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;myCanvasContainer&quot;</span> <span class="attr">class</span>=<span class="string">&quot;widget tagcloud&quot;</span> <span class="attr">style</span>=<span class="string">&quot;font-size:20px;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">width</span>=<span class="string">&quot;220&quot;</span> <span class="attr">height</span>=<span class="string">&quot;200&quot;</span> <span class="attr">id</span>=<span class="string">&quot;resCanvas&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width=100%&quot;</span>&gt;</span></span><br><span class="line">            &#123;&#123; list_tags() &#125;&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h1 id="瞎折腾-美化页面"><a href="#瞎折腾-美化页面" class="headerlink" title="瞎折腾/美化页面"></a>瞎折腾/<del>美化</del>页面</h1><p>在博客根目录下的 <code>source/_data</code> 文件夹中新建 <code>variables.styl</code> 文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd hexo</span><br><span class="line">vi source/_data/variables.styl</span><br></pre></td></tr></table></figure>
<h2 id="页面圆角"><a href="#页面圆角" class="headerlink" title="页面圆角"></a>页面圆角</h2><p>在 <code>variables.styl</code> 文件里添加圆角半径值</p>
<figure class="highlight"><figcaption><span>source/_data/variables.styl</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// 圆角设置</span></span><br><span class="line">$border-radius-inner     = 0px;     // 内部圆角半径</span><br><span class="line">$border-radius           = 8px;     // 外部圆角半径</span><br></pre></td></tr></table></figure>
<h1 id="需要修改源代码的操作"><a href="#需要修改源代码的操作" class="headerlink" title="需要修改源代码的操作"></a>需要修改源代码的操作</h1><h2 id="修改侧边栏最大高度"><a href="#修改侧边栏最大高度" class="headerlink" title="修改侧边栏最大高度"></a>修改侧边栏最大高度</h2><p>Sidebar 的高度在 <code>themes/next/source/js/util.js</code> 文件中计算出，修改计算公式可调整 Sidebar 的最大高度。</p>
<figure class="highlight javascript"><figcaption><span>themes/next/source/js/util.js - 原 Sidebar 最大高度</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Init Sidebar &amp; TOC inner dimensions on all pages and for all schemes.</span></span><br><span class="line"><span class="comment"> * Need for Sidebar/TOC inner scrolling if content taller then viewport.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">initSidebarDimension: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// Initialize Sidebar &amp; TOC Height.</span></span><br><span class="line">  <span class="keyword">var</span> sidebarWrapperHeight = <span class="built_in">document</span>.body.offsetHeight - sidebarSchemePadding + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><figcaption><span>themes/next/source/js/util.js - 修改后的 Sidebar 最大高度</span></figcaption><table><tr><td class="code"><pre><span class="line">initSidebarDimension: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// Initialize Sidebar &amp; TOC Height.</span></span><br><span class="line">  <span class="keyword">var</span> sidebarWrapperHeight = <span class="built_in">document</span>.body.offsetHeight - sidebarSchemePadding -<span class="number">100</span> + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<ul>
<li>参考文档：<a href="https://yi-yun.github.io/Hexo-Next-Custom/#更改-sidebar-大小https://yi-yun.github.io/Hexo-Next-Custom/#更改-sidebar-大小">Hexo Next 博客自定义配置 -&gt; 更改-sidebar-大小</a></li>
</ul>
]]></content>
      <categories>
        <category>Blog</category>
        <category>Hexo</category>
        <category>Next</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title>Josh 的学习笔记之 Verilog（Part 2 —— Verilog 语言基础）</title>
    <url>/posts/fd2ca242.html</url>
    <content><![CDATA[<p>本文从一个 Verilog 用例出发，对 Verilog 语言的语法进行了阐释。包括的内容主要有 Verilog 语言的基本词法，常用的编译指令，逻辑值、常量、变量的含义，操作符的概念和分类等，还对 Verilog 中的参数、并发以及系统任务和系统函数进行了简要说明。</p>
<h1 id="1-两种设计方法（Top-Down-和-Bottom-Up）"><a href="#1-两种设计方法（Top-Down-和-Bottom-Up）" class="headerlink" title="1. 两种设计方法（Top-Down 和 Bottom-Up）"></a>1. 两种设计方法（Top-Down 和 Bottom-Up）</h1><p>在传统意义上，设计硬件电路主要是使用自底向上（Bottom-Up）的设计方法。工程师们总是从最底层的逻辑门开始，逐渐搭建成较大的模块，然后再将这些模块组成更大的模块，最后形成整个设计。</p>
<p>在  <a href="https://josh-gao.top/posts/460433dd.html">Part 1——初识 HDL 设计方法</a>中已经提到，随着 HDL 和逻辑综合技术的进步，工程师们逐渐可以使用自顶向下（Top-Down）的方法来设计硬件。这样，工程师们<strong>首先关注于设计的规格（Specification），然后将规格分解为一个个模块，再分解为更小的模块</strong>。然后采用 HDL 的可综合子集直接描述硬件的行为，由逻辑综合工具自动完成由 HDL 到门级电路的转换。</p>
<a id="more"></a>
<p>最近几年，随着 IP核 市场的逐渐兴起，许多设计者逐渐意识到<strong>利用现有的 IP核 可以帮助节约设计成本、减少设计周期</strong>，有许多设计工程师，甚至希望所有的设计模块都使用现成的模块，自己仅仅开发一些简单的粘合逻辑。这就有点像电路板设计的过程，工程师将各种芯片集成到一块电路板上，自己完成这些芯片间的互连和一些简单的 CPLD 逻辑设计，以及对微处理器的编程。使用现有的 IP 来搭建系统实际上也是一种自底向上（Bottom-Up）的设计方法。</p>
<p>从以上描述可以看出，设计硬件电路时，这两种设计方法都有可能采用。Verilog HDL 可以完全支持这两种设计方法。</p>
<ul>
<li>在门级的设计中，用户可以直接实例化 Verilog 语言中的门级原语构建系统；</li>
<li>如果需要描述硬件的行为，可以使用 Verilog 的行为级描述功能；</li>
<li>如果要使用 IP核 ，只要在设计中直接实例化 IP核 即可。</li>
</ul>
<p>EDA 行业的先行者们发明了 Verilog 硬件描述语言，其最根本的目的就是用 Verilog 来描述硬件的行为，但是有的描述是不需要实现为硬件电路的。</p>
<p>如果用户的 Verilog 描述的最终目的是要实现为硬件电路，那么要<strong>时刻提醒自己是在设计电路</strong>，这与用 C 语言对处理器编程有很大的区别。</p>
<p>硬件电路最大的特点是由一个个模块组成，模块之间使用互连线，各个模块<strong>独立并行</strong>工作。同时，它们通过输人和输出端口与相邻的模块互相沟通。每个硬件单元都有相应的<strong>延时特性</strong>，硬件的延时也是设计的目标之一。</p>
<h1 id="2-从-Verilog-实例出发"><a href="#2-从-Verilog-实例出发" class="headerlink" title="2. 从 Verilog 实例出发"></a>2. 从 Verilog 实例出发</h1><h2 id="2-1-Verilog-实例"><a href="#2-1-Verilog-实例" class="headerlink" title="2.1. Verilog 实例"></a>2.1. Verilog 实例</h2><p><a name="JoshVerilog模块"></a>首先看一个简单的如下图所示的电路（模块）：JoshVerilog。它可以是一个独立的设计，也可以是更大的系统的一个组成部分。</p>
<div align="center">
  <img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-28-josh-verilog-part-2/2020-11-28-josh-verilog-part-2-010-JoshVerilog.png!700px"/>
</div>

<p>该电路首先在两个 2 位的输人数据 <code>A_in[1:0]</code> 的和 <code>B_in[1:0]</code> 之间，由 <code>sel</code> 信号做二选一。后面是一个 2-4 译码电路，将输人的信号 <code>result[1:0]</code>解析成 <code>eq0</code>、<code>eql</code>、<code>eq2</code> 和 <code>eq3</code> 这4个信号，它们同时只有一个为 1。</p>
<p>将 <code>eq0</code> 和 <code>eql</code> 相异或（xor），<code>eq2</code> 和 <code>eq3</code> 相异或。然后，将两个异或的结果 <code>A_xor_wire</code> 和 <code>XOR_B</code> 分别寄存输出给 <code>A_xor_out</code> 和 <code>B_xor_out</code> 两个输出寄存器带有低有效（active low）的异步复位端。</p>
<p><strong>这些电路单元都是同时并行工作的，相互之间并没有先后顺序关系，这一点与软件设计程序很不一样。</strong></p>
<p>下面具体分析 <a href="#JoshVerilog模块">JoshVerilog 模块</a>的电路功能。源代码如下。</p>
<p><a name="JoshVerilog代码"></a></p>
<figure class="highlight verilog"><figcaption><span>Josh.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编译指令, 定义时间单位和时间精度</span></span><br><span class="line"><span class="meta">`<span class="meta-keyword">timescale</span> 1ns/100p             // 每个时间单位是1ns, 仿真精度是100ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// module名 + 端口列表</span></span><br><span class="line"><span class="keyword">module</span> Josh( clk, rst_n, A_in, B_in, sel, A_xor_out, B_xor_out );</span><br><span class="line"></span><br><span class="line"><span class="comment">// IO端口声明</span></span><br><span class="line"><span class="keyword">input</span>       clk;</span><br><span class="line"><span class="keyword">input</span>       rst_n;</span><br><span class="line"><span class="keyword">input</span> [<span class="number">1</span>:<span class="number">0</span>] A_in;               <span class="comment">// 该信号的输入位宽为2</span></span><br><span class="line"><span class="keyword">input</span> [<span class="number">1</span>:<span class="number">0</span>] B_in;</span><br><span class="line"><span class="keyword">input</span>       sel;</span><br><span class="line"><span class="keyword">output</span>      A_xor_out;</span><br><span class="line"><span class="keyword">output</span>      B_xor_out;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内部线网和寄存器声明</span></span><br><span class="line"><span class="keyword">wire</span>        A_xor_wire;         <span class="comment">// 模块内wire型变量</span></span><br><span class="line"><span class="keyword">wire</span>        B_xor_wire;</span><br><span class="line"><span class="keyword">wire</span>  [<span class="number">1</span>:<span class="number">0</span>] result;</span><br><span class="line"><span class="keyword">reg</span>         eq0, eq1, eq2, eq3; <span class="comment">// 模块内reg型变量</span></span><br><span class="line"><span class="keyword">reg</span>         A_xor_out;</span><br><span class="line"><span class="keyword">reg</span>         B_xor_out;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 行为描述, DFF_A</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">    <span class="keyword">if</span> (~rst_n)</span><br><span class="line">        A_xor_out &lt;= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        A_xor_out &lt;= A_xor_wire;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 行为描述, DFF_B</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">    <span class="keyword">if</span> (~rst_n)</span><br><span class="line">        B_xor_out &lt;= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        B_xor_out &lt;= B_xor_wire;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据流描述, A_xor_wire</span></span><br><span class="line"><span class="keyword">assign</span> #<span class="number">1</span> A_xor_wire = eq0 ^ eq1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构化描述, XOR_B, 直接使用 Verilog 自带的 xor 门原句</span></span><br><span class="line"><span class="keyword">xor</span> #<span class="number">1</span> XOR_B(B_xor_wire, eq2, eq3);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据流描述, MUX21</span></span><br><span class="line"><span class="keyword">assign</span> #<span class="number">3</span> result = sel ? B_in : A_in;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 行为描述, DECODER, 一个2-4译码器</span></span><br><span class="line"><span class="keyword">always</span> @(result) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">case</span>(result)</span><br><span class="line">        <span class="number">2&#x27;b00</span>: <span class="keyword">begin</span></span><br><span class="line">            &#123;eq3, eq2, eq1, eq0&#125; = #<span class="number">2</span> <span class="number">4&#x27;b0001</span>;</span><br><span class="line">            <span class="built_in">$display</span> (<span class="string">&quot;At time %t-&quot;</span>, <span class="built_in">$time</span>, <span class="string">&quot;eq0 = 1&quot;</span>);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="number">2&#x27;b01</span>: <span class="keyword">begin</span></span><br><span class="line">            &#123;eq3, eq2, eq1, eq0&#125; = #<span class="number">2</span> <span class="number">4&#x27;b0010</span>;</span><br><span class="line">            <span class="built_in">$display</span> (<span class="string">&quot;At time %t-&quot;</span>, <span class="built_in">$time</span>, <span class="string">&quot;eq1 = 1&quot;</span>);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="number">2&#x27;b10</span>: <span class="keyword">begin</span></span><br><span class="line">            &#123;eq3, eq2, eq1, eq0&#125; = #<span class="number">2</span> <span class="number">4&#x27;b0100</span>;</span><br><span class="line">            <span class="built_in">$display</span> (<span class="string">&quot;At time %t-&quot;</span>, <span class="built_in">$time</span>, <span class="string">&quot;eq2 = 1&quot;</span>);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="number">2&#x27;b11</span>: <span class="keyword">begin</span></span><br><span class="line">            &#123;eq3, eq2, eq1, eq0&#125; = #<span class="number">2</span> <span class="number">4&#x27;b1000</span>;</span><br><span class="line">            <span class="built_in">$display</span> (<span class="string">&quot;At time %t-&quot;</span>, <span class="built_in">$time</span>, <span class="string">&quot;eq3 = 1&quot;</span>);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">default</span>: ;</span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">// module结束</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>代码分析如下。</p>
<ol>
<li><p>二选一多路选择器</p>
<p> 对于 <code>MUX21</code> 这样二选一的电路，将采用如下的数据流描述（assign语句）：</p>
 <figure class="highlight verilog"><figcaption><span>Josh.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> #<span class="number">3</span> result = sel ? B_in : A_in;</span><br></pre></td></tr></table></figure>
<p> <code>assign</code> 是 Verilog 中的关键词，用它赋值的语言称为<strong>连续赋值语句</strong>。</p>
<p> 如果 <code>sel</code>为真（1），则选择 <code>B_in</code>，否则将选择 <code>A_in</code>，而 <code>#3</code> 表示经过 3 个延时单位，再将选择结果赋值给 <code>result</code>，这也模拟了组合逻辑的延时。由于在<a href="#JoshVerilog代码">代码</a>最开头已经使用 Verilog 的编译指令将延时单位定义为 1ns（<code>timescale 1ns/100ps</code>），因此这里的 <code>#3</code> 代表 3ns 的延时。</p>
</li>
<li><p>2 - 4 译码器</p>
<p> 关于实现 2 - 4 译码器，则采用了如下的描述：</p>
 <figure class="highlight verilog"><figcaption><span>Josh.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @(result) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">case</span>(result)</span><br><span class="line">        <span class="number">2&#x27;b00</span>: <span class="keyword">begin</span></span><br><span class="line">            &#123;eq3, eq2, eq1, eq0&#125; = #<span class="number">2</span> <span class="number">4&#x27;b0001</span>;</span><br><span class="line">            <span class="built_in">$display</span> (<span class="string">&quot;At time %t-&quot;</span>, <span class="built_in">$time</span>, <span class="string">&quot;eq0 = 1&quot;</span>);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">default</span>: ;</span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p> 这里采用了另一种描述方式：用 <code>always</code> 语句来描述电路的行为。通过 <code>case</code> 判断 <code>result</code> 的值来决定 <code>eq0</code>、<code>eq3</code> 的值。同样，也采用 <code>#2</code> 来模拟组合逻辑的延时。<code>always</code> 和 <code>case</code> 也是 Verilog 中的关键词。这样的描述方法称之为<strong>行为描述</strong>，它侧重于描述电路的行为。</p>
 <figure class="highlight verilog"><figcaption><span>Josh.v</span></figcaption><table><tr><td class="code"><pre><span class="line">&#123;eq3, eq2, eq1, eq0&#125; = #<span class="number">2</span> <span class="number">4&#x27;b0001</span>;</span><br></pre></td></tr></table></figure>
<p> 该语句表示将 <code>4&#39;b0001</code> 赋值给 <code>eq3~eq0</code> 合并成的 4 位变量。<code>&#123;&#125;</code> 是 Verilog 的合并符号。</p>
</li>
<li><p>异或门</p>
<p> 对于 <code>A_xor_wire</code> 和 <code>XOR_B</code> 的两个完全一样的异或门，也采用了两种不同的描述方式：</p>
 <figure class="highlight verilog"><figcaption><span>Josh.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> #<span class="number">1</span> A_xor_wire = eq0 ^ eq1;</span><br></pre></td></tr></table></figure>
<p> 和</p>
 <figure class="highlight verilog"><figcaption><span>Josh.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">xor</span> #<span class="number">1</span> XOR_B(B_xor_wire, eq2, eq3);</span><br></pre></td></tr></table></figure>
<p> <code>xor</code> 是 Verilog 中自带的基本逻辑门原语。这里相当于调用了该 <code>xor</code> 门。而 <code>B_xor_wire</code>、<code>eq2</code> 和 <code>eq3</code> 是代人到 <code>xor</code> 门中的参数。<code>eq2</code> 和 <code>eq3</code> 是输人，<code>B_xor_wire</code> 是输出。这里 <code>B_xor_wire</code> 是 <code>eq2</code> 和 <code>eq3</code> 相异或的结果。</p>
<p> 在 Verilog 中，<strong>将调用其他功能模块（包括 Verilog 的内嵌基本逻辑门）称为“实例化（lnstantiate）”</strong>。实例化<strong>类似</strong>于软件设计中的调用，但不能简单理解为软件中的调用。软件调用过程是顺序执行的，而实例化的硬件电路在设计中是独立于其他功能块，并行运行的。</p>
<p> 这种<strong>在模块中实例化其他功能模块</strong>的描述方式被称之为<strong>结构化描述</strong>。</p>
</li>
</ol>
<h2 id="2-2-3-种描述方法"><a href="#2-2-3-种描述方法" class="headerlink" title="2.2. 3 种描述方法"></a>2.2. 3 种描述方法</h2><p>从以上的描述可以看出 Verilog 语言的 3 种基本的描述方法（基本上所有的 Verilog 功能模块都是由这 3 种方式来描述）：</p>
<ul>
<li><strong>数据流描述</strong>：采用 <code>assign</code> 语句，该语句被称为连续赋值语句；</li>
<li><strong>行为描述</strong>：使用 <code>always</code> 或 <code>initial</code> 语句块，其中出现的语句被称为过程赋值语句；</li>
<li><p><strong>结构化描述</strong>：实例化已有的功能模块。结构化描述主要有以下3种：</p>
<ul>
<li>Module实例化：实例化已有的 module；</li>
<li>门实例化：实例化基本的门电路原语；</li>
<li>用户定义原语（UDP）实例化：实例化用户定义的原语。</li>
</ul>
</li>
</ul>
<p>在<a href="https://josh-gao.blog.csdn.net/article/details/105262549">《Part 3——描述方式和设计层次》</a>中会将详细介绍 Verilog 语言中的这 3 种描述方式。</p>
<h1 id="3-Verilog-的基本词法"><a href="#3-Verilog-的基本词法" class="headerlink" title="3. Verilog 的基本词法"></a>3. Verilog 的基本词法</h1><p>Verilog HDL 是一种<strong>大小写敏感</strong>的语言，这一点与 VHDL 不同，因此在书写的时候要格外注意。在 Verilog 语言中，<strong>所有的关键字（又叫保留字）都为小写</strong>。Verilog 的内部信号名（或称为标识符）使用大写和小写都可以。标识符可以是字母、数字、<code>$</code>（美元符号）和 <code>_</code>（下划线）任意组合，只要<strong>第一个字符是字母或者下划线</strong>即可。</p>
<blockquote>
<p>因为 Verilog HDL 对大小写敏感，因此养成良好的信号定义习惯非常重要，否则容易因为大小写不同造成信号的歧义。推荐的信号定义习惯为：<strong>所有信号和网线名均小写，用下划线分割单词，而宏变量全部用大写字母。</strong></p>
</blockquote>
<p>在上述<a href="#JoshVerilog代码">代码</a>中，用双反斜线 <code>//</code> 表示注释。另外，还有一种注释方式，用 <code>/* ...... */</code> 来表示。所不同的是前者为单行注释，而后者将 <code>/*</code> 和 <code>*/</code> 之间的内容全部看作注释内容。</p>
<blockquote>
<p>通常，注释的内容只是作者为了增强代码的可读性而增加的内容，对整个代码的功能没有任何影响。不过，在一些工具中，尤其是逻辑综合工具，定义了一些特殊的指令，用于控制工具编译过程。这些指令也是以注释的方式出现的。例如：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">moduleblbox(out, data, clk) <span class="comment">/* synthesis syn_black_box */</span>;</span><br></pre></td></tr></table></figure>
<p>在 <code>modulebl_box</code> 的声明处有一行注释，用 <code>/* ...... */</code> 表示。它看起来是一个注释，实际上，是综合工具Synplify中的一个指令，指示 Synplify 将该模块看作一个黑盒（black_box），不处理模块内部的描述。</p>
</blockquote>
<p>在 Verilog 中，通常使用空格符、跳格符和换行符作为间隔。在书写代码的时候，适当运用间隔符可以提高代码的可读性。比如在声明 4 个 <code>reg</code> 型数据 <code>eq0~eq3</code> 时，可以采用上述<a href="#JoshVerilog代码">例子</a>中的方法：</p>
<figure class="highlight verilog"><figcaption><span>Josh.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">reg</span> eq0, eq1, eq2, eq3;</span><br></pre></td></tr></table></figure>
<p>也可以用换行符将其分开：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">reg</span> eq0;</span><br><span class="line"><span class="keyword">reg</span> eq1;</span><br><span class="line"><span class="keyword">reg</span> eq2;</span><br><span class="line"><span class="keyword">reg</span> eq3;</span><br></pre></td></tr></table></figure>
<p>在verilog中，还有一些转义字符。比如 <code>\n</code> 表示换行符；<code>\t</code> 表示 Tab 键；防止引起歧义，就用 <code>\</code> 表示 <code>\</code> 符号本身等等。这里不再对 Verilog 的词法做过多的描述，更多可以参考 Verilog IEEE 国际标准（<a href="https://standards.ieee.org/standard/1364-2005.html">IEEE Std. 1364-2005</a>）。</p>
<h1 id="4-模块和端口"><a href="#4-模块和端口" class="headerlink" title="4. 模块和端口"></a>4. 模块和端口</h1><p>大型设计往往是由一个个模块构成的。实际上，模块可大可小，大到一个复杂的微处理器系统，小到一个基本的晶体管，都可以作为一个模块来设计。例如，在上述代码中描述的 <a href="#JoshVerilog代码">JoshVerilog</a> 就是一个模块。</p>
<p>在 Verilog 中，模块（module）是基本的组成单位。</p>
<blockquote>
<p>通常，建议在一个 Verilog 文件中，只放一个 <code>module</code> 定义，而且使文件名称和 <code>module</code> 名称一致。这是一个良好的设计习惯。</p>
</blockquote>
<p>以下是 Verilog 中 <code>module</code> 的基本语法：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> 模块名称( 端口列表 );</span><br><span class="line"><span class="comment">// 声明：</span></span><br><span class="line">    <span class="keyword">reg</span>, <span class="keyword">parameter</span>,</span><br><span class="line">    <span class="keyword">input</span>, <span class="keyword">output</span>, </span><br><span class="line">    <span class="keyword">function</span>, <span class="keyword">task</span>, ...</span><br><span class="line"><span class="comment">// 语句：</span></span><br><span class="line">    <span class="keyword">initial</span> 语句</span><br><span class="line">    <span class="keyword">always</span> 语句</span><br><span class="line">    <span class="keyword">module</span> 实例化</span><br><span class="line">    门实例化</span><br><span class="line">    用户定义原语 (UDP) 实例化</span><br><span class="line">    连续赋值 (Continous assignment)</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>首先，需要有一个名称来标识这个 <code>module</code>。</p>
<p>通常 <code>module</code> 具有输入和输出端口，在 <code>module</code> 名称后面的括号中列出所有的输入、输出和双向的端口名称。</p>
<p>有些 <code>module</code> 也不包含端口。例如，在仿真平台的顶层模块中，其内部已经实例化了所有的设计模块和激励模块，是一个封闭的系统，没有输入和输出。一般这种没有端口的模块都是用于仿真的，不用作实际电路。</p>
<p>在 <code>module</code> 内部的声明部分，需要声明端口的方向，（<code>input</code>, <code>output</code> 和 <code>inout</code>）和位宽。按照 Verilog 的习惯，<strong>高位写在左边，低位写在右边</strong>。比如</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">input</span> [<span class="number">1</span>:<span class="number">0</span>] A_in；</span><br></pre></td></tr></table></figure>
<p>就表示两位的总线。</p>
<p>模块内部使用的 <code>reg</code>（寄存器类型的一种）、<code>wire</code>（线网类型的一种）、参数、函数以及任务等，都将在 <code>module</code> 中声明。</p>
<p>一般来说，<code>module</code> 的 </p>
<ul>
<li><code>input</code> 默认定义为 <code>wire</code> 类型；</li>
<li><code>output</code> 信号可以是 <code>wire</code>，也可以是 <code>reg</code> 类型（如果在 <code>always</code> 或 <code>initial</code> 语句块中被赋值）；</li>
<li><code>inout</code> 是双向信号，一般将其设为 <code>tri</code> 类型，表示其有多个驱动源，如无驱动时为三态。</li>
</ul>
<p>虽然变量声明只要出现在使用的相应语句之间即可，但还是建议将所有的声明放在所有的语句之前，这样具有较好的可读性。在声明之后，就应该是语句了。语句有如下几种：</p>
<ul>
<li><code>initial</code> 语句；</li>
<li><code>always</code> 语句；</li>
<li>其他子 <code>module</code> 实例化；</li>
<li>门实例化；</li>
<li>用户定义原语（UDP）实例化；</li>
<li>连续赋值（Continous assignment）。</li>
</ul>
<p>Verilog 中所有的功能描述都是通过以上几种描述方式进行的。</p>
<blockquote>
<p>需要格外注意的是，以上几种语句如果出现在同一个 <code>module</code> 内，其<strong>相互之间是没有任何顺序关系的</strong>，它们在 <code>module</code> 中出现顺序的改变不会改变 <code>module</code> 的功能，这正是硬件的一大特点。有硬件电路原理图设计经验的读者们可以想象一下画原理图的过程，先画哪个，后画哪个器件根本没有任何关系。在 Verilog 中也是类似的道理。</p>
</blockquote>
<h1 id="5-编译指令"><a href="#5-编译指令" class="headerlink" title="5. 编译指令"></a>5. 编译指令</h1><p>在 Verilog 语言中，提供了一些编译指令，用于指导编译器的工作。例如，定义宏、文件包含、条件编译、时间单位和精度定义等。</p>
<p>Verilog 中的编译指令是从 C 语言中的“预处理指令”演变得来的。这里列出了一些常用的编译指令如下：</p>
<ul>
<li><code>`timescale</code>；</li>
<li><code>`define, `undef</code>；</li>
<li><code>`ifdef, `else, `endif</code>；</li>
<li><code>`include</code>；</li>
<li><code>`resetall</code>。</li>
</ul>
<p>与 C 语言中使用的 <code>#</code> 不同，Verilog 中使用反引号一来标识编译指令。编译器一旦遇到某个编译指令，则其在整个编译过程中有效，可以包含多个文件，直到编译器遇到另一个相同的编译指令。</p>
<h2 id="5-1-timescale"><a href="#5-1-timescale" class="headerlink" title="5.1. `timescale"></a>5.1. <code>`timescale</code></h2><p>在每一个 <code>module</code> 文件前面加上<code>` </code>的编译指令，就可以保证该文件中的延时信息受其自身文件中的 <code>`timescale</code> 编译指令指导。<strong>否则在编译过程中，该模块将沿用上一个</strong> <code>`timescale</code> <strong>的值，或者使用缺省值</strong>。</p>
<p>在上述实例代码中描述的 <a href="#JoshVerilog代码">JoshVerilog</a> 模块中使用了一个<code>`timescale 1ns/100ps</code> 编译指令。其中 <code>1ns</code> 表示延时单位，<code>100ps</code> 表示时间精度，也就是编译器所能接收的最小仿真时间粒度。<code>`timescale</code> 编译指令在模块外部出现，并且影响后面模块中所有的时延值，直到遇到下一个 <code>`timescale</code> 或 <code>`resetall</code>指令。</p>
<p>比如语句：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> #<span class="number">1</span><span class="variable">.16</span> A_xor_wire = eq0 ^ eq1;</span><br></pre></td></tr></table></figure>
<p>如果采用 <code>`timescale 1ns/100ps</code> 编译指令由于延时单位是 <code>1ns</code>，同时最小时间粒度是 <code>100ps</code>，即 <code>0.1ns</code> ，那么根据四舍五入的规则，<code>1.16ns</code> 则实际上对应 <code>1.2ns</code> 延时。如果采用 <code>`timescale 1ns/10ps</code> 编译指令，由于延时单位是 <code>1ns</code>，同时最小时间粒度是 <code>10ps</code>，即 <code>0.01ns</code>，那么 <code>1.16ns</code> 则实际上对应 <code>1.16ns</code> 延时。</p>
<h2 id="5-2-define-和-undef"><a href="#5-2-define-和-undef" class="headerlink" title="5.2. `define 和 `undef"></a>5.2. <code>`define</code> 和 <code>`undef</code></h2><p><code>`define</code> 用于定义宏。例如，首先定义一个总线宽度的宏为 16，然后利用这个宏定义一个宽度为 16 的 <code>reg</code>类型数据 <code>Data</code>，方法如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="meta-keyword">define</span> BUS_WIDTH 16</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="meta">`BUS_WIDTH - 1 : 0] Data</span></span><br></pre></td></tr></table></figure>
<p>在一个文件中出现的 <code>`define</code>，可以被多个文件使用。也就是说 <code>`define</code> 是一种<strong>全局的定义</strong>。这是 <code>`define</code> 与 <code>parameter</code> 定义的最大区别，在后面也会提到。</p>
<p><code>`define</code> 指令被编译以后，则在整个编译过程中都有效，直到遇到 <code>`undef</code> 指令，该宏就不再有效。如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="meta-keyword">undef</span> BUS_WIDTH</span></span><br></pre></td></tr></table></figure>
<p>遇到该编译指令后，先前的 <code>`define</code> 指令失效。</p>
<h2 id="5-3-ifdef、-else-和-endif"><a href="#5-3-ifdef、-else-和-endif" class="headerlink" title="5.3. `ifdef、`else 和`endif"></a>5.3. <code>`ifdef</code>、<code>`else</code> 和<code>`endif</code></h2><p>再来看看如下的条件编译指令：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="meta-keyword">ifdef</span> NARROW</span></span><br><span class="line">    <span class="keyword">parameter</span> BUS_WIDTH = <span class="number">16</span>；</span><br><span class="line"><span class="meta">`<span class="meta-keyword">else</span></span></span><br><span class="line">    paramete rBUS_WIDTH = <span class="number">32</span>；</span><br><span class="line"><span class="meta">`<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>在这个条件编译指令中，如果先前已经定义了 <code>NARROW</code> 宏，那么参数 <code>BUS_WIDTH</code> 被设置为 16，否则其被设置为 32。<code>`else</code> 指令对于 <code>`ifdef</code> 来说是可选的，也就是说可以单独使用。</p>
<h2 id="5-4-include"><a href="#5-4-include" class="headerlink" title="5.4. `include"></a>5.4. <code>`include</code></h2><p>在 Verilog 中，可以使用 <code>`include</code> 指令来嵌人某个文件的内容。例如：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="meta-keyword">include</span> &quot;HEADFILE.h&quot;</span></span><br></pre></td></tr></table></figure>
<p>那么，在编译的时候，就将使用 <code>HEADFILE.h</code> 文件中的内容完全替换这一行语句。而双引号中的文件可以使用相对路径，或绝对路径，或者默认在当前路径以下。</p>
<h2 id="5-5-resetall"><a href="#5-5-resetall" class="headerlink" title="5.5. `resetall"></a>5.5. <code>`resetall</code></h2><p><code>`resetall</code> 编译指令会将所有其他编译指令重新设置为缺省值，要谨慎使用。</p>
<blockquote>
<p>Verilog 语言中的编译指令不止这几条，其他不常用的指令这里不一一介绍，有兴趣可以参考其他文献。</p>
</blockquote>
<h1 id="6-逻辑值与常量"><a href="#6-逻辑值与常量" class="headerlink" title="6. 逻辑值与常量"></a>6. 逻辑值与常量</h1><h2 id="6-1-逻辑值"><a href="#6-1-逻辑值" class="headerlink" title="6.1. 逻辑值"></a>6.1. 逻辑值</h2><p>在二进制计数中，单位逻辑值只有 <code>1</code> 和 <code>0</code> 两种状态。而在 Verilog 语言中，为了对电路进行精确建模，于是增加了两种逻辑状态 <code>X</code> 和 <code>Z</code>。</p>
<ul>
<li><code>X</code> 表示未知值（unknown），或者不关心（don’t care），<code>X</code> 用作信号状态时表示未知，用在条件判断时（在 <code>casex</code> 或 <code>casez</code>中）表示不关心；</li>
<li><code>Z</code> 表示高阻状态，也就是<strong>没有任何驱动</strong>，通常用来对<strong>三态总线</strong>进行建模。</li>
</ul>
<p>在后面将提到 Verilog 语言中的变量类型。通常 <code>net</code> 型变量如果没有初始化，其值为 <code>Z</code>，<code>register</code> 型变量如果没有初始化，其值为 <code>X</code> 。这一点在仿真时显得比较有意义。</p>
<blockquote>
<p>但是，对综合工具而言（或者说在实际电路中），并没有什么 <code>X</code> 值，只存在 <code>0</code>、<code>1</code> 和 <code>Z</code> 这 3 种状态。在实际电路中还可能出现亚稳态，它既不是 <code>0</code>，也不是 <code>1</code>，是一种暂时的不稳定状态。</p>
</blockquote>
<p>Verilog 语言中所有数据都是由以上描述的 4 种基本的逻辑值 <code>0</code>、<code>1</code>、<code>X</code> 和 <code>Z</code> 构成。同时，<code>X</code> 和 <code>Z</code> 是不区分大小写的。例如：<code>0z1x</code> 和 <code>0Z1X</code> 表示同一个数据。</p>
<h2 id="6-2-常量"><a href="#6-2-常量" class="headerlink" title="6.2. 常量"></a>6.2. 常量</h2><p>常量是 Verilog 中不变的数值。在上述<a href="#JoshVerilog代码">实例代码</a>中，<code>4&#39;b0001</code> 就表示一个 4 位的二进制整型常量：0001。</p>
<p>Verilog中的常量有3种：</p>
<ul>
<li>整数型；</li>
<li>实数型；</li>
<li>字符串型。</li>
</ul>
<h3 id="6-2-1-整型常量"><a href="#6-2-1-整型常量" class="headerlink" title="6.2.1. 整型常量"></a>6.2.1. 整型常量</h3><p>可以使用简单的十进制表示一个整型常量，例如：</p>
<ul>
<li><code>16</code> 表示十进制的 16；</li>
<li><code>-15</code> 表示十进制的 -15，用二进制补码表示，至少需要 5 位，即 10001，最高一位为符号位；如果用 6 位表示，则是 110001，同样最高一位为符号位。</li>
</ul>
<p>整数型常量也可以采用基数表示法，例如：</p>
<ul>
<li><code>8&#39;haa</code>：表示 8 位的<strong>十六进制数</strong>，换算成二进制是 1010_1010。</li>
<li><code>6&#39;o33</code>：表示 6 位的<strong>八进制数</strong>，换算成二进制是 011_011。</li>
<li><code>4&#39;b1011</code>：表示 4 位的<strong>二进制数</strong> 1011。</li>
<li><code>3&#39;d7</code>：表示 3 位<strong>十进制</strong>的 7。</li>
</ul>
<p>在基数表示法中，都是以如下格式写的：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">[长度]&#x27;数值符号 数字</span><br></pre></td></tr></table></figure>
<p>其中长度可有可无，数值符号中，<code>h</code> 表示十六进制，<code>o</code> 表示八进制，<code>b</code> 表示二进制，<code>d</code> 表示十进制数据。如果长度比后面数字的实际位数多，则<strong>自动在数字的左边补足 0</strong>；如果位数少，则<strong>自动截断数字左边超出的位数</strong>。</p>
<p>如果将数字写成 <code>&#39;haa</code>，那么这个十六进制数的长度就决定于数字本身的长度。</p>
<p>在基数表示法中，如果遇到 <code>X</code>，十六进制数中表示 4 个 <code>X</code>，八进制数中表示 3 个 <code>X</code>。</p>
<p>另外，数字中的下划线没有任何意义，只是增强可读性。例如：<code>4&#39;b1011</code> 和 <code>4&#39;b10_11</code> 一样。</p>
<h3 id="6-2-2-实数型常量"><a href="#6-2-2-实数型常量" class="headerlink" title="6.2.2. 实数型常量"></a>6.2.2. 实数型常量</h3><p>Verilog 语言中的实数型变量可以采用十进制，也可以采用科学计数法，例如：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span><span class="variable">.512</span></span><br><span class="line"><span class="number">13_2</span><span class="variable">.18e2</span>       <span class="comment">// 表示13218</span></span><br></pre></td></tr></table></figure>
<h3 id="6-2-3-字符串型常量"><a href="#6-2-3-字符串型常量" class="headerlink" title="6.2.3. 字符串型常量"></a>6.2.3. 字符串型常量</h3><p>字符串是双引号中的字符序列，例如：<code>&quot;HeIIo World&quot;</code>。字符串是 8 位 ASCII 码值的序列，<code>&quot;HeIIo World&quot;</code> 就需要 11 字节存储，方法如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">reg</span>[<span class="number">1</span>:<span class="number">8</span> * <span class="number">11</span>] Message;</span><br><span class="line">Message = <span class="string">&quot;HeIIo World&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>这样就将字符串常量存人到 Message 变量中。</p>
<h1 id="7-变量类型"><a href="#7-变量类型" class="headerlink" title="7. 变量类型"></a>7. 变量类型</h1><p>在 Verilog 语言中，有两大变量类型：</p>
<ul>
<li>线网型：表示电路间的物理连线。</li>
<li>寄存器型：Verilog 中的一个抽象的存储数据单元。</li>
</ul>
<p>对于初学者而言，则需要首先遵守如下的简单规则：</p>
<ul>
<li><strong>凡是在</strong> <code>always</code> <strong>或</strong> <code>initial</code> <strong>语句中赋值的变量，一定是寄存器变量</strong>；</li>
<li><strong>在</strong> <code>assign</code> <strong>中赋值的一定是线网变量</strong>。</li>
</ul>
<h2 id="7-1-线网类型"><a href="#7-1-线网类型" class="headerlink" title="7.1. 线网类型"></a>7.1. 线网类型</h2><p>在线网类型下，分为几种子类，它们具有线网的共性：</p>
<ul>
<li><code>wire</code>、<code>tri</code>：表示电路间连线，<code>tri</code> 主要用于多驱动源建模；</li>
<li><code>wor</code>、<code>trior</code>：表示该连线具有“线或”功能；</li>
<li><code>wand</code>、<code>triand</code>：表示该连线具有“线与”功能；</li>
<li><code>trireg</code>：表示该连线具有总线保持功能；</li>
<li><code>tri1</code>、<code>tri0</code>：表示当无驱动时，连线状态为1（<code>tri1</code>）和0（<code>tri0</code>）；</li>
<li><code>supply1</code>、<code>supply0</code>：分别表示电源和地信号。</li>
</ul>
<p>在以上描述的线网类型中，除了 <code>trireg</code> 未初始化时为 <code>X</code> 以外，其余的未初始化时的值为 <code>Z</code>。</p>
<p>线网类型主要用在连续赋值语句中，以及作为模块之间的互连信号。</p>
<p>在后面的内容中会详细阐述常用线网类型的使用方法。</p>
<h2 id="7-2-寄存器类型"><a href="#7-2-寄存器类型" class="headerlink" title="7.2. 寄存器类型"></a>7.2. 寄存器类型</h2><p>寄存器类型变量在 Verilog 语言中通常表示一个存储数据的空间。尤其是在 Verilog 仿真器中，寄存器类型变量通常占据一个仿真内存空间。</p>
<ul>
<li><code>reg</code>：是最常用的寄存器类型数，可以是 1 位或者多位，或者是二维数组（存储器）；</li>
<li><code>integer</code>：整型数据，存储一个至少 32 位</li>
<li><code>time</code>：时间类型，存储一个至少 64 位的时间值；</li>
<li><code>real</code>，<code>realtime</code>：实数和实数时间寄存器。</li>
</ul>
<h3 id="7-2-1-reg-类型"><a href="#7-2-1-reg-类型" class="headerlink" title="7.2.1 reg 类型"></a>7.2.1 <code>reg</code> 类型</h3><ol>
<li><p>寄存器类型数</p>
<p> <code>reg</code> 类型可以定位为一个寄存器，可以定义一位或者多位，例如：</p>
 <figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">reg</span>         AB;             <span class="comment">// 定义一个名为 AB 的 1 位寄存器</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>]   ABC;            <span class="comment">// 定义一个名为 ABC 的 4 位寄存器</span></span><br></pre></td></tr></table></figure>
<p> 在多位寄存器中，可以作“位选择”或“部分选择”，例如：</p>
 <figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">ABC [<span class="number">3</span>] = <span class="number">1</span>;                <span class="comment">// 将 ABC 的第 3 位赋值为 1</span></span><br><span class="line">ABC [<span class="number">0</span>] = <span class="number">0</span>;                <span class="comment">// 将 ABC 的第 0 位赋为 0</span></span><br><span class="line">ABC [<span class="number">2</span>:<span class="number">1</span>] = <span class="number">2&#x27;b01</span>;          <span class="comment">// 将 ABC 的第 1、2 位赋值为 1 和 0</span></span><br></pre></td></tr></table></figure>
<p> 这样，整个 <code>ABC</code> 变量的值为 <code>4&#39;b1010</code>。</p>
</li>
<li><p>寄存器类型数组</p>
<p> <code>reg</code> 类型可以作为二维数组，也就是存储器，例如：</p>
 <figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] MEMABC [<span class="number">0</span>:<span class="number">7</span>];     <span class="comment">// 定义一个存储器，地址为 0~7，每个存储单元是 4 位</span></span><br></pre></td></tr></table></figure>
<p> 与一维的 <code>reg</code> 变量不同的是，存储器中的存储单元不能再做位选择或部分选择，而每个单元可以单独赋值。比如：</p>
 <figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">MEMABC[<span class="number">1</span>] = <span class="number">4&#x27;b0101</span>;        <span class="comment">// 为 MEMABC 中的第 1 个存储单元赋值 4&#x27;b0101</span></span><br></pre></td></tr></table></figure>
<p> 同时，在 Verilog 中，不存可以对整个存储器赋值的语句，必须对每个单元独立赋值。除非使用 <code>$readmemb</code> 或 <code>$readmemh</code> 系统任务从文件中读入整个或者部分存储器的数据。</p>
</li>
</ol>
<h3 id="7-2-2-integer-类型"><a href="#7-2-2-integer-类型" class="headerlink" title="7.2.2. integer 类型"></a>7.2.2. <code>integer</code> 类型</h3><p><code>integer</code> 变量通常用于高层次建模，也常用在 <code>for</code> 语句的索引中，例如：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">initial</span></span><br><span class="line"><span class="keyword">begin</span>: ACCESS</span><br><span class="line">    <span class="keyword">integer</span> i;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">7</span>; i = i + <span class="number">1</span> )        <span class="comment">// 定义一个整数变量 i</span></span><br><span class="line">        MEMABC[i] = i                       <span class="comment">// 遍历 0～7 地址</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3 id="7-2-3-其他寄存器类型"><a href="#7-2-3-其他寄存器类型" class="headerlink" title="7.2.3. 其他寄存器类型"></a>7.2.3. 其他寄存器类型</h3><p>另外，<code>time</code> 变量用于存储和处理系统时间，<code>real</code> 和 <code>realtime</code> 用来存储实数和实数时间。</p>
<h2 id="7-3-变量的物理含义"><a href="#7-3-变量的物理含义" class="headerlink" title="7.3. 变量的物理含义"></a>7.3. 变量的物理含义</h2><p>这里需要引起重视，<strong>“线网”变量可以理解为电路模块中的连线，但“寄存器”并不严格对应于电路上的存储单元</strong>，包括触发器（flip-flop）或锁存器（latch）。从纯粹语言表达的语义角度来说，寄存器类型变量的值，从一个赋值到下一个赋值被保存下来，并且在仿真过程中会保持而不会丢失。</p>
<p>实际上，从语义上来讲，在 Verilog 仿真工具对语言进行仿真的时候，<strong>寄存器类型的变量是占用仿真环境的物理内存的</strong>，这与 C 语言中的变量类似。寄存器在被赋值后，便一直保存在内存中，保持该值不变，直到再次对该寄存器变量进行赋值。而<strong>线网类型是不占用仿内存的</strong>，它的值是由当前所有驱动该线网的其他变量（可以是寄存器或线网）决定的。这是寄存器和线网最大的区别，也是当初 Verilog 的发明者定义“线网”和“寄存器”变量的根本动机。</p>
<p>在下一小节中，将引人“驱动”和“赋值”两个概念，深人探讨两种变量的含义。</p>
<h2 id="7-4-驱动和赋值"><a href="#7-4-驱动和赋值" class="headerlink" title="7.4. 驱动和赋值"></a>7.4. 驱动和赋值</h2><p>为了更清楚地描述寄存器和线网变量的概念，将以上述<a href="#JoshVerilog代码">实例代码</a>中的语句来说明。首先，引人Verilog 语言中两个重要的概念：驱动（Driving）和赋值（Assigning)。</p>
<ul>
<li><strong>线网是被驱动的，该值不被保持，在任意一个仿真步进上都需要重新计算</strong>；</li>
<li><strong>寄存器是被赋值的，且该值在仿真过程中被保持，直到下一个赋值的出现</strong>。</li>
</ul>
<p>在上述<a href="#JoshVerilog代码">实例代码</a>中，定义了一个 <code>A_xor_wire</code> 的 <code>wire</code>，它是 <code>eq0</code> 和 <code>eq1</code> 相异或的结果。采用如下描述方式：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> #<span class="number">1</span> A_xor_wire = eq0 ^ eq1;</span><br></pre></td></tr></table></figure>
<p>实际上，也可以采用如下的另一种描述方式：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @(eq0 <span class="keyword">or</span> eq1)</span><br><span class="line">    A_xor_wire = #<span class="number">1</span> eq0 ^ eq1;</span><br></pre></td></tr></table></figure>
<p>当然需要在 <code>module</code> 的声明处，将 <code>A_xor_wire</code> 首先定义成 <code>reg</code> 变量，而不是 <code>wire</code> 变量，即需要做如下定义：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">reg</span> A_xor_wire</span><br></pre></td></tr></table></figure>
<p>这两者描述的目的一样，都是一个异或门，如下图所示。</p>
<div align="center">
  <img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-28-josh-verilog-part-2/2020-11-28-josh-verilog-part-2-020-XORGate.png!700px"/>
</div>

<p>下面从语义上的角度探讨两种描述方式的不同。</p>
<p>第一种描述方式使用 <code>assign</code> 语句，Verilog 中将其称为连续赋值语句（Continously Assignment）实际上是<strong>连续驱动</strong>的过程。也就是说，在任意一个仿真时刻，当前时刻 <code>eq0</code> 和 <code>eq1</code> 相异或的结果决定了 <code>1ns</code> 以后（语句 <code>#1</code> 的延时控制）的线网变量 <code>A_xor_wire</code> 的值，<strong>不管 <code>eq0</code> 和 <code>eq1</code> 变化与否，这个驱动过程一直存在</strong>，因此称为连续驱动。（在仿真器中，线网变量是不占用仿真内存空间的。）如上<a href="#异或门">异或门图</a>中的时序所示，这个驱动过程在任意时刻都存在。</p>
<p>在第二种描述方式中使用了 <code>always</code> 语句，后面紧跟着一个敏感列表：<code>@(eq0 or eq1)</code> 因此，这个语句只有在 <code>eq0</code> 或 <code>eq1</code> 发生变化时才会执行。如上<a href="#异或门">异或门图</a>中，在时刻 2、3 和 6，该语句都将执行，将 <code>eq0</code> 和 <code>eq1</code> 赋值的结果延时 1ns 以后赋值给 <code>A_xor_wire</code> 变量。<strong>在其他时刻，<code>A_xor_wire</code> 变量必须保持</strong>。因此，<strong>从仿真语义上讲，需要一个存储单元，也可以说是寄存器，来保存 <code>A_xor_wire</code> 变量的中间值</strong>。这就是Verilog 语言的“寄存器类型”变量的来历，而这个 <code>A_xor_wire</code> 变量首先需要定义为 <code>reg</code> 类型。</p>
<p>不管采用哪种方式，所描述的是一样的组合逻辑电路。尤其是第二种描述，虽然其在语言中被定义为 reg 型，但并不是对应硬件上的触发器（flip-flop），而是 Verilog 语言仿真语义上的寄存器概念。</p>
<p>但是，在对实际电路中D触发器建模的时候，必须采用 <code>reg</code> 型的变量。下图是 D 触发器的模型。</p>
<div align="center">
  <img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-28-josh-verilog-part-2/2020-11-28-josh-verilog-part-2-030-DFlipFlop.png!300px"/>
</div>

<p>在上述<a href="#JoshVerilog代码">实例代码</a>中相应的描述如下：</p>
<figure class="highlight verilog"><figcaption><span>Josh.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">    <span class="keyword">if</span> (~rst_n)</span><br><span class="line">        A_xor_out &lt;= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        A_xor_out &lt;= A_xor_wire;</span><br></pre></td></tr></table></figure>
<p>D 触发器只对时钟和复位（置位）敏感，因此在敏感列表中，列出了 <code>clk</code> 的上升沿和 <code>rst_n</code> 的下降沿。如果 <code>rst_n</code> 为 0，就对触发器的输出复位，否则在 <code>clk</code> 的时钟上升沿发生的时候，将输人的 <code>A_xor_wire</code> 寄存到触发器的输出端 <code>A_xor_out</code>。</p>
<p>这样的代码精确地描述了一个 D 触发器的行为。这里的 <code>reg</code> 变量就对应了硬件中的 D 触发器。</p>
<p>在叙述时，为了简单起见，常常将“驱动”和“赋值”都统一说成是赋值，但是一定要清楚其中的本质。</p>
<h1 id="8-参数"><a href="#8-参数" class="headerlink" title="8. 参数"></a>8. 参数</h1><p>参数是一种常量，通常出现在 <code>module</code> 内部。它常常被用作定义状态机的状态、数据位宽和延时大小等等。例如：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">parameter</span> and_delay = <span class="number">2</span>；</span><br><span class="line"><span class="keyword">parameter</span> xor_delay = <span class="number">4</span>；</span><br></pre></td></tr></table></figure>
<p><strong>参数的值可以在编译时被改变</strong>，因此它又<strong>经常被用于一些参数可调的模块中</strong>，让用户在实例化模块时，根据需要配置参数。</p>
<p>前面介绍的 <code>`define</code> 是一种全局的定义，而 <code>parameter</code> 是出现在模块内部的<strong>局部定义</strong>，而且可以被<strong>灵活改变</strong>，这是 <code>parameter</code> 的一个重要特征。</p>
<p>在<a href="https://josh-gao.blog.csdn.net/article/details/105262549#42__865">《Part 3——描述方式和设计层次》的 4.2 小节</a>中会详细探讨改变模块参数的方法。</p>
<h1 id="9-Verilog-中的并发与顺序"><a href="#9-Verilog-中的并发与顺序" class="headerlink" title="9. Verilog 中的并发与顺序"></a>9. Verilog 中的并发与顺序</h1><p>并行概念是硬件中的一个非常重要的概念，特别是初学者或软件工程师们需要重点理解。</p>
<p>与在处理器上运行的软件不同的是，<strong>硬件电路之间的工作是并行的</strong>。</p>
<p>为了描述硬件的并行性，Verilog 语言本身就具有并发的特性。在 Verilog 语言的 <code>module</code> 中，所有的描述语句（包括连续赋值语句，行为语句块：<code>always</code> 和 <code>initial</code>，模块实例化等）之间都是并行发生的。任何功能描述语句，在 Verilog 的 module 中的顺序都不重要。</p>
<p>但是，在语句块（<code>always</code> 和 <code>initial</code>）内部，则可以存在两种语句组：</p>
<ul>
<li><code>begin ... end</code>：顺序语句组；</li>
<li><code>fork ... join</code>：并行语句组。</li>
</ul>
<p>在 <code>begin ... end</code> 中存在的语句，按照 Veilog 的语义，应该是顺序执行的。而在 <code>fork ... join</code> 中的语句，则是并行执行的。</p>
<p>相比较顺序运行的事物，并行的事物比较难以理解和建模。同时，用于仿真的计算机是串行执行的，而 Verilog 语言本身的语义是用计算机进行模拟的语义，是用一种串行的语义来模拟并行的硬件。</p>
<p>Verilog 仿真器用来模拟硬件的并行行为的方式类似于软件中的多任务操作系统，在某个时刻只能执行一个任务，这样，不同的任务之间看起来是并行执行的。</p>
<p>后续将会重点介绍 Verilog 语言中的这一并行特性，同时阐述 Verilog 的高级仿真原理，希望能帮助大家领会 Verilog 的语义精髓。</p>
<h1 id="10-操作数、操作符和表达式"><a href="#10-操作数、操作符和表达式" class="headerlink" title="10. 操作数、操作符和表达式"></a>10. 操作数、操作符和表达式</h1><h2 id="10-1-操作符"><a href="#10-1-操作符" class="headerlink" title="10.1. 操作符"></a>10.1. 操作符</h2><p>操作符是操作数之间的运算符号。在介绍操作数之前，先来看看 Verilog 中的各种操作符。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">操作符</th>
<th style="text-align:left">含义</th>
<th style="text-align:left">操作符</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>+</code></td>
<td style="text-align:left">一元加</td>
<td style="text-align:left"><code>&gt;&gt;</code></td>
<td style="text-align:left">右移</td>
</tr>
<tr>
<td style="text-align:left"><code>-</code></td>
<td style="text-align:left">一元减</td>
<td style="text-align:left"><code>&lt;</code></td>
<td style="text-align:left">小于</td>
</tr>
<tr>
<td style="text-align:left"><code>!</code></td>
<td style="text-align:left">一元逻辑非</td>
<td style="text-align:left"><code>&lt;=</code></td>
<td style="text-align:left">小于等于</td>
</tr>
<tr>
<td style="text-align:left"><code>~</code></td>
<td style="text-align:left">一元按位求反</td>
<td style="text-align:left"><code>&gt;</code></td>
<td style="text-align:left">大于</td>
</tr>
<tr>
<td style="text-align:left"><code>&amp;</code></td>
<td style="text-align:left">归约与</td>
<td style="text-align:left"><code>&gt;=</code></td>
<td style="text-align:left">大于等于</td>
</tr>
<tr>
<td style="text-align:left"><code>~&amp;</code></td>
<td style="text-align:left">归约与非</td>
<td style="text-align:left"><code>==</code></td>
<td style="text-align:left">逻辑相等</td>
</tr>
<tr>
<td style="text-align:left"><code>^</code></td>
<td style="text-align:left">归约异或</td>
<td style="text-align:left"><code>!=</code></td>
<td style="text-align:left">逻辑不等</td>
</tr>
<tr>
<td style="text-align:left"><code>^~</code> 或 <code>~^</code></td>
<td style="text-align:left">归约异或非</td>
<td style="text-align:left"><code>===</code></td>
<td style="text-align:left">全等</td>
</tr>
<tr>
<td style="text-align:left"><code>&#124;</code></td>
<td style="text-align:left">归约或</td>
<td style="text-align:left"><code>!==</code></td>
<td style="text-align:left">非全等</td>
</tr>
<tr>
<td style="text-align:left"><code>~&#124;</code></td>
<td style="text-align:left">归约或非</td>
<td style="text-align:left"><code>&amp;</code></td>
<td style="text-align:left">按位与</td>
</tr>
<tr>
<td style="text-align:left"><code>*</code></td>
<td style="text-align:left">乘</td>
<td style="text-align:left"><code>^</code></td>
<td style="text-align:left">按位异或</td>
</tr>
<tr>
<td style="text-align:left"><code>/</code></td>
<td style="text-align:left">除以</td>
<td style="text-align:left"><code>^~</code> 或 <code>~^</code></td>
<td style="text-align:left">按位异或非</td>
</tr>
<tr>
<td style="text-align:left"><code>%</code></td>
<td style="text-align:left">取模</td>
<td style="text-align:left"><code>&#124;</code></td>
<td style="text-align:left">按位或</td>
</tr>
<tr>
<td style="text-align:left"><code>+</code></td>
<td style="text-align:left">二元加</td>
<td style="text-align:left"><code>&amp;&amp;</code></td>
<td style="text-align:left">逻辑与</td>
</tr>
<tr>
<td style="text-align:left"><code>-</code></td>
<td style="text-align:left">二元减</td>
<td style="text-align:left"><code>&#124;&gt;&#124;</code></td>
<td style="text-align:left">逻辑或</td>
</tr>
<tr>
<td style="text-align:left"><code>&lt;&lt;</code></td>
<td style="text-align:left">左移</td>
<td style="text-align:left"><code>? :</code></td>
<td style="text-align:left">条件操作符</td>
</tr>
</tbody>
</table>
</div>
<p>其中，一元操作表示仅有一个操作数，二元操作表示有两个操作数。归约操作也是只有一个操作数，它是该操作数中的所有位之间的计算。</p>
<h3 id="10-1-1-算术操作符"><a href="#10-1-1-算术操作符" class="headerlink" title="10.1.1. 算术操作符"></a>10.1.1. 算术操作符</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">操作符</th>
<th style="text-align:center">表达式</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>+</code></td>
<td style="text-align:center"><code>m + n</code></td>
<td style="text-align:center">将 <code>n</code> 与 <code>m</code> 相加</td>
</tr>
<tr>
<td style="text-align:center"><code>-</code></td>
<td style="text-align:center"><code>m - n</code></td>
<td style="text-align:center">将 <code>m</code> 减去 <code>n</code></td>
</tr>
<tr>
<td style="text-align:center"><code>-</code></td>
<td style="text-align:center"><code>-m</code></td>
<td style="text-align:center">将 <code>m</code> 取反（二进制补码）</td>
</tr>
<tr>
<td style="text-align:center"><code>*</code></td>
<td style="text-align:center"><code>m * n</code></td>
<td style="text-align:center">将 <code>m</code> 与 <code>n</code> 相乘</td>
</tr>
<tr>
<td style="text-align:center"><code>/</code></td>
<td style="text-align:center"><code>m / n</code></td>
<td style="text-align:center">将 <code>m</code> 除以 <code>n</code></td>
</tr>
<tr>
<td style="text-align:center"><code>%</code></td>
<td style="text-align:center"><code>m % n</code></td>
<td style="text-align:center">对 <code>m / n</code> 求模</td>
</tr>
</tbody>
</table>
</div>
<h3 id="10-1-2-按位操作符"><a href="#10-1-2-按位操作符" class="headerlink" title="10.1.2. 按位操作符"></a>10.1.2. 按位操作符</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">操作符</th>
<th style="text-align:center">表达式</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>~</code></td>
<td style="text-align:center"><code>~m</code></td>
<td style="text-align:center">将 <code>m</code> 的每个位取反</td>
</tr>
<tr>
<td style="text-align:center"><code>&amp;</code></td>
<td style="text-align:center"><code>m &amp; n</code></td>
<td style="text-align:center">将 <code>m</code> 的每个位与 <code>n</code> 的相应位相与</td>
</tr>
<tr>
<td style="text-align:center"><code>&#124;</code></td>
<td style="text-align:center"><code>m &#124; n</code></td>
<td style="text-align:center">将 <code>m</code> 的每个位与 <code>n</code> 的相应位相或</td>
</tr>
<tr>
<td style="text-align:center"><code>^</code></td>
<td style="text-align:center"><code>m ^ n</code></td>
<td style="text-align:center">将 <code>m</code> 的每个位与 <code>n</code> 的相应位相异或</td>
</tr>
<tr>
<td style="text-align:center"><code>~^</code><br><code>^~</code></td>
<td style="text-align:center"><code>m ~^ n</code><br><code>m ^~ n</code></td>
<td style="text-align:center">将 <code>m</code> 的每个位与 <code>n</code> 的相应位相异或非</td>
</tr>
</tbody>
</table>
</div>
<h3 id="10-1-3-归约操作符"><a href="#10-1-3-归约操作符" class="headerlink" title="10.1.3. 归约操作符"></a>10.1.3. 归约操作符</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">操作符</th>
<th style="text-align:center">表达式</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>&amp;</code></td>
<td style="text-align:center"><code>&amp;m</code></td>
<td style="text-align:center">将 <code>m</code> 中的所有位相与（1位结果）</td>
</tr>
<tr>
<td style="text-align:center"><code>~&amp;</code></td>
<td style="text-align:center"><code>~&amp;m</code></td>
<td style="text-align:center">将 <code>m</code> 中的所有位相与非（1位结果）</td>
</tr>
<tr>
<td style="text-align:center"><code>&#124;</code></td>
<td style="text-align:center"><code>&#124;m</code></td>
<td style="text-align:center">将 <code>m</code> 中的所有位相或（1位结果）</td>
</tr>
<tr>
<td style="text-align:center"><code>~&#124;</code></td>
<td style="text-align:center"><code>~&#124;m</code></td>
<td style="text-align:center">将 <code>m</code> 中的所有位或非（1位结果）</td>
</tr>
<tr>
<td style="text-align:center"><code>^</code></td>
<td style="text-align:center"><code>^m</code></td>
<td style="text-align:center">将 <code>m</code> 中的所有位异或（1位结果）</td>
</tr>
<tr>
<td style="text-align:center"><code>~^</code><br><code>^~</code></td>
<td style="text-align:center"><code>~^m</code><br><code>^~m</code></td>
<td style="text-align:center">将 <code>m</code> 中的所有位相异或非（1位结果）</td>
</tr>
</tbody>
</table>
</div>
<h3 id="10-1-4-逻辑操作符"><a href="#10-1-4-逻辑操作符" class="headerlink" title="10.1.4. 逻辑操作符"></a>10.1.4. 逻辑操作符</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">操作符</th>
<th style="text-align:center">表达式</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>!</code></td>
<td style="text-align:center"><code>!m</code></td>
<td style="text-align:center"><code>m</code> 是否不为真？（1 位 真/假结果）</td>
</tr>
<tr>
<td style="text-align:center"><code>&amp;&amp;</code></td>
<td style="text-align:center"><code>m &amp;&amp; n</code></td>
<td style="text-align:center"><code>m</code> 和 <code>n</code> 是否都为真？（1位 真/假结果）</td>
</tr>
<tr>
<td style="text-align:center"><code>&#124;&#124;</code></td>
<td style="text-align:center"><code>m &#124;&#124; n</code></td>
<td style="text-align:center"><code>m</code> 或 <code>n</code> 是否为真？（1位 真/假结果）</td>
</tr>
</tbody>
</table>
</div>
<h3 id="10-1-5-相等操作符"><a href="#10-1-5-相等操作符" class="headerlink" title="10.1.5. 相等操作符"></a>10.1.5. 相等操作符</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">操作符</th>
<th style="text-align:center">表达式</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>==</code></td>
<td style="text-align:center"><code>m == n</code></td>
<td style="text-align:center"><code>m</code> 和 <code>n</code> 相等吗？（1 位 正确/错误结果）</td>
</tr>
<tr>
<td style="text-align:center"><code>!=</code></td>
<td style="text-align:center"><code>m != n</code></td>
<td style="text-align:center"><code>m</code> 和 <code>n</code> 不等吗？（1 位 正确/错误结果）</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>相等操作符仅比较逻辑 1 和 0。</p>
</blockquote>
<h3 id="10-1-6-全等操作符"><a href="#10-1-6-全等操作符" class="headerlink" title="10.1.6. 全等操作符"></a>10.1.6. 全等操作符</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">操作符</th>
<th style="text-align:center">表达式</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>===</code></td>
<td style="text-align:center"><code>m === n</code></td>
<td style="text-align:center"><code>m</code> 和 <code>n</code> 全等吗？（1 位 正确/错误结果）</td>
</tr>
<tr>
<td style="text-align:center"><code>!==</code></td>
<td style="text-align:center"><code>m !== n</code></td>
<td style="text-align:center"><code>m</code> 和 <code>n</code> 不全等吗？（1 位 正确/错误结果）</td>
</tr>
</tbody>
</table>
</div>
<h3 id="10-1-7-关系操作符"><a href="#10-1-7-关系操作符" class="headerlink" title="10.1.7. 关系操作符"></a>10.1.7. 关系操作符</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">操作符</th>
<th style="text-align:center">表达式</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>&lt;</code></td>
<td style="text-align:center"><code>m &lt; n</code></td>
<td style="text-align:center"><code>m</code> 小于 <code>n</code> ？（1 位 正确/错误结果）</td>
</tr>
<tr>
<td style="text-align:center"><code>&gt;</code></td>
<td style="text-align:center"><code>m &gt; n</code></td>
<td style="text-align:center"><code>m</code> 大于 <code>n</code> ？（1 位 正确/错误结果）</td>
</tr>
<tr>
<td style="text-align:center"><code>&lt;=</code></td>
<td style="text-align:center"><code>m &lt;= n</code></td>
<td style="text-align:center"><code>m</code> 小于等于 <code>n</code> ？（1 位 正确/错误结果）</td>
</tr>
<tr>
<td style="text-align:center"><code>&gt;=</code></td>
<td style="text-align:center"><code>m &gt;= n</code></td>
<td style="text-align:center"><code>m</code> 大于等于 <code>n</code> ？（1 位 正确/错误结果）</td>
</tr>
</tbody>
</table>
</div>
<h3 id="10-1-8-逻辑移位操作符"><a href="#10-1-8-逻辑移位操作符" class="headerlink" title="10.1.8. 逻辑移位操作符"></a>10.1.8. 逻辑移位操作符</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">操作符</th>
<th style="text-align:center">表达式</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>&lt;&lt;</code></td>
<td style="text-align:center"><code>m &lt;&lt; n</code></td>
<td style="text-align:center">将 <code>m</code> 左移 <code>n</code> 位</td>
</tr>
<tr>
<td style="text-align:center"><code>&gt;&gt;</code></td>
<td style="text-align:center"><code>m &gt;&gt; n</code></td>
<td style="text-align:center">将 <code>m</code> 右移 <code>n</code> 位</td>
</tr>
</tbody>
</table>
</div>
<h3 id="10-1-9-条件操作符"><a href="#10-1-9-条件操作符" class="headerlink" title="10.1.9. 条件操作符"></a>10.1.9. 条件操作符</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">操作符</th>
<th style="text-align:center">表达式</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>? :</code></td>
<td style="text-align:center"><code>sel ? m : n</code></td>
<td style="text-align:center">如果 <code>sel</code> 为真，选择 <code>m</code>，否则选择 <code>n</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="10-1-10-连接复制操作符"><a href="#10-1-10-连接复制操作符" class="headerlink" title="10.1.10. 连接复制操作符"></a>10.1.10. 连接复制操作符</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">操作符</th>
<th style="text-align:center">表达式</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>&#123; &#125;</code></td>
<td style="text-align:center"><code>&#123;m,n&#125;</code></td>
<td style="text-align:center">将 <code>m</code> 和 <code>n</code> 连接起来，产生更大的向量</td>
</tr>
<tr>
<td style="text-align:center"><code>&#123;&#123; &#125;&#125;</code></td>
<td style="text-align:center"><code>&#123;n&#123;m&#125;&#125;</code></td>
<td style="text-align:center">将 <code>m</code> 重复 <code>n</code> 次</td>
</tr>
</tbody>
</table>
</div>
<p>在以上描述的操作符之间有优先级之分，下表体现了不同的操作数优先级由高到低排列。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">操作符</th>
<th style="text-align:center">优先级</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>!</code>、<code>~</code>、<code>+</code>、<code>-</code>（一元）</td>
<td style="text-align:center">最高优先级</td>
</tr>
<tr>
<td style="text-align:center"><code>*</code>、<code>/</code>、<code>%</code></td>
<td style="text-align:center">$\vdots$</td>
</tr>
<tr>
<td style="text-align:center"><code>+</code>、<code>-</code>（二元）</td>
<td style="text-align:center">$\vdots$</td>
</tr>
<tr>
<td style="text-align:center"><code>&lt;&lt;</code>、<code>&gt;&gt;</code></td>
<td style="text-align:center">$\vdots$</td>
</tr>
<tr>
<td style="text-align:center"><code>&lt;</code>、<code>&lt;=</code>、<code>&gt;</code>、<code>&gt;=</code></td>
<td style="text-align:center">$\vdots$</td>
</tr>
<tr>
<td style="text-align:center"><code>==</code>、<code>!=</code>、<code>===</code>、<code>!==</code></td>
<td style="text-align:center">$\vdots$</td>
</tr>
<tr>
<td style="text-align:center"><code>&amp;</code>、<code>~&amp;</code></td>
<td style="text-align:center">$\vdots$</td>
</tr>
<tr>
<td style="text-align:center"><code>^</code>、<code>~^</code></td>
<td style="text-align:center">$\vdots$</td>
</tr>
<tr>
<td style="text-align:center"><code>&#124;</code>、<code>~&#124;</code></td>
<td style="text-align:center">$\vdots$</td>
</tr>
<tr>
<td style="text-align:center"><code>&amp;&amp;</code></td>
<td style="text-align:center">$\vdots$</td>
</tr>
<tr>
<td style="text-align:center"><code>&#124;&#124;</code></td>
<td style="text-align:center">$\vdots$</td>
</tr>
<tr>
<td style="text-align:center"><code>? :</code></td>
<td style="text-align:center">最低优先级</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>例如：<code>A + B &amp; C + D</code> 就表示 <code>(A + B) &amp; (C + D)</code>，而不是 <code>A + (B &amp; C) + D</code>。</p>
</blockquote>
<h2 id="10-2-二进制数值"><a href="#10-2-二进制数值" class="headerlink" title="10.2. 二进制数值"></a>10.2. 二进制数值</h2><p>在讨论操作数之前，先来看看二进制数中如何表示有符号数和无符号数。</p>
<p>例如，在一个 6 位二进制整形变量中，</p>
<ul>
<li>无符号数能表示的范围是：<code>0~63</code>；</li>
<li>有符号数采用二进制补码（Two’s complement）方式，能表示的范围是：<code>-32～31</code>。其中二进制的最高位表示符号，最高位为 1 表示该数是负数，为 0 表示该数是正数。</li>
</ul>
<p>这里对具体的编码方式不过多介绍，但学过数字电路的同学必须掌握二进制中无符号数和有符号数的表示方法，以及计算的机制。</p>
<h2 id="10-3-操作数"><a href="#10-3-操作数" class="headerlink" title="10.3. 操作数"></a>10.3. 操作数</h2><p>在 Verilog 语言中，操作数可以是如下几种：</p>
<ul>
<li>常数；</li>
<li>参数；</li>
<li>线网；</li>
<li>寄存器；</li>
<li>向量的位选择;</li>
<li>向量的部分选择；</li>
<li>存储器单元；</li>
<li>系统函数或用户自定义函数调用的返回值。</li>
</ul>
<p>在选择操作数时，需要用户尤其注意的是操作数的极性。通常在 Verilog 中，无符号数用以下3种形式存在：</p>
<ul>
<li>线网变量；</li>
<li>一般寄存器变量；</li>
<li>基数格式表示形式的整数常数。</li>
</ul>
<p>而有符号数有：</p>
<ul>
<li>整型寄存器变量；</li>
<li>十进制形式的整型常量。</li>
</ul>
<p>首先讨论常量，如果采用基数格式表示一个数，例如：<code>-4&#39;d12</code>，其二进制表示方式是：<code>1111_1111_1111_1111_1111_1111_1111_0100</code>（<code>1100</code> 的补码），由于基数格式的整数为无符号数，因此<code>-4&#39;d12</code> 的值就是十进制的 <code>429496728</code>。</p>
<p>当采用普通十进制数来表示 <code>-12</code> 的时候，虽然它的二进制表示方式与上面的数相同，但 <code>-12</code> 是一个有符号数，它在运算时就表示十进制的 <code>-12</code>。</p>
<p>这里定义两个变量，一个是无符号的 <code>reg</code> 型，另一个是有符号的整型：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">reg</span> [<span class="number">4</span>:<span class="number">0</span>] Opreg;            <span class="comment">// 一个 5 位的 reg 型，存储无符号数</span></span><br><span class="line"><span class="keyword">integer</span> Opint;              <span class="comment">// 一个 32 位的 integer 型，存储有符号数</span></span><br></pre></td></tr></table></figure>
<p>做如下运算：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">Opreg = -<span class="number">4</span>d&#x27;<span class="number">12</span>/<span class="number">4</span>;           <span class="comment">// Opreg 被赋值 29，(-4d&#x27;12/4)的最低5位</span></span><br><span class="line">Opint = -<span class="number">4</span>d&#x27;<span class="number">12</span>/<span class="number">4</span>;           <span class="comment">// Opint 被赋值为 1073741821，共 32 位</span></span><br><span class="line">Opreg = -<span class="number">12</span>/<span class="number">4</span>;              <span class="comment">// Opreg 被赋值29，(-12/4)的最低5位</span></span><br><span class="line">Opint = -<span class="number">12</span>/<span class="number">4</span>;              <span class="comment">// Opint 被赋值为 -3，采用 32 位的二进制补码表示方式</span></span><br></pre></td></tr></table></figure>
<p>通过以上的计算结果可以看出，无符号数和有符号数的算术运算非常不同，用户在设计常量和变量并用它们计算的时候，一定要搞清楚它们中哪些表示有符号数，哪些表示无符号数，这很重要。</p>
<h1 id="11-系统任务和系统函数"><a href="#11-系统任务和系统函数" class="headerlink" title="11. 系统任务和系统函数"></a>11. 系统任务和系统函数</h1><p>在 Verilog 语中，预先定义了一些任务和函数，用于完成一些特殊的功能，它们被称为系统任务和系统函数。Verilog 能提供的系统任务和系统函数类型如下：</p>
<ul>
<li>显示任务（display task）；</li>
<li>文件输人/输出任务（file I/O task）；</li>
<li>时间标度任务（timescale task）；</li>
<li>拟控制任务（simulation control task）；</li>
<li>时序验证任务（timing check task）；</li>
<li>PLA建模任务（PLA modeling task）；</li>
<li>机建模任务（stochastic modeling task）；</li>
<li>实数变换函数（conversion functions for real）；</li>
<li>概率分布数（probabilistic distribution function)。</li>
</ul>
<p>由于 Verilog 的系统任务和函数种类很多，在这里，只重点介绍一些常用的内容，希望通过介绍可以能让大家迅速掌握，灵活使用。相信通过以下的介绍，大家可以举一反三，通过参考 Verilog 的语法文献，迅速查找到需要的系统任务和函数，完成需要的功能。</p>
<h2 id="11-1-显示任务"><a href="#11-1-显示任务" class="headerlink" title="11.1. 显示任务"></a>11.1. 显示任务</h2><p><code>$display</code> 是显示任务，通常用来显示变量值、字符串，以及仿真时间等信息。</p>
<p>在 <a href="#JoshVerilog代码">JoshVerilog 模块</a>中使用了这样的系统任务。</p>
<figure class="highlight verilog"><figcaption><span>Josh.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="built_in">$display</span> (<span class="string">&quot;At time %t-&quot;</span>, <span class="built_in">$time</span>, <span class="string">&quot;eq0 = 1&quot;</span>);     <span class="comment">// 显示时间</span></span><br></pre></td></tr></table></figure>
<p>其中，双引号中的是字符串，<code>％t</code> 是时间格式。<code>$time</code> 是产生模拟时间的系统函数，它的返回值显示在字符串中的 <code>％t</code> 位置。</p>
<p>再如：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$display</span>(<span class="string">&quot;The value of ABC is %d&quot;</span>, ABC);        <span class="comment">// 显示当前 ABC 变量的值</span></span><br></pre></td></tr></table></figure>
<p>其中，<code>%d</code> 表示十进制数。<code>ABC</code> 的值显示在字符串中的 <code>%d</code> 位置。</p>
<h2 id="11-2-文件输入出任务"><a href="#11-2-文件输入出任务" class="headerlink" title="11.2. 文件输入出任务"></a>11.2. 文件输入出任务</h2><p>系统函数 <code>$fopen</code> 用于打开一个文件，并返回一个整数的文件指针。然后，<code>$fdisplay</code> 就可以使用这个文件指针向文件中写人信息。写完后，则可以使用 <code>$fclose</code> 这个系统关闭这个文件。例如：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span> Write_Out_File;                     <span class="comment">// 定义一个文件指针</span></span><br><span class="line">Write_Out_File = <span class="built_in">$fopen</span>(<span class="string">&quot;Write_Out_File.txt&quot;</span>);</span><br><span class="line"><span class="built_in">$fdisplay</span>(Write_Out_File, <span class="string">&quot;@ %h\n%h&quot;</span>, Mpi_addr, Data_in);</span><br><span class="line"><span class="built_in">$fclose</span>(Write_Out_File);</span><br></pre></td></tr></table></figure>
<p>以上的语法，将 <code>Mpi_addr</code> 和 <code>Data_in</code> 分别显示在 <code>@ %h\n%h</code> 中两个 <code>%h</code> 的位置，写入 <code>Write_Out_File</code> 指针所指的文件 <code>Write_Out_File.txt</code> 中。</p>
<p>用户可以通过 <code>$readmemb</code> 或者 <code>$readmemh</code> 来从文件中读人数据，但是这个文件中的数据格式是一定的。例如：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] DataSource [<span class="number">0</span>:<span class="number">47</span>];</span><br><span class="line"><span class="built_in">$readmemh</span> (<span class="string">&quot;Read_In_File.txt, DataSource);</span></span><br></pre></td></tr></table></figure>
<p>就是将 <code>Read_In_FiIe</code> 文件中数据读人到 <code>DataSource</code> 数组中，然后就可以直接使用。</p>
<p><code>Read_In_File</code> 数据文件的格式，可以参考如下写法：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">@<span class="number">2</span>f</span><br><span class="line"><span class="number">24</span></span><br><span class="line">@<span class="number">2</span>e</span><br><span class="line"><span class="number">81</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>其中，<code>@2f</code> 表示地址，是十六进制；<code>24</code> 表示该地址的数据，以此类推。</p>
<h2 id="11-3-其他系统任务和数"><a href="#11-3-其他系统任务和数" class="headerlink" title="11.3. 其他系统任务和数"></a>11.3. 其他系统任务和数</h2><ol>
<li><p>仿真控制任务</p>
<p> Verilog 中有一些仿真控制任务，例如：<br> <code>$finish</code> 表示使仿真器退出。<br> <code>$stop</code> 使仿真挂起。</p>
</li>
<li><p>时序验证任务和仿真时间函数</p>
<p> Verilog 仿真器也可以检查设计时序，以及返回当前仿真时间，例如：<br> <code>$setup</code> 系统任务用来检查建立时间。<br> <code>$hold</code> 系统任务用来检查保持时间。<br> <code>$time</code> 系统函数用来返回一个64位的模拟时间。</p>
</li>
<li><p>概率分布函数</p>
<p> <code>$random</code> 系统函数可以用来返回一个32位的有符号整型随机数。</p>
</li>
</ol>
<p>需要注意的是，<strong>系统任务/函数只可以在 Verilog 仿真器中运行，仅仅对代码仿真有意义</strong>，综合和布线工具将忽略所有的系统任务和函数。</p>
<p>除了系统任务和系统函数之外，VeriIog还允许用户自己定义任务和函数。关于自定义的任务和函数的特点及使用方法，请参考后续的相关内容。</p>
<hr>
<p>在本篇笔记中，以一个实例为出发点，系统介绍了 Verilog 的基本语法，相信能为大家深入学习 Verilog 语言打下坚实的基础。</p>
]]></content>
      <categories>
        <category>Verilog</category>
        <category>Josh 的学习笔记</category>
        <category>Verilog</category>
        <category>Verilog 语法</category>
      </categories>
      <tags>
        <tag>Verilog</tag>
        <tag>HDL</tag>
        <tag>自顶向下</tag>
        <tag>自底向上</tag>
        <tag>Verilog 语法</tag>
      </tags>
  </entry>
  <entry>
    <title>Josh 的学习笔记之 Verilog（Part 3 —— 描述方式和设计层次）</title>
    <url>/posts/fd117896.html</url>
    <content><![CDATA[<p>Verilog 语言可以用多种方式来描述硬件，同时，使用这些描述方式又可以在多个抽象层次上设计硬件。这是 Verilog 语言的重要特征。本文主要侧重于阐述 Verilog 语言的描述方法和设计层次。</p>
<h1 id="1-描述方式"><a href="#1-描述方式" class="headerlink" title="1. 描述方式"></a>1. 描述方式</h1><p>在<a href="https://josh-gao.top/posts/fd2ca242.html#3-%E7%A7%8D%E6%8F%8F%E8%BF%B0%E6%96%B9%E6%B3%95">《Part 2——Verilog 语言基础》</a>中己经介绍过，Verilog 语言有 3 种最基本的描述方式．</p>
<ul>
<li>数据流描述，采用 <code>assign</code> 连续赋值语句；</li>
<li>行为描述，使用 <code>always</code> 语句或 <code>initial</code> 语句块中的过程赋值语句；</li>
<li>结构化描述，实例化已有的功能模块或原语。</li>
</ul>
<p>下面分别说明这几种描述方式。</p>
<a id="more"></a>
<h1 id="2-数据流描述"><a href="#2-数据流描述" class="headerlink" title="2. 数据流描述"></a>2. 数据流描述</h1><h2 id="2-1-数据流"><a href="#2-1-数据流" class="headerlink" title="2.1. 数据流"></a>2.1. 数据流</h2><p>在数字电路中，信号经过组合逻辑时有点类似于数据的流动：信号从输入流向输出，而信号不会在其中存储。当输入发生变化时，总会在一定时间以后体现在输出端。</p>
<p>同样，可以模拟数字电路的这一特性，对其进行建模。通常将这种建模方式称为数据流建模。</p>
<p>数据流描述最基本的语句是 <code>assign</code> 连续赋值语句。</p>
<h2 id="2-2-连续赋值语句"><a href="#2-2-连续赋值语句" class="headerlink" title="2.2. 连续赋值语句"></a>2.2. 连续赋值语句</h2><div align="center">
  <img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-30-josh-verilog-part-3/2020-11-30-josh-verilog-part-3-010-XORGate.png!sign"/>
</div>

<p>上图中的电路模型可以用如下的语句来描述：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> #<span class="number">1</span> A_xor_wire = eq0 ^ eq1;</span><br></pre></td></tr></table></figure>
<p>在任意一个时刻，<code>A_xor_wire</code> 线网的值是由 <code>eq0</code> 和 <code>eq1</code> 决定的，也可以说是由它们驱动的。</p>
<h3 id="2-2-1-连续赋值语句的特点"><a href="#2-2-1-连续赋值语句的特点" class="headerlink" title="2.2.1. 连续赋值语句的特点"></a>2.2.1. 连续赋值语句的特点</h3><ol>
<li><p><strong>连续驱动</strong></p>
<p> 在 <a href="https://josh-gao.top/posts/fd2ca242.html#%E5%AF%84%E5%AD%98%E5%99%A8%E7%B1%BB%E5%9E%8B">Part 2 的 7.2 驱动和赋值</a>部分，已经解释了驱动和赋值之间的微妙区别。</p>
<p> 连续赋值语句是连续驱动的。也就是说，任何时刻输人的任何变化都将导致该语句的重新计算。</p>
</li>
<li><p><strong>只有线网类型能在 <code>assign</code> 中赋值</strong></p>
<p> 由于仿真器中不会存储连续赋值语句中被赋值的变量值，因此该变量是线网类型（Net），不能是寄存器类型。需要记住，只有线网类型的变量才可以在 <code>assign</code> 语句中被赋值。</p>
<p> 另外，线网类型的变量可以被多重驱动，也就是说，可以在多个连续赋值语句中驱动同一个线网。在<a href="#drive">2.4 驱动源线网</a>中将进一步介绍。但是，寄存器变量就不同了，它不能被不同的行为进程（例如 <code>always</code> 语句块）驱动。</p>
</li>
<li><p><strong>使用 <code>assign</code> 对组合逻辑建模</strong></p>
<p> 通常建议使用 <code>assign</code> 对组合逻辑建模。因为 <code>assign</code> 语句的连续驱动特点与组合逻辑的行为非常相似。而且，在 <code>assign</code> 语句中加延时可以非常精确的模拟组合逻辑的惯性延时。</p>
</li>
<li><p><strong>并行性</strong></p>
<p> <code>assign</code> 语句和行为语句块（<code>always</code> 和 <code>initial</code>)、其他连续赋值语句、门级模型之间是并行的。一个连续赋值语句是一个独立的进程，进程之间是并发，同时也是交织的。</p>
</li>
</ol>
<h3 id="2-2-2-实例"><a href="#2-2-2-实例" class="headerlink" title="2.2.2. 实例"></a>2.2.2. 实例</h3><div align="center">
  <img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-30-josh-verilog-part-3/2020-11-30-josh-verilog-part-3-020-FullAdder.png!sign"/>
</div>

<p>在上中，用两个半加器和一个或门组成一个全加器，这里将使用连续赋值语句描述这个电路。代码如下。</p>
<p><a name="半加器代码"></a></p>
<figure class="highlight verilog"><figcaption><span>HalfAdd.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> HalfAdd(X, Y, sum, C_out);</span><br><span class="line"></span><br><span class="line"><span class="comment">// IO端口声明</span></span><br><span class="line"><span class="keyword">input</span> X;</span><br><span class="line"><span class="keyword">input</span> Y;</span><br><span class="line"><span class="keyword">output</span> sum;</span><br><span class="line"><span class="keyword">output</span> C_out;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> sum = X ^ Y;</span><br><span class="line"><span class="keyword">assign</span> C_out = X &amp; Y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span> </span><br></pre></td></tr></table></figure>
<figure class="highlight verilog"><figcaption><span>FullAdd.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> FullAdd(X, Y, C_in, sum, C_out);</span><br><span class="line"></span><br><span class="line"><span class="comment">// IO端口声明</span></span><br><span class="line"><span class="keyword">input</span> X;</span><br><span class="line"><span class="keyword">input</span> Y;</span><br><span class="line"><span class="keyword">input</span> C_in;</span><br><span class="line"><span class="keyword">output</span> sum;</span><br><span class="line"><span class="keyword">output</span> C_out;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线网类型用于连接</span></span><br><span class="line"><span class="keyword">wire</span> HalfAdd_A_sum;</span><br><span class="line"><span class="keyword">wire</span> HalfAdd_A_Cout;</span><br><span class="line"><span class="keyword">wire</span> HalfAdd_B_Cout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> C_out = HalfAdd_A_Cout | HalfAdd_B_Cout;</span><br><span class="line"></span><br><span class="line">HalfAdd u_HalfAdd_A(</span><br><span class="line">    <span class="variable">.X</span>      (C_in),</span><br><span class="line">    <span class="variable">.Y</span>      (Y),</span><br><span class="line">    <span class="variable">.s</span>      (HalfAdd_A_sum),</span><br><span class="line">    <span class="variable">.C_out</span>  (HalfAdd_A_Cout)</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">HalfAdd u_HalfAdd_B(</span><br><span class="line">    <span class="variable">.X</span>      (C_in),</span><br><span class="line">    <span class="variable">.Y</span>      (HalfAdd_A_sum),</span><br><span class="line">    <span class="variable">.s</span>      (sum),</span><br><span class="line">    <span class="variable">.C_out</span>  (HalfAdd_B_Cout)</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line"><span class="keyword">endmodule</span> </span><br></pre></td></tr></table></figure>
<p>在 <code>HalfAdd</code> 模块中，两个 <code>assign</code> 语句之间是<strong>完全并行独立执行</strong>的，它们的顺序与逻辑功能无关。同样，<code>FullAdd</code> 模块中，两个 <code>HalfAdd</code> 的实例和或门的 <code>assign</code> 语句之间的关系也是独立的。</p>
<h2 id="2-3-延时"><a href="#2-3-延时" class="headerlink" title="2.3. 延时"></a>2.3. 延时</h2><p>在连续赋值语句中，可以对电路的延时进行建模。当然，也可以没有延时。比如：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> #<span class="number">1</span> A_xor_wire = eq0 ^ eq1;           <span class="comment">// `timescale 1ns/1ns</span></span><br></pre></td></tr></table></figure>
<p>这个语句就表示该异或门的延时为 <code>1ns</code>，也就是说，输人端信号变化到输出端体现出来需要 <code>1ns</code> 的时间。</p>
<p>这里是比较笼统的延时模型。实际上，电路对不同的信号跳变表现出的延时往往并不一致。这些延时模型包括：</p>
<ul>
<li>上升沿延时（输出变为 1）；</li>
<li>下降沿延时（输出变为 0）；</li>
<li>关闭延时（输出变成 <code>Z</code>，高阻态）；</li>
<li>输出变成 <code>X</code> 的延时。</li>
</ul>
<p>用户可以分别描述这几种延时，比如：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> <span class="variable">#(1,2)</span> A_xor_wire = eq0 ^ eq1;</span><br><span class="line"><span class="keyword">assign</span> <span class="variable">#(1,2,3)</span> A_xor <span class="keyword">wire</span> = eq0 ^ eq1;</span><br></pre></td></tr></table></figure>
<p>第一句表示，上升延时 <code>1ns</code>，下降延时 <code>2ns</code>，关闭延时和传递到 <code>X</code> 的延时为两者中最小的，即 <code>1ns</code>。</p>
<p>第二句表示，上升延时 <code>1ns</code>，下降延时 <code>2ns</code>，关闭延时为 <code>3ns</code>，传递到 <code>X</code> 的延时取1、2、3中最小的 <code>1ns</code>。</p>
<p>在一些电路模型中，延时分为最大、典型和最小3种情况。连续赋值语句中的延时也可以采用 <code>min:typ:max</code> 的格式来表示。例如：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> <span class="variable">#(4:5:6, 3:4:5)</span> A_xor_wire = eq0 ^ eq1;</span><br></pre></td></tr></table></figure>
<p>表示上升延时的 <code>min:typ:max</code> 为 <code>4:5:6</code>，下降延时的 <code>min:typ:max</code> 为 <code>3:4:5</code>。</p>
<p>需要注意的是，在连续赋值语句中的延时具有硬件电路中惯性延时的特性。也就是说，<strong>任何小于其延时的信号变化脉冲将被滤除掉，不会体现在输出端口上</strong>。关于这部分内容会在后续详细描述。</p>
<p>另外，<code>assign</code> 语句中的延时特性通常是被逻辑综合工具忽略的。因为综合工具要将 Verilog 语言模型综合成逻辑电路，而逻辑电路的延时是由基本的单元库和走线延时决定的。用户无法对逻辑单元指定延时，但是，用户可以在综合和实现工具中加时序约束，让工具尽量满足设计的时序要求。</p>
<h2 id="2-4-驱动源线网"><a href="#2-4-驱动源线网" class="headerlink" title="2.4. 驱动源线网"></a>2.4. 驱动源线网<a name="drive"></a></h2><p>下面分为几种线网类型来描述当线网具有多重驱动源时的情况。</p>
<h3 id="2-4-1-多重驱动-wire（错误）"><a href="#2-4-1-多重驱动-wire（错误）" class="headerlink" title="2.4.1. 多重驱动 wire（错误）"></a>2.4.1. 多重驱动 <code>wire</code>（错误）</h3><figure class="highlight verilog"><figcaption><span>WS.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> WS (A, B, C, D, WireShort)；</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span> A, B, C, D;</span><br><span class="line"><span class="keyword">output</span> WireShort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">wire</span> WireShort;         <span class="comment">//显式定义为wire类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> WireShort = A ^ B；</span><br><span class="line"><span class="keyword">assign</span> WireShort = C &amp; D；</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>在以上代码中，由于 <code>WireShort</code> 为 <code>wire</code> 类型，同时它有多重驱动源，因此仿真时 <code>WireShort</code> 的值将是 <code>X</code>，也就是不定态。</p>
<h3 id="2-4-2-线或、线与功能"><a href="#2-4-2-线或、线与功能" class="headerlink" title="2.4.2. 线或、线与功能"></a>2.4.2. 线或、线与功能</h3><p>可以使用 <code>wor</code> 线网类型来将不同的输出“线或”在一起，如下：</p>
<figure class="highlight verilog"><figcaption><span>// WO.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> WO (A, B, C, D, WireOr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span> A, B, C, D;</span><br><span class="line"><span class="keyword">output</span> WireOr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">wor</span> WireOr;             <span class="comment">// 显式定义为 wor 类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> WireOr = A ^ B;</span><br><span class="line"><span class="keyword">assign</span> WireOr = C &amp; D;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>逻辑综合以后，它具体对应的逻辑电路如下图所示。</p>
<div align="center">
  <img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-30-josh-verilog-part-3/2020-11-30-josh-verilog-part-3-030-WireOr.png!700px"/>
</div>

<p>同样，可以使用 <code>wand</code> 线网类型来将不同的输出“线与”在一起，如下：</p>
<figure class="highlight verilog"><figcaption><span>WA.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> WA (A, B, C, D, WireAnd);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span> A, B, C, D;</span><br><span class="line"><span class="keyword">output</span> WireAnd;</span><br><span class="line"></span><br><span class="line"><span class="keyword">wand</span> WireAnd;           <span class="comment">// 显式定义为 wand 类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> WireAnd = A ^ B;</span><br><span class="line"><span class="keyword">assign</span> WireAnd = C &amp; D;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>它对应的逻辑电路如下图所示。</p>
<div align="center">
  <img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-30-josh-verilog-part-3/2020-11-30-josh-verilog-part-3-040-WireAnd.png!700px"/>
</div>

<h3 id="2-4-3-三态总线功能"><a href="#2-4-3-三态总线功能" class="headerlink" title="2.4.3. 三态总线功能"></a>2.4.3. 三态总线功能</h3><p>如果要实现多个三态总线相连，可以采用 <code>tri</code> 型线网：</p>
<figure class="highlight verilog"><figcaption><span>WT.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> WT (A, B, C, D, WireTri, en1_n, en2_n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span> A, B, C, D, en1_n, en2_n;</span><br><span class="line"><span class="keyword">output</span> WireTri;</span><br><span class="line"></span><br><span class="line"><span class="keyword">tri</span> WireTri;            <span class="comment">// 显式定义为 tri 类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> WireTri = (en1_n) ? <span class="number">1&#x27;bz</span> : (A ^ B);</span><br><span class="line"><span class="keyword">assign</span> WireTri = (en2_n) ? <span class="number">1&#x27;bz</span> : (C &amp; D);</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>其实现的电路如下图所示。</p>
<div align="center">
  <img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-30-josh-verilog-part-3/2020-11-30-josh-verilog-part-3-050-WireTri.png!700px"/>
</div>

<h1 id="3-行为描述"><a href="#3-行为描述" class="headerlink" title="3. 行为描述"></a>3. 行为描述<a name="03"><a></h1><p>在 <a href="https://josh-gao.top/posts/fd2ca242.html#3-%E7%A7%8D%E6%8F%8F%E8%BF%B0%E6%96%B9%E6%B3%95">Part 2</a> 中介绍过行为描述的概念。所谓行为描述，是指用语言描述电路的行为。行为描述的语句有两种：<code>initial</code> 和 <code>always</code> 语句。</p>
<h2 id="3-1-行为描述的语句格式"><a href="#3-1-行为描述的语句格式" class="headerlink" title="3.1. 行为描述的语句格式"></a>3.1. 行为描述的语句格式</h2><p><code>initial</code> 和 <code>always</code> 的后面一般跟语句或语句组（statement group)。语句可以是：非阻塞过程赋值、阻塞过程赋值、连续过程赋值或高级编程语句。在以后会一一介绍。</p>
<h3 id="3-1-1-initial-或-always-过程块（procedual-block）"><a href="#3-1-1-initial-或-always-过程块（procedual-block）" class="headerlink" title="3.1.1. initial 或 always 过程块（procedual block）"></a>3.1.1. <code>initial</code> 或 <code>always</code> 过程块（procedual block）</h3><p><code>initial</code> 语句在 0 仿真时间执行，而且只执行一次；<code>always</code> 语句同样在 0 仿真时间开始执行，但是它将一直循环执行。这样的特点单单从它们的命名上就能看得出来：一个是 <code>initial</code>，就是初始化一次的意思；另一个是 <code>always</code>，就是总在运行的意思。</p>
<p>下面利用 <code>initial</code> 和 <code>always</code> 语句各自的特点，产生一个时钟发生器的模型。</p>
<figure class="highlight verilog"><figcaption><span>ClkGen.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="meta-keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"><span class="keyword">module</span> ClkGen (clk);</span><br><span class="line"></span><br><span class="line"><span class="keyword">output</span> clk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span> clk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span>             <span class="comment">// 将 clk 初始化为 0</span></span><br><span class="line">    clk = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span>              <span class="comment">// 每 5ns 将 clk 翻转一次</span></span><br><span class="line">    #<span class="number">5</span> clk = ~clk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>在 0 时刻，<code>initial</code> 和 <code>always</code> 语句同时执行，顺序随机。假设先运行 <code>initial</code> 语句，那么 <code>clk</code> 变量被赋值为 0，这时 <code>initial</code> 语句进程将永远被挂起，再也不会执行。</p>
<p>然后，开始运行 <code>always</code> 语句。该 <code>always</code> 语句每隔 <code>5ns</code> 将 <code>clk</code> 信号翻转一次，一直不停地运行，这样就产生了一个周期是 <code>10ns</code> 的时钟信号。</p>
<blockquote>
<p>在以上代码中，0 时刻，<code>initial</code> 和 <code>always</code> 语句同时执行，顺序随机，这样就存在一个冲突的问题。假设先执行的是 <code>always</code> 语句， <code>clk</code> 就不会被初始化为 0。</p>
</blockquote>
<h3 id="3-1-2-过程块中的语句种类"><a href="#3-1-2-过程块中的语句种类" class="headerlink" title="3.1.2. 过程块中的语句种类"></a>3.1.2. 过程块中的语句种类</h3><p>在 <code>initial</code> 和 <code>always</code> 过程块中可以直接跟语句或者语句组。直接跟的语句可以是非阻塞过程赋值、阻塞过程赋值、连续过程赋值或高级编程语句。语句组可以是：<code>begin ... end</code> 和 <code>fork ... join</code> 两种。</p>
<p>语句组中可以有其他几种语句类型，而高级编程语句中也可以有语句组，它们可以互相嵌套，完成非常复杂的逻辑功能描述。</p>
<p>下面是 <code>always</code> 过程块中直接跟阻塞赋值语句：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span>              <span class="comment">// 每 5ns 将 clk 翻转一次</span></span><br><span class="line">    #<span class="number">5</span> clk = ~clk;</span><br></pre></td></tr></table></figure>
<p>下面的代码描述了语句组和高级编程语句的互相嵌套：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) </span><br><span class="line"><span class="keyword">begin</span>                               <span class="comment">// 语句组</span></span><br><span class="line">    <span class="keyword">if</span> (~rst_n)                     <span class="comment">// 高级编程语句</span></span><br><span class="line">    <span class="keyword">begin</span>                           <span class="comment">// 语句组</span></span><br><span class="line">        reg_A &lt;= <span class="number">0</span>;                 <span class="comment">// 非阻塞赋值语句</span></span><br><span class="line">        reg_B &lt;= <span class="number">0</span>;                 <span class="comment">// 非阻塞赋值语句</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span>                            <span class="comment">// 高级编程语句</span></span><br><span class="line">    <span class="keyword">begin</span>                           <span class="comment">// 语句组</span></span><br><span class="line">        reg_A &lt;= input_A;           <span class="comment">// 非阻塞赋值语句</span></span><br><span class="line">        reg_B &lt;= input_B;           <span class="comment">// 非阻塞赋值语句</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>从上例中可以看出，高级编程语句里面可以嵌套过程赋值语句，或者其他高级编程语句。</p>
<h3 id="3-1-3-时序控制（Timing-Control）"><a href="#3-1-3-时序控制（Timing-Control）" class="headerlink" title="3.1.3. 时序控制（Timing Control）"></a>3.1.3. 时序控制（Timing Control）</h3><p>在行为描述中，有几种方式对设计模型进行时序控制，它们是：</p>
<ul>
<li>事件语句（<code>@</code>）；</li>
<li>延时语句（<code>#</code>）；</li>
<li>等待语句。</li>
</ul>
<p>当执行 <code>initial</code> 或 <code>always</code> 语句块时遇到一个事件语句（<code>@</code>）、延时语句（<code>#</code>），或其表达式值为假（false）的等待语句时，语句块（或称为进程）的执行将被挂起（suspended)。直到发生该事件，或者已经过了指定延迟的时间单位数，或者等待语句表达式变为真（ture）时，才重新执行 <code>initial</code> 或 <code>always</code> 语句块。这个过程就是时序控制。Verilog 的行为描述中，正是利用这几种时序控制语句来实现各种各样的逻辑功能。</p>
<h4 id="3-1-3-1-事件语句（-）的用法"><a href="#3-1-3-1-事件语句（-）的用法" class="headerlink" title="3.1.3.1. 事件语句（@）的用法"></a>3.1.3.1. 事件语句（<code>@</code>）的用法</h4><div align="center">
  <img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-30-josh-verilog-part-3/2020-11-30-josh-verilog-part-3-060-DFlipFlop.png!600px"/>
</div>

<p>要实现上图中这样一个 D 触发器，通常用以下代码：</p>
<figure class="highlight verilog"><figcaption><span>TYP_DFF.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> TYP_DFF (clk, D, Q);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span> clk, D;</span><br><span class="line"><span class="keyword">output</span> Q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span> Q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">    Q &lt;= D;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>在 0 仿真时刻，<code>always</code> 语句块开始执行。当遇到 <code>@ (posedge clk)</code> 语句时，该进程被挂起。等待 <code>clk</code> 的上升沿到来，才重新激活该进程。当 <code>clk</code> 的上升沿出现后，将 <code>D</code> 的值赋给 <code>Q</code>，<code>always</code> 语句块执行完成。</p>
<p>由于 <code>always</code> 语句的特点，<code>always</code> 语句马上开始重新执行，当遇到 <code>@ (posedge clk)</code> 语句时，进程再一次挂起，等待 <code>clk</code> 的上升沿到来，才继续往下执行。</p>
<p>这样，在 <code>always</code> 语句中使用 <code>@</code> 事件语句很好地模拟了触发器的行为。综合工具会马上将上述代码映射成上图中的 D 触发器。</p>
<p>同样的道理，采用如下的代码也可以得到一样的 D 触发器功能：</p>
<figure class="highlight verilog"><figcaption><span>TYP_DFF.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> TYP_DFF (clk, D, Q);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span> clk, D;</span><br><span class="line"><span class="keyword">output</span> Q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span> Q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> <span class="keyword">begin</span></span><br><span class="line">    @(<span class="keyword">posedge</span> clk)</span><br><span class="line">    Q &lt;= D;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>当有多个条件语句时，一般将它们用 <code>or</code> 分隔开。例如，要实现一个带异步复位端的 D 触发器可以采用如下代码：</p>
<figure class="highlight verilog"><figcaption><span>TYP_DFF.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> TYP_DFF (clk, D, Q, rst);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span> clk, D, rst;</span><br><span class="line"><span class="keyword">output</span> Q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span> Q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">posedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (rst)</span><br><span class="line">        Q &lt;= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        Q &lt;= D;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>当出现 <code>clk</code> 或 <code>rst</code> 的下降沿时，才会触发 <code>always</code> 语句。</p>
<h4 id="3-1-3-2-延时语句（-）的用法"><a href="#3-1-3-2-延时语句（-）的用法" class="headerlink" title="3.1.3.2. 延时语句（#）的用法"></a>3.1.3.2. 延时语句（<code>#</code>）的用法</h4><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span>              <span class="comment">// 每 5ns 将 clk 翻转一次</span></span><br><span class="line">    #<span class="number">5</span> clk = ~clk;</span><br></pre></td></tr></table></figure>
<p>这里 <code>always</code> 的语句开始执行时，马上遇到 <code>#5</code>，<code>always</code> 语句块挂起。直到 <code>5ns</code> 以后才恢复执行，这时将 <code>clk</code> 取反。当再次执行 <code>always</code> 时，动作与上一次完全一致。这里，模拟了一个周期为 <code>10ns</code> 的时钟。</p>
<p>当然，这种写法一般用于仿真激励的产生，仅仅用于仿真。由于综合工具会将延时语句 <code>#5</code> 忽略，所以如上的代码无法综合成一个 <code>10ns</code> 周期的时钟发生器电路。</p>
<p>以下代码利用延时语句产生一个复位信号：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    rst_n =<span class="number">1</span>;</span><br><span class="line">    #<span class="number">5</span> rst_n = <span class="number">0</span>;</span><br><span class="line">    #<span class="number">100</span> rst_n=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>当以上 <code>initial</code> 语句开始运行时，首先将 <code>rst_n</code> 赋值为 <code>1</code>。当遇到 <code>#5</code> 时，该 <code>initial</code> 的执行过程被暂时挂起，等待 <code>5ns</code> 后恢复执行，<code>rst_n</code> 被置 <code>0</code>，处于复位状态。然后，遇到 <code>#100</code>，等待 <code>100ns</code> 以后再恢复执行，<code>rst_n</code> 被置为 <code>1</code>。这时，<code>initial</code> 语句块被永远挂起，再也不会执行。于是，就产生了一个 <code>100ns</code> 的复位信号。</p>
<h4 id="3-1-3-3-等待语句的用法"><a href="#3-1-3-3-等待语句的用法" class="headerlink" title="3.1.3.3. 等待语句的用法"></a>3.1.3.3. 等待语句的用法</h4><p>下面分析一下等待语句如何做时序控制：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> MY_LATCH (Strobe, D, Q);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span> Strobe, D;</span><br><span class="line"><span class="keyword">output</span> Q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span> Q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">wait</span> (Strobe == <span class="number">1</span>);</span><br><span class="line">    Q = D;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>该语句表示，当 <code>always</code> 语句开始执行后，遇到 <code>wait()</code> 语句，如果括号内的变量不为真，则该进程被挂起，直到 <code>(Strobe == 1)</code> 为真，<code>always</code> 才继续往下执行，将 <code>D</code> 的值赋值给 <code>Q</code>，这样就模拟了一个电平敏感的锁存器。</p>
<p>要注意的是，目前多数综合工具还不支持 <code>wait</code> 语句，因此这个锁存器的功能只能在仿真时用，不能实现为具体的电路。</p>
<h2 id="3-2-过程赋值语句"><a href="#3-2-过程赋值语句" class="headerlink" title="3.2. 过程赋值语句"></a>3.2. 过程赋值语句</h2><p>所谓过程赋值语句就是在 <code>initial</code> 和 <code>always</code> 语句块中的赋值语句。赋值对象只能是寄存器变量类型。右边的表达式可以是任意操作符的表达式。</p>
<h3 id="3-2-1-阻塞赋值"><a href="#3-2-1-阻塞赋值" class="headerlink" title="3.2.1. 阻塞赋值"></a>3.2.1. 阻塞赋值</h3><p>阻塞赋值的语法如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">寄存器变量 = 表达式;</span><br></pre></td></tr></table></figure>
<p>所谓“阻塞赋值”，实际上有两层含义：</p>
<ol>
<li><p>右边表达式的计算和对左边寄存器变量的赋值是一个统一的原子操作中的两个动作。<strong>这两个动作之间不能插人任何其他的动作</strong>。</p>
</li>
<li><p>如果多个阻塞赋值语句顺序出现在 <code>begin. .. end</code> 语句中，<strong>前面的语句在执行时，将完全阻塞后面的语句，直到前面语句的赋值完成以后，才会执行下一句的右边表达式计算</strong>。例如 <code>begin m = n; n = m; end</code> 语句中，当 <code>m</code> 被完全赋值以后，再开始执行 <code>n=m</code>，将 <code>m</code> 的新值赋给 <code>n</code>。这样执行的结果就是的初始值不变，而且与 <code>n</code> 相等。</p>
</li>
</ol>
<p>由于阻塞賦值的这一特点，通常会建议在对组合逻辑建模的时候，采用阻塞賦值，先看一段代码：</p>
<p><a name="一个组合逻辑"></a></p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">wire</span> A_in, B_in, C_in;</span><br><span class="line"><span class="keyword">reg</span> Temp, D_out;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">always</span> @(A_in <span class="keyword">or</span> B_in <span class="keyword">or</span> C_in) <span class="keyword">begin</span></span><br><span class="line">    Temp = A_in &amp; B_in;             <span class="comment">// 阻塞赋值</span></span><br><span class="line">    D_out = Temp | C_in;            <span class="comment">// 阻塞赋值</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>设计者的根本目的是得到如下图所示的电路。</p>
<div align="center">
  <img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-30-josh-verilog-part-3/2020-11-30-josh-verilog-part-3-070-ACombinationalLogic.png!700px"/>
</div>

<p>在以上代码仿真时，正是利用了阻塞赋值的这一特点才模拟了该组合逻辑的行为。</p>
<p>首先，任何一个输人发生变化，<code>D_out</code> 必然发生变化。因此，在 <code>always</code> 的敏感列表中，包括 <code>A_in</code>，<code>B_in</code> 和 <code>C_in</code>。在内部计算时，首先将 <code>A_in</code> 和 <code>B_in</code> 相与，得到一个中间结果 <code>Temp</code>。等 <code>Temp</code> 被完全赋值后，才开始执行下一个语句：将 <code>Temp</code> 的新值与 <code>C_in</code> 相或，得到 <code>D_out</code> 的值。我们也许可以感受到，这个 <code>always</code> 语句非常精确地模拟了上图中电路的行为。</p>
<p>另外，有一点会使得初学者产生较大的疑问。为什么 Verilog 规定只有寄存器（register）类型的变量才能够在过程赋值语句中被赋值呢？有时候在Verilog中定义的寄存器变量，在综合时并不一定映射成一个实在的触发器硬件。比如在以上的例子中，<code>Temp</code> 和 <code>D_out</code> 被定义成 <code>reg</code> 变量，而综合结果它们却还是组合逻辑，并不是存储单元。</p>
<p>在 Verilog  语言中，寄存器变量的特点是需要在仿真运行器件上保持它的值，也就是说，这个变量在仿真时需要占据内存空间。</p>
<p>在以上的 <code>always</code> 实例中，<code>always</code> 语句块只对 <code>A_in</code> 等 3 个输人变化敏感。如果没有这 3 个变量的变化事件，<code>Temp</code> 和 <code>D_out</code> 变量将需要保存其值，因此它们必须被定义为寄存器类型变量。但是，它们在综合之后，并不对应硬件锁存器或者触发器。</p>
<h3 id="3-2-2-非阻塞赋值"><a href="#3-2-2-非阻塞赋值" class="headerlink" title="3.2.2. 非阻塞赋值"></a>3.2.2. 非阻塞赋值</h3><p>非阻寒赋值的语法如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">寄存器变量 &lt;= 表达式;</span><br></pre></td></tr></table></figure>
<p>它的特点是在执行该语句时，首先计算右边的表达式，然后并不立刻对左边的变量赋值。由于这个赋值操作在当前仿真时间事件队列中的优先级比较低，因此<strong>将赋值推迟到当前仿真时刻的后期运行</strong>。关于具体非阻塞赋值的右式计算和左式更新是何时完成的，请参考后续内容。</p>
<p>与阻塞赋值不同的是，如果多个非阻塞赋值语句顺序出现在 <code>begin ... end</code> 语句中，前面语句的执行，并不会阻塞后面语句的执行。前面语句的计算完成，还没有赋值时，就会执行下一句的右边表达式计算。例如 <code>begin m &lt;= n; n &lt;= m; end</code> 语句中，最后的结果是将m与n值互换了。</p>
<p>如果想要采用如下代码来描述<a href="#一个组合逻辑">前述组合逻辑电路</a>的功能：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">wire</span> A_in, B_in, C_in;</span><br><span class="line"><span class="keyword">reg</span> Temp, D_out;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">always</span> @(A_in <span class="keyword">or</span> B_in <span class="keyword">or</span> C_in) <span class="keyword">begin</span></span><br><span class="line">    Temp &lt;= A_in &amp; B_in;            <span class="comment">// 非阻塞赋值</span></span><br><span class="line">    D_out &lt;= Temp | C_in;           <span class="comment">// 非阻塞赋值</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>如果使用仿真工具去仿真这段代码，就会发现它的功能并不是所想要的功能。比如当 <code>A_in</code> 发生变化，执行 <code>always</code> 语句，其中 <code>Temp &lt;= A_in &amp; B_in;</code> 这句话并没有立刻对 <code>Temp</code> 赋值，而是放在当前仿真时刻的后期才开始执行 <code>Temp</code> 的更新。这样，当执行 <code>D_out &lt;=Temp | C_in;</code> 表达式的右式计算事件时，<code>Temp</code> 的值还是<br>旧的值，因此这时 <code>D_out</code> 并不会发生变化。</p>
<p>大家也许可以尝试将如上的代码用综合工具综合一下，可能同样会得到<a href="#一个组合逻辑">前述组合逻辑电路</a>的情况。这是由于一些综合工具可以容忍用户的这些代码缺陷。这就造成了 RTL 仿真和综合的结果不一致的现象。</p>
<p>为什么会造成这个现象呢？因为 RTL 的仿真器严格按照 Verilog 的仿真语义执行 RTL 的仿真过程，而综合工具通常只是根据用户的代码推断设计者的意图，然后生成相应的电路结构。因此，综合的过程有一定的主观推断性，并不严格遵守 Verilog 的语义，不同的综合工具判决标准也不一样。</p>
<p>这种情况是每一个设计都应该尽量避免的，因为仿真和综合结果不一致说明源代码中很可能有隐患，不符合 Verilog 的语义，会错过许多 bug，增加设计的不稳定性。</p>
<p>所以保证仿真器和综合器都能正确理解设计的代码，是非常关键的。</p>
<p><strong>通常利用非阻塞赋值的特点来对时序逻辑进行建模。</strong></p>
<p>代码如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">    q1 &lt;= d;</span><br><span class="line">    q2 &lt;= q1;</span><br><span class="line">    q3 &lt;= q2;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>其实现结果如下图：</p>
<div align="center">
  <img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-30-josh-verilog-part-3/2020-11-30-josh-verilog-part-3-080-ThreeFlowStateRegister.png!sign"/>
</div>

<p>正是利用了语句之间的非阻塞性，才实现了这个 3 级流水线的逻辑功能。</p>
<h3 id="3-2-3-过程连续赋值"><a href="#3-2-3-过程连续赋值" class="headerlink" title="3.2.3. 过程连续赋值"></a>3.2.3. 过程连续赋值</h3><p>在 Verilog 语言中，还有一种过程赋值语句叫做“过程连续赋值”，它们也是出现在 <code>always</code> 和 <code>initial</code> 语句块中的。</p>
<p>过程连续赋值主要有两种：</p>
<ul>
<li><code>assign</code> 与 <code>deassign</code>：在过程语句块中对寄存器变量强制赋值和放开；</li>
<li><code>force</code> 与 <code>release</code>：在过程语句块中对寄存器和线网进行强制赋值和放开。</li>
</ul>
<p>例如，在下面的代码实例中用 <code>assign</code> 和 <code>deassign</code> 描述了一个带异步清零端的 D 触发器。</p>
<figure class="highlight verilog"><figcaption><span>DEF.V</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> DEF(D, clr, clk, Q);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span> D, clr, clk;</span><br><span class="line"><span class="keyword">output</span> Q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span> Q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(clr) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!clr)</span><br><span class="line">        <span class="keyword">assign</span> Q = <span class="number">0</span>;       <span class="comment">// D 的值对 Q 无效, 将 Q 强制为 0</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">deassign</span> Q;         <span class="comment">// 将强制的 Q 值放开</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">negedge</span> clk)</span><br><span class="line">    Q = D;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>这里不再对过程连续赋值进行过多阐述，有兴趣可以参考其他文献。</p>
<h2 id="3-3-语句组"><a href="#3-3-语句组" class="headerlink" title="3.3. 语句组"></a>3.3. 语句组</h2><p>语句组是两条以上语句的组合，它们看起来像一个独立的语句。语句组也是出现在 <code>initial</code> 和 <code>always</code> 的过程块中的。</p>
<p>根据其中语句的执行顺序，语句组可以分为“顺序语句组”和“并行语句组”两种。</p>
<h3 id="3-3-1-顺序语句组-begin-end"><a href="#3-3-1-顺序语句组-begin-end" class="headerlink" title="3.3.1. 顺序语句组 begin ... end"></a>3.3.1. 顺序语句组 <code>begin ... end</code></h3><p>在顺序语句组中，其中的语句是一条一条顺序执行的。比如下面的语句：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @(A_in <span class="keyword">or</span> B_in <span class="keyword">or</span> C_in) <span class="keyword">begin</span></span><br><span class="line">    Temp = A_in &amp; B_in;                 <span class="comment">// 阻塞赋值</span></span><br><span class="line">    D_out = Temp | C_in;                <span class="comment">// 阻塞赋值</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>首先执行第一句，将 <code>A_in</code> 和 <code>B_in</code> 相与，然后将结果赋给 <code>Temp</code> 变量；再执行第一句，将新的 <code>Temp</code> 值 <code>C_in</code> 相或，结果立刻赋给 <code>D_out</code>。</p>
<p>当然，这里是同时利用了 <code>begin ... end</code> 语句组和阻塞赋值的特点，才实现了用户想要的逻辑功能。</p>
<p>再比如要产生一个值序列：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">initial</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    DataBin = <span class="number">0</span>;</span><br><span class="line">    #<span class="number">6</span> DataBin = <span class="number">0</span>;</span><br><span class="line">    #<span class="number">4</span> DataBin = <span class="number">1</span>;</span><br><span class="line">    #<span class="number">2</span> DataBin = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>由于语句是顺序执行的，产生的波形如下图所示。</p>
<div align="center">
  <img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-30-josh-verilog-part-3/2020-11-30-josh-verilog-part-3-090-SequentialWave.png!500px"/>
</div>

<h3 id="3-3-2-并行语句组-fork-join"><a href="#3-3-2-并行语句组-fork-join" class="headerlink" title="3.3.2. 并行语句组 fork ... join"></a>3.3.2. 并行语句组 <code>fork ... join</code></h3><p>在<code>fork ... join</code> 语句组中，语句是并行执行的。将上一小节的代码改写如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">initial</span></span><br><span class="line"><span class="keyword">fork</span></span><br><span class="line">    DataBin = <span class="number">0</span>;</span><br><span class="line">    #<span class="number">6</span> DataBin = <span class="number">0</span>;</span><br><span class="line">    #<span class="number">4</span> DataBin = <span class="number">1</span>;</span><br><span class="line">    #<span class="number">2</span> DataBin = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">join</span></span><br></pre></td></tr></table></figure>
<p>由于其中的所有语句并行执行，也就是以上 4 条语句都是从 0 时刻开始同时执行的，产生的波形如下图。</p>
<div align="center">
  <img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-30-josh-verilog-part-3/2020-11-30-josh-verilog-part-3-100-ParallelWave.png!500px"/>
</div>

<h3 id="3-3-3-语句组的标识符"><a href="#3-3-3-语句组的标识符" class="headerlink" title="3.3.3. 语句组的标识符"></a>3.3.3. 语句组的标识符</h3><p>语句组可以有标识符，也可以没有。</p>
<p>当一个语句组有标识符时，在语句组内部可以定义局部变量，而不会传递到语句组的外部。然而，在仿真语义上，这个变量是静态变量，它的值在整个仿真运行周期中是不变的，但是不会与其他语句组中同一个名称的变量发生冲突。例如：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span> i;              <span class="comment">// always 语句以外的 i 变量</span></span><br><span class="line"><span class="keyword">always</span> @(...)</span><br><span class="line"><span class="keyword">begin</span>: SORT</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">integer</span> i;          <span class="comment">// 语句组内部的土变量</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>;i &lt;= <span class="number">7</span>; i = i + <span class="number">1</span>)</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>在 <code>always</code> 以外的i变量和 <code>always</code> 里面定义的i变量属于<strong>两个不同的变量，并不冲突</strong>。它们在仿真的时候将占用两块不同的内存，类似于 C 语言中的静态局部变量。</p>
<h2 id="3-4-高级编程语旬"><a href="#3-4-高级编程语旬" class="headerlink" title="3.4. 高级编程语旬"></a>3.4. 高级编程语旬</h2><h3 id="3-4-1-为什么需要编程语句"><a href="#3-4-1-为什么需要编程语句" class="headerlink" title="3.4.1. 为什么需要编程语句"></a>3.4.1. 为什么需要编程语句</h3><p>Verilog 作为硬件描述语言，最重要的特性就是其设计层次比较高，不仅停留在晶体管级和门级，而是可以在更高的层次如 RTL 级甚至是行为级描述硬件系统的行为，或者编写测试激励。</p>
<p>为了达到提高描述能力、提高抽象层次，Verilog 语言从 C 语言等编程语言中借鉴了一语句，同时也创造了一些语句，例如 <code>if</code>、<code>case</code>、<code>while</code>、<code>for</code>、<code>repeat</code> 和 <code>forever</code> 等。这些语句被称为高级编程语句。有了这些语句 Verilog 才可以描述比较复杂的电路行为。</p>
<p>编程语句只能出现在 <code>initial</code> 和 <code>always</code> 的过程块中。编程语句中可以嵌套其他的语句，比如过程赋值语句或者其他编程语句。</p>
<p>高级编程语分为3大类：</p>
<ul>
<li><code>if ... else</code> 语句；</li>
<li>case语句；</li>
<li>循环语句：<code>forever</code>、<code>repeat</code>、<code>while</code>、<code>for</code>。</li>
</ul>
<p>下面将逐一介绍。</p>
<h3 id="3-4-2-if-else-语句"><a href="#3-4-2-if-else-语句" class="headerlink" title="3.4.2. if ... else 语句"></a>3.4.2. <code>if ... else</code> 语句</h3><p><code>if</code> 语句后面跟语句或语句组（<code>begin ... end</code> 或 <code>fork ... join</code>)。常和 <code>else</code> 搭配来实现不同条件的各种情况。<code>if</code> 也可以单独使用，没有 <code>else</code> 配合。</p>
<p>现考虑以下代码：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @(sel_a <span class="keyword">or</span> sel_b <span class="keyword">or</span> a <span class="keyword">or</span> b <span class="keyword">or</span> c) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (sel_a)</span><br><span class="line">        q = a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (sel_b)</span><br><span class="line">        q = b;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        q = c;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>它要实现的逻辑如下图。</p>
<div align="center">
  <img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-30-josh-verilog-part-3/2020-11-30-josh-verilog-part-3-110-IfElseStatement.png!600px"/>
</div>

<p>在 <code>if ... else</code> 语句中，条件是从上到下逐条检查的。因此，当满足一个条件时，就执行其后的语句，跳过 <code>else</code> 后面的语句、当所有条件都不满足，便执行最后一条 <code>else</code> 后面的语句。因此 <code>if ... else</code> 语句实际上是有优先级顺序的。</p>
<p>实际在上例中使用了 <code>if ... else</code> 优先级编码的特点，<code>sel_a</code> 的判断优先级最高，因此在逻辑中的级数要明显少一些，参考上图。如果 <code>sel_a</code> 为关键路径的话，就可以利用这样的优先级编码提高设计的性能。</p>
<p>在使用 <code>if ... else</code> 语句时，<strong>尤其是用在组合逻辑中，需要注意不要引入 Latch 电路</strong>。先来看如下的代码：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @(sel <span class="keyword">or</span> a <span class="keyword">or</span> b <span class="keyword">or</span> c) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (sel == <span class="number">2&#x27;b00</span>)</span><br><span class="line">        q = a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (sel == <span class="number">2&#x27;b01</span>)</span><br><span class="line">        q = b;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (sel == <span class="number">2&#x27;b10</span>)</span><br><span class="line">        q = c;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>由于，最后一个条件 <code>sel == 2&#39;b11</code> 的语句没有被显式地写出，言下之意是，当 <code>sel</code> 为 <code>2&#39;b11</code> 时，<code>q</code> 值需要保持不变。这个代码在综合时自然就会产生锁存器，如下图。</p>
<div align="center">
  <img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-30-josh-verilog-part-3/2020-11-30-josh-verilog-part-3-120-CombinationalLogicwithLatch.png!800px"/>
</div>

<p><strong>锁存器在数字同步逻辑设计中应该尽量避免。因为锁存器容易引起竞争冒险，同时静态时序分析工具也不好分析穿过锁存器的路径。</strong></p>
<p>在下面的代码中，己经明确写出：当 <code>se</code> 为 <code>2&#39;b11</code> 时，<code>q</code> 值不关心，赋值为 <code>x</code>。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @(sel <span class="keyword">or</span> a <span class="keyword">or</span> b <span class="keyword">or</span> c) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (sel == <span class="number">2&#x27;b00</span>)</span><br><span class="line">        q = a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (sel == <span class="number">2&#x27;b01</span>)</span><br><span class="line">        q = b;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (sel == <span class="number">2&#x27;b10</span>)</span><br><span class="line">        q = c;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        q = <span class="number">1&#x27;bx</span>;       <span class="comment">// 当 sel 为 2&#x27;b11 时, q 值不关心</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>既然不关心 <code>sel</code> 为 <code>2&#39;b11</code> 时 <code>q</code> 的值，那么有的综合工具就顺手将 <code>sel</code> 等于 <code>2&#39;b11</code> 时 <code>q</code> 的值也赋值为 <code>c</code>，这样就避免了锁存器的产生。实现电路如下图。</p>
<div align="center">
  <img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-30-josh-verilog-part-3/2020-11-30-josh-verilog-part-3-130-CombinationalLogicwithoutLatch.png!sign"/>
</div>

<p><span id="无锁存器的组合逻辑电路"></span></p>
<p>然而，在描述时序逻辑时，通常将利用 <code>if</code> 语句的隐式条件对带时钟使能的 D 触发器建模。代码如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (~rst_n)</span><br><span class="line">        sum &lt;= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (en)</span><br><span class="line">        sum &lt;= a + b;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>以上语句表示在时钟正沿来临时，如果 <code>en</code> 为 1，则将 <code>a + b</code> 的值付给 <code>sum</code>。言下之意：如果 <code>en</code> 为 0，那么 <code>sum</code> 保持原值不变。因此，这里综合工具会把代码综合成一个时钟使能的寄存器，如图3一14所示。</p>
<div align="center">
  <img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-30-josh-verilog-part-3/2020-11-30-josh-verilog-part-3-140-DFlipFlopClock.png!800px"/>
</div>

<p>其中，<code>en</code> 信号时 D 触发器的时钟使能端，<code>rst_n</code> 是 D 触发器的异步清零信号。</p>
<h3 id="3-4-3-case-语句"><a href="#3-4-3-case-语句" class="headerlink" title="3.4.3. case 语句"></a>3.4.3. <code>case</code> 语句</h3><p><code>case</code> 语句的功能同正一类似，但是又有很大的不同。它后面也可以跟语句或语句组（<code>begin ... end</code> 或 <code>fork ... join</code>）。</p>
<p>如下例：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @(sel <span class="keyword">or</span> a <span class="keyword">or</span> b <span class="keyword">or</span> c) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">case</span>(sel)</span><br><span class="line">        <span class="number">2&#x27;b00</span>: q = a;</span><br><span class="line">        <span class="number">2&#x27;b01</span>: q = b;</span><br><span class="line">        <span class="number">2&#x27;b10</span>: q = c;</span><br><span class="line">        <span class="keyword">default</span>: q = <span class="number">1&#x27;bx</span>；</span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>在 <code>case</code> 语句中，<code>default:</code> 一条描述了所有没有明确说明的其他可能情况。比如，这里的 <code>default</code> 就包含了 <code>sel</code> 为 <code>2&#39;b11</code>、<code>2&#39;bzz</code> 和 <code>2&#39;bxx</code> 等情况。</p>
<p>以上的代码将实现如上的<a href="#无锁存器的组合逻辑电路">无锁存器的组合逻辑电路</a>。</p>
<p>与 <code>if ... else</code> 语句不同的是，在 <code>case</code> 语句中，所有被判断的分支条件都具有一样的优先级。</p>
<p>与 <code>if ... else</code> 类似的是，语句同样需要考虑所有可能的情况，否则将会产生不想要的锁存器。如果将代码改为：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @(sel <span class="keyword">or</span> a <span class="keyword">or</span> b <span class="keyword">or</span> c) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">case</span>(sel)</span><br><span class="line">        <span class="number">2&#x27;b00</span>: q = a;</span><br><span class="line">        <span class="number">2&#x27;b01</span>: q = b;</span><br><span class="line">        <span class="number">2&#x27;b10</span>: q = c;</span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>这样，将会产生与如上的<a href="#带锁存器的组合逻辑电路">带锁存器的组合逻辑电路</a>。这是设计者不愿意看到的。</p>
<p>对于 <code>case</code> 语句，有两个派生语句，即 <code>casez</code> 及 <code>casex</code>。</p>
<p><code>casez</code> 语句将分支条件中所有的 <code>z</code> 看作“不关心”的值，而不看作任何逻辑值。条件中的 <code>z</code> 可以改写为 <code>?</code>，如下例：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">casez</span> (encoder)</span><br><span class="line">    <span class="number">4&#x27;b1</span>???: hign_lvl = <span class="number">3</span>;</span><br><span class="line">    <span class="number">4&#x27;b01</span>??: hign_lvl = <span class="number">2</span>;</span><br><span class="line">    <span class="number">4&#x27;b001</span>?: hign_lvl = <span class="number">1</span>;</span><br><span class="line">    <span class="number">4&#x27;b0001</span>: high_lvl = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">default</span>: high_lvl = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">endcase</span></span><br></pre></td></tr></table></figure>
<p>这里，如果 <code>encoder</code> 为 <code>4b&#39;1zzz</code> 则 <code>high_lvl</code> 取值为 3。</p>
<p><code>casex</code> 语句将分支条件中所有的x和z看作“不关心”的值，而不看作任何逻辑值。如下例：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">casex</span> (encoder)</span><br><span class="line">    <span class="number">4&#x27;b1xxx</span>: hign_lvl = <span class="number">3</span>;</span><br><span class="line">    <span class="number">4&#x27;b01xx</span>: hign_lvl = <span class="number">2</span>;</span><br><span class="line">    <span class="number">4&#x27;b001x</span>: hign_lvl = <span class="number">1</span>;</span><br><span class="line">    <span class="number">4&#x27;b0001</span>: high_lvl = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">default</span>: high_lvl = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">endcase</span></span><br></pre></td></tr></table></figure>
<p>这里，如果 <code>encoder</code> 为 <code>4&#39;b1xzx</code>，则 <code>high-lvl</code> 取值为 3。</p>
<h3 id="3-4-4-循环语句"><a href="#3-4-4-循环语句" class="headerlink" title="3.4.4. 循环语句"></a>3.4.4. 循环语句</h3><p>循环语句一般用于重复的操作。</p>
<p>循环语句后面可以跟语句或语句组（<code>begin ... end</code> 或 <code>fork ... join</code>)。</p>
<ol>
<li><p><code>forever</code> 循环：永远执行</p>
 <figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    clk = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">forever</span> #<span class="number">25</span> clk = ~clk;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p> 以上语句产生了一个周期为 50 个时间单位的时钟。</p>
</li>
<li><p><code>repeat</code> 循环：执行固定的次数</p>
 <figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (rotate == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">repeat</span> (<span class="number">8</span>)</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        tmp = data[<span class="number">15</span>];</span><br><span class="line">        data = &#123;data&lt;&lt;<span class="number">1</span>, temp&#125;;</span><br><span class="line">    <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p> 以上语句中，当为 1 时，重复对 <code>data</code> 数据做8次循环左移。</p>
</li>
<li><p><code>while</code> 循环：当表达式为真时执行</p>
 <figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (count &lt; <span class="number">101</span>) <span class="keyword">begin</span></span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;Count = %d&quot;</span>, count);</span><br><span class="line">        count = count + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p> 在 <code>while</code> 语句中，只要后面的条件满足，就持续执行该语句，直到条件不满足，跳出循环。这里，将 <code>count</code> 从 0 递增到 101，逐步打印出来。</p>
</li>
<li><p><code>for</code> 循环：从初始值开始，如果表达式为真就执行</p>
 <figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span> i;          <span class="comment">// 为 for 循环声明索引</span></span><br><span class="line"><span class="keyword">always</span> @(inp <span class="keyword">or</span> cnt) <span class="keyword">begin</span></span><br><span class="line">    result[<span class="number">7</span>:<span class="number">4</span>] = <span class="number">0</span>;</span><br><span class="line">    result[<span class="number">3</span>:<span class="number">0</span>] = inp;</span><br><span class="line">    <span class="keyword">if</span> (cnt == <span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">4</span>; i &lt;= <span class="number">7</span>; i = i + <span class="number">1</span>)</span><br><span class="line">            result[i] = result[i-<span class="number">4</span>];</span><br><span class="line">        result[<span class="number">3</span>:<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p> <code>for</code> 语句开始执行直到 <code>i</code> 大于 7，跳出循环。如上代码实现了一个位的左移器。</p>
</li>
</ol>
<p>简单介绍了 Verilog 中的高级编程语句，只要对 C 语言有一定基础，就能迅速掌握其中的用法。</p>
<h1 id="4-结构化描述"><a href="#4-结构化描述" class="headerlink" title="4. 结构化描述"></a>4. 结构化描述</h1><p>结构化描述就是在设计中<strong>实例化已有的功能模块</strong>，这些功能模块包括：门原语、用户自定义原语（UDP）、其他模块（module）。以下是结构化描述的3种实例类型：实例化其他模块、实例化门及实例化UDP。</p>
<p>下例是由两个半加器组成的全加器的模型，其中所有模块都采用了结构化描述方法。</p>
<figure class="highlight verilog"><figcaption><span>HalfAdd.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> HalfAdd(X, Y, sum, C_out);                   <span class="comment">// 半加器模块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span> X;</span><br><span class="line"><span class="keyword">input</span> Y;</span><br><span class="line"><span class="keyword">output</span> sum;</span><br><span class="line"><span class="keyword">output</span> C_out;</span><br><span class="line"></span><br><span class="line"><span class="comment">// assign sum = X ^ Y;</span></span><br><span class="line"><span class="comment">// assign C_out = X &amp; Y;</span></span><br><span class="line"><span class="keyword">xor</span> u_xor(sum, X, Y);                               <span class="comment">// 门级原语实例</span></span><br><span class="line"><span class="keyword">and</span> u_and(C_out, X, Y);                             <span class="comment">// 门级原语实例</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span> </span><br></pre></td></tr></table></figure>
<figure class="highlight verilog"><figcaption><span>FullAdd.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> FullAdd(X, Y, C_in, sum, C_out);             <span class="comment">// 全加器模块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span> X;</span><br><span class="line"><span class="keyword">input</span> Y;</span><br><span class="line"><span class="keyword">input</span> C_in;</span><br><span class="line"><span class="keyword">output</span> sum;</span><br><span class="line"><span class="keyword">output</span> C_out;</span><br><span class="line"></span><br><span class="line"><span class="keyword">wire</span> HalfAdd_A_sum;</span><br><span class="line"><span class="keyword">wire</span> HalfAdd_A_Cout;</span><br><span class="line"><span class="keyword">wire</span> HalfAdd_B_Cout;</span><br><span class="line"></span><br><span class="line"><span class="comment">// assign C_out = HalfAdd_A_Cout | HalfAdd_B_Cout;</span></span><br><span class="line"><span class="keyword">or</span> u_or(C_out, HalfAdd_A_Cout, HalfAdd_B_Cout);     <span class="comment">// 门级原语实例</span></span><br><span class="line"></span><br><span class="line">HalfAdd u_HalfAdd_A(                                <span class="comment">// 半加器实例 A</span></span><br><span class="line">    <span class="variable">.X</span>      (C_in),</span><br><span class="line">    <span class="variable">.Y</span>      (Y),</span><br><span class="line">    <span class="variable">.sum</span>    (HalfAdd_A_sum),</span><br><span class="line">    <span class="variable">.C_out</span>  (HalfAdd_A_Cout)</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">HalfAdd u_HalfAdd_B(                                <span class="comment">// 半加器实例 B</span></span><br><span class="line">    <span class="variable">.X</span>      (C_in),</span><br><span class="line">    <span class="variable">.Y</span>      (HalfAdd_A_sum),</span><br><span class="line">    <span class="variable">.sum</span>    (sum),</span><br><span class="line">    <span class="variable">.C_out</span>  (HalfAdd_B_Cout)</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line"><span class="keyword">endmodule</span> </span><br></pre></td></tr></table></figure>
<p>上例已将<a href="#半加器代码">原半加器代码</a>中的语句改为门原语的实例化。在全加器的模块中，有两个半加器模块的实例和一个 <code>or</code> 门原语的实例。</p>
<p>在以上代码中，实例化的 <code>or</code> 门原语是 Verilog 语言自带的电路，实例化的半加器模块则是用户自己设计的模块。</p>
<p>实现电路如下图。</p>
<div align="center">
  <img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-30-josh-verilog-part-3/2020-11-30-josh-verilog-part-3-150-FullAdder.png!sign"/>
</div>

<p>以上内容提到了实例化基本门和其他模块。</p>
<p>关于 UDP，它是用户自定义的原语，由于应用不广泛，其功能基本上可以由模块替代，因此不再介绍。</p>
<h2 id="4-1-实例化模块的方法"><a href="#4-1-实例化模块的方法" class="headerlink" title="4.1. 实例化模块的方法"></a>4.1. 实例化模块的方法</h2><p>在结构化描述中，需要将模块实例与外部信号相连接。下面谈谈模块实例的端口连接规则。</p>
<p>先看一个模块内部输入/输出/双向端口的内部属性：</p>
<ul>
<li><strong><code>input</code>：在模块内部默认是一个线网类型；</strong></li>
<li><strong><code>output</code>：在模块内部是一个寄存器（在过程赋值语句中被赋值）或者线网类型；</strong></li>
<li><strong><code>inout</code>：在模块内部默认是一个线网类型，是双向信号，一般定义为 <code>tri</code>。</strong></li>
</ul>
<p>当这个模块被实例化时，与之相连的信号类型如下：</p>
<ul>
<li><strong>与模块 <code>input</code> 端口相连：可以是一个线网或者寄存器；</strong></li>
<li><strong>与模块 <code>output</code> 端口相连：一定是驱动到一个线网；</strong></li>
<li><strong>与模块 <code>inout</code> 端口相连：输入时从一个线网驱动来，输出时驱动到一个线网。</strong></li>
</ul>
<p>初学者经常犯这样一个错误，将寄存器变量驱动 <code>inout</code> 端口，导致编译出错。因为，只有线网类型可以驱动 <code>inout</code> 端口。</p>
<p>下图清楚地了模块端口在内部和外部的类型。</p>
<div align="center">
  <img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-30-josh-verilog-part-3/2020-11-30-josh-verilog-part-3-160-ModuleConnection.png!sign"/>
</div>

<p>下面举例说明模块内部和外部的端口：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">HalfAdd u_HalfAdd_A(                                <span class="comment">// 半加器实例 A</span></span><br><span class="line">    <span class="variable">.X</span>      (C_in),</span><br><span class="line">    <span class="variable">.Y</span>      (Y),</span><br><span class="line">    <span class="variable">.sum</span>    (HalfAdd_A_sum),</span><br><span class="line">    <span class="variable">.C_out</span>  (HalfAdd_A_Cout)</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>
<p>点 <code>.</code> 后面紧跟的信号是 <code>HalfAdd</code> 内的端口名称，而括号中的信号是上一层 <code>FullAdd</code> 模块中的驱动源或被驱动信号。</p>
<p>模块实例的端口对应方式有以下两种：名称对应及位置对应。</p>
<p>所谓名称对应是指：将模块实例外部的信号直接对应于模块的端口名称。在实例化 <code>HalfAdd</code> 时就是采用了名称对应的方法。</p>
<p>在这种端口对应方式下，端口对应的顺序可以是任意的。在没有对应外部信号的时候，可以将端口后面的括号留空。如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">模块 实例名称(</span><br><span class="line">    .模块端口名称           (实例外部信号),</span><br><span class="line">    .模块端口名称           (实例外部信号),</span><br><span class="line">    .模块端口名称           (),             <span class="comment">//无对应信号</span></span><br><span class="line">    ...);</span><br></pre></td></tr></table></figure>
<p>位置对应方式就是在模块实例化的时候外部的信号需要按照该模块端口声明的顺序一一对应。例如：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> HalfAdd(X, Y, sum, C_out);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>在实例化该模块的时候，可以使用：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">HaIfAdd u_HalfAdd(E_X, E_Y, E_sum, E_C_out);</span><br></pre></td></tr></table></figure>
<p>其中 <code>E_X</code>、<code>E_Y</code>、<code>E_sum</code> 和 <code>E_C_out</code> 分别对应 <code>HalfAdd</code> 的端口 <code>X</code>、<code>Y</code>、<code>sum</code> 和 <code>C_out</code>，严格按照<code>HalfAdd</code> 模块的端口位置顺序。如果在没有对应外部信号的时候，就需要将位置留空。例如：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">HaIfAdd u_HalfAdd(E_X, E_Y, , E_C_out);</span><br></pre></td></tr></table></figure>
<p>其中 <code>E_X</code>、<code>E_Y</code> 和 <code>E_C_out</code> 分别对应 <code>HaIfAdd</code> 的端口 <code>X</code>、<code>Y</code> 和 <code>C_out</code>，模块端口 <code>sum</code> 没有对应的外部信号。</p>
<h2 id="4-2-参数"><a href="#4-2-参数" class="headerlink" title="4.2. 参数"></a>4.2. 参数</h2><p>在本小节中将讨论可参数化的模块。</p>
<h3 id="4-2-1-参数定义"><a href="#4-2-1-参数定义" class="headerlink" title="4.2.1. 参数定义"></a>4.2.1. 参数定义</h3><p><code>module</code> 中的参数一般是定义其中常量的工具。</p>
<p>如下的代码中定义了半加器的“与门”和“异或门”的延时分别为 2 和 4 个时间单位：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> half_adder(co, sum, a, b)</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span> a, b;</span><br><span class="line"><span class="keyword">output</span> co, sum;</span><br><span class="line"></span><br><span class="line"><span class="keyword">parameter</span> and_delay = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">parameter</span> xor_delay = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">and</span> #and_delay u1(co, a, b);</span><br><span class="line"><span class="keyword">xor</span> #xor_delay u2(sum, a, b);</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>实际上，在 Verilog 语言中，<strong>当实例化模块时用户可以修改模块中的参数</strong>，用来实现不同的特性。这个定制过程是通过“新参数直接带入”或“参数重定义”完成的。</p>
<p>Verilog 模块参数的这一特性非常有用，用户可以定义一个通用的模块，其具有缺省的参数值，然后通过改变参数来做成不同的实例模块。</p>
<p>例如，可以设计一个通用的 RAM 模块，将其位宽和地址深度定义为参数。在具体使用时，如果需要用到不同的位宽和深度，用户则可以通过改变模块中的参数实现。</p>
<h3 id="4-2-2-参数的定制"><a href="#4-2-2-参数的定制" class="headerlink" title="4.2.2. 参数的定制"></a>4.2.2. 参数的定制</h3><p>参数的用户定制有两种方法：</p>
<ol>
<li>通过 <code>defparam</code> 关键字对模块中的参数重新定义；</li>
<li>参数直接在实例化模块时代入。</li>
</ol>
<p>有意思的是，两家最大的 PLD 供应商 Altera 和 Xilinx 的通用模块定制恰好分别采用了这两种方法。<br>比如 Altera 的 Quartus II 开发环境中，用 MegaWiard 工具定制一个宽 8 深 32 位的单口 RAM 时，将产生如下的代码：</p>
<figure class="highlight verilog"><figcaption><span>ran_w8_d32.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> ran_w8_d32(address, clock, data, wren, q);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span> [<span class="number">4</span>:<span class="number">0</span>] address;</span><br><span class="line"><span class="keyword">input</span>       clock;</span><br><span class="line"><span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>] data;</span><br><span class="line"><span class="keyword">input</span>       wren;</span><br><span class="line"><span class="keyword">output</span>      q;</span><br><span class="line"></span><br><span class="line">altsyncram altsyncram_component(</span><br><span class="line">    <span class="variable">.wren_a</span>        (wren),</span><br><span class="line">    <span class="variable">.clock0</span>        (clock),</span><br><span class="line">    <span class="variable">.address_a</span>     (address),</span><br><span class="line">    <span class="variable">.data_a</span>        (data),</span><br><span class="line">    <span class="variable">.q_a</span>           (q),</span><br><span class="line">    <span class="variable">.aclr0</span>         (<span class="number">1&#x27;b0</span>),</span><br><span class="line">    <span class="variable">.aclr1</span>         (<span class="number">1&#x27;b0</span>),</span><br><span class="line">    <span class="variable">.q_b</span>           (),</span><br><span class="line">    <span class="variable">.clocken1</span>      (<span class="number">1&#x27;b1</span>),</span><br><span class="line">    <span class="variable">.clocken0</span>      (<span class="number">1&#x27;b0</span>),</span><br><span class="line">    <span class="variable">.data_b</span>        (<span class="number">1&#x27;b1</span>),</span><br><span class="line">    <span class="variable">.rden_b</span>        (<span class="number">1&#x27;b1</span>),</span><br><span class="line">    <span class="variable">.address_b</span>     (<span class="number">1&#x27;b1</span>),</span><br><span class="line">    <span class="variable">.wren_b</span>        (<span class="number">1&#x27;b0</span>),</span><br><span class="line">    <span class="variable">.byteena_b</span>     (<span class="number">1&#x27;b0</span>),</span><br><span class="line">    <span class="variable">.addressstall_a</span>(<span class="number">1&#x27;b0</span>),</span><br><span class="line">    <span class="variable">.byteena_a</span>     (<span class="number">1&#x27;b1</span>),</span><br><span class="line">    <span class="variable">.addressstall_b</span>(<span class="number">1&#x27;b0</span>),</span><br><span class="line">    <span class="variable">.clocken1</span>      (<span class="number">1&#x27;b1</span>)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line"><span class="keyword">defparam</span></span><br><span class="line">    altsyncram_component<span class="variable">.clock_enable_input_a</span> = <span class="string">&quot;BYPASS&quot;</span>,</span><br><span class="line">    altsyncram_component<span class="variable">.clock_enable_output_a</span> = <span class="string">&quot;BYPASS&quot;</span>,</span><br><span class="line">    altsyncram_component<span class="variable">.intended_device_family</span> = <span class="string">&quot;Stratix II&quot;</span>,</span><br><span class="line">    altsyncram_component<span class="variable">.lpm_hint</span> = <span class="string">&quot;ENABLE_RUNTIME_MOD = NO&quot;</span>,</span><br><span class="line">    altsyncram_component<span class="variable">.lpm_type</span> = <span class="string">&quot;altsyncram&quot;</span>,</span><br><span class="line">    altsyncram_component<span class="variable">.numwords_a</span> = <span class="number">32</span>,               <span class="comment">// 32 个字</span></span><br><span class="line">    altsyncram_component<span class="variable">.operation_mode</span> = <span class="string">&quot;SINGLE_PORT&quot;</span>,</span><br><span class="line">    altsyncram_component<span class="variable">.outdata_aclr_a</span> = <span class="string">&quot;NONE&quot;</span>,</span><br><span class="line">    altsyncram_component<span class="variable">.outdata_reg_a</span> = <span class="string">&quot;UNREGISTERED&quot;</span>,</span><br><span class="line">    altsyncram_component<span class="variable">.power_up_uninitialized</span> = <span class="string">&quot;FALSE&quot;</span>,</span><br><span class="line">    altsyncram_component<span class="variable">.ram_block_type</span> = <span class="string">&quot;M4K&quot;</span>,</span><br><span class="line">    altsyncram_component<span class="variable">.widthad_a</span> = <span class="number">5</span>,                 <span class="comment">// 5 位地址</span></span><br><span class="line">    altsyncram_component<span class="variable">.width_a</span> = <span class="number">8</span>,                   <span class="comment">// 8 位宽的数据</span></span><br><span class="line">    altsyncram_component<span class="variable">.width_byteena_a</span> = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>其中，<code>altsyncram</code> 是 Altera 的块 RAM 的通用模型。它可以在 Altera 的仿真文件“alteramf.v”中找到。</p>
<p><code>altsyncram-component</code> 是实例名称，<code>.</code> 后面是参数的名称，定义的参数值，有的是字符串，有的是整数。</p>
<p>在 <code>defparam</code> 关键字后面的是参数重定义的语句：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">altsyncram_component<span class="variable">.width_a</span> = <span class="number">8</span>,               <span class="comment">// 8 位宽的数据</span></span><br></pre></td></tr></table></figure>
<p>以上就是将 <code>altsyncram-component</code> 中的参数 <code>width_a</code> 重新定义为 8。</p>
<p>使用 <code>defparam</code> 的方法重新定义参数时，可以根据需要对部分的参数重新定义，其他的会保留模块的缺省值。</p>
<p>用 Xilinx 设计工具 ISE 中的 CORE Generator 产生一个单端口 8 位宽、32 位深的 RAM。注意观察，其中RAM的参数是如何带入的：</p>
<figure class="highlight verilog"><figcaption><span>ram_w8_d32.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> ram_w8_d32(addr, clk, din, dout, we)</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span> [<span class="number">4</span>:O] addr;</span><br><span class="line"><span class="keyword">input</span>       clk;</span><br><span class="line"><span class="keyword">input</span> [<span class="number">7</span>:O] din.</span><br><span class="line"><span class="keyword">output</span> [<span class="number">7</span>:<span class="number">0</span>] dout;</span><br><span class="line"><span class="keyword">input</span> we;</span><br><span class="line"></span><br><span class="line"><span class="comment">// synopsys translate_off</span></span><br><span class="line">BLKMEMSP_V6_1 #(</span><br><span class="line">    <span class="number">5</span>,                  <span class="comment">// c_addr_width</span></span><br><span class="line">    <span class="string">&quot;0&quot;</span>,                <span class="comment">// c_default_data</span></span><br><span class="line">    <span class="number">32</span>,                 <span class="comment">// c_depth</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">// c_enable_rlocs</span></span><br><span class="line">    <span class="number">1</span>,                  <span class="comment">// c_has_default_data</span></span><br><span class="line">    <span class="number">1</span>,                  <span class="comment">// c_has_din</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">// c_has_en</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">// c_has_limit_data_pitch</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">// c_has_nd</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">// c_has_rdy</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">// c_has_rfd</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">// c_has_sinit</span></span><br><span class="line">    <span class="number">1</span>,                  <span class="comment">// c_has_we</span></span><br><span class="line">    <span class="number">18</span>,                 <span class="comment">// c_limit_data_pitch</span></span><br><span class="line">    <span class="string">&quot;mif_file_16_1&quot;</span>,    <span class="comment">// c_em_init_file</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">// c_pipe_stages</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">// c_reg_inputs</span></span><br><span class="line">    <span class="string">&quot;0&quot;</span>,                <span class="comment">// c_sinit_value</span></span><br><span class="line">    <span class="number">8</span>,                  <span class="comment">// c_width</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">// c_write_mode</span></span><br><span class="line">    <span class="string">&quot;0&quot;</span>,                <span class="comment">// c_ybottom_addr</span></span><br><span class="line">    <span class="number">1</span>,                  <span class="comment">// c_yclk_is_rising</span></span><br><span class="line">    <span class="number">1</span>,                  <span class="comment">// c_yen_is_high</span></span><br><span class="line">    <span class="string">&quot;hierarchy1&quot;</span>,       <span class="comment">// c_hierarchy</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">// c_ymake_bmm</span></span><br><span class="line">    <span class="string">&quot;32kx1&quot;</span>,            <span class="comment">// c_yprimitive_type</span></span><br><span class="line">    <span class="number">1</span>,                  <span class="comment">// c_ysinit_is_high</span></span><br><span class="line">    <span class="string">&quot;1024&quot;</span>,             <span class="comment">// c_ytop_addr</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">// c_yuse_single_primitive</span></span><br><span class="line">    <span class="number">1</span>,                  <span class="comment">// c_ywe_is_high</span></span><br><span class="line">    <span class="number">1</span>                   <span class="comment">// c_yydisable_warnings</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">inst(</span><br><span class="line">    <span class="variable">.ADDR</span> (addr),</span><br><span class="line">    <span class="variable">.CLK</span>  (clk),</span><br><span class="line">    <span class="variable">.DIN</span>  (din),</span><br><span class="line">    <span class="variable">.DOUT</span> (dout),</span><br><span class="line">    <span class="variable">.WE</span>   (we),</span><br><span class="line">    <span class="variable">.EN</span>   (),</span><br><span class="line">    <span class="variable">.ND</span>   (),</span><br><span class="line">    <span class="variable">.RFD</span>  (),</span><br><span class="line">    <span class="variable">.RDY</span>  (),</span><br><span class="line">    <span class="variable">.SINIT</span>()</span><br><span class="line">    );</span><br><span class="line"><span class="comment">// synopsys translate_on</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>其中 <code>BLKMEMSP_V6_1</code> 是 Xilinx 的块状RAM的通用模型。<code>inst</code> 是用户实例名称。用户需要在通用RAM类型的基础上，通过参数带入实现。采用 <code>#(...)</code> 方法来实现参数逐个覆盖。</p>
<p>使用上面这种参数直接带入法时，要注意一点，所有的参数都需要全部按顺序列出来，不能遗漏，也不能颠倒顺序，否则就容易对应不上。</p>
<h1 id="5-设计层次"><a href="#5-设计层次" class="headerlink" title="5. 设计层次"></a>5. 设计层次</h1><p>在前面几节中，介绍了 Verilog 的描述方式。<br>Verilog 语言是一种强大的硬件描述语言，可以支持多个设计层次。在这里将进行简单的介绍。</p>
<h2 id="5-1-系统级和行为级"><a href="#5-1-系统级和行为级" class="headerlink" title="5.1. 系统级和行为级"></a>5.1. 系统级和行为级</h2><p>Verilog 语言作为一种用户工具，提供给用户许多描述硬件的手段，如前面所述：数据流描述、行为描述（<code>always</code> 和 <code>initial</code> 语句）、结构化描述。同时，不同用户可以根据自己的需要，在不同抽象层次上对硬件进行描述。有如下设计层次金字塔供参考。</p>
<div align="center">
  <img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-30-josh-verilog-part-3/2020-11-30-josh-verilog-part-3-170-DesignLevelPyramid.png!600px"/>
</div>

<p>下面简单介绍几种不同角色的工作特点，以及它们所处的设计层次：</p>
<p>系统构架师：在目前业界主流的设计方法学中，系统构架师（System Architect）通常用高级语言，如SystemC，来描述一个系统的规格，仿真整个系统的功能和性能等。这种早期的设计和探索往往不涉及到具体的实现细节，甚至于软件和硬件的划分都没有开始。系统构架师也可以采用 Verilog 来描述系统的功能，它们往往不考虑硬件实现的细节。因而称这种设计层次为系统级或算法级。</p>
<p>逻辑设计工程师：他们利用前面所讲的 Verilog 各种描述手段，设计 RTL 级的代码，精确到时钟周期。逻辑设计工程师的代码，通过综合工具的综合，可以转换为 Verilog 的门级网表，其中所有的功能块都是由基本的门单元组成的。</p>
<p>物理设计工程师：他们将这些门级网表进行布局和布线，做成实际的芯片。</p>
<p>验证工程师：他们负责对设计的电路进行验证，他们编写的代码主要是用来产生激励，这些激励大部分需要的抽象层次更高，以使仿真的效率更高。然后在工具中对电路进行仿真，检查响应结果。这些代码不会实现为具体癭件，有些并不需要精确到时钟周期，而只是在软件的仿真工具中运行，实现一定的功能即可，称这种描述层次为行为级。</p>
<p>这里的行为级描述，不同于 <a href="#03">3. 行为描述</a>中所述的“行为描述方式”。这里特指一种描述的抽象层次。</p>
<p>下面举一个实例说明 RTL 级和行为级的区别，要实现的状态机一部分如下图所示。</p>
<div align="center">
  <img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-30-josh-verilog-part-3/2020-11-30-josh-verilog-part-3-180-ASimpleHandshakingStateMachine.png!500px"/>
</div>

<p>上图中只有两个状态，当在左边的状态时，<code>REQ</code> 输出 1；当在右边的状态时，<code>REQ</code> 输出 0。<code>ACK</code> 是状态机的输人信号，决定了状态的跳转。</p>
<p>如果是让一个 RTL 设计工程师来设计，他马上就会与硬件实现的细节联系起来，很可能就会用如下代码实现：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">/************************</span></span><br><span class="line"><span class="comment">RTL 描述</span></span><br><span class="line"><span class="comment">************************/</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>] curr_sm;</span><br><span class="line"><span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>] next_sm;              <span class="comment">// 定义状态寄存器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">parameter</span> ...;</span><br><span class="line">state0 = <span class="number">2&#x27;b01</span>;</span><br><span class="line">state1 = <span class="number">2&#x27;b10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// state registers</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">posedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (rst)</span><br><span class="line">        curr_sm &lt;= ...;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        curr_sm &lt;= next_sm;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// next state logic</span></span><br><span class="line"><span class="keyword">always</span> @(curr_sm <span class="keyword">or</span> ACK) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">case</span>(curr_sm)</span><br><span class="line">        ...</span><br><span class="line">        state0: <span class="keyword">begin</span></span><br><span class="line">            REQ = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (ACK == <span class="number">1</span>)</span><br><span class="line">                next_sm = state1;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                next_sm = state0;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        state1: <span class="keyword">begin</span></span><br><span class="line">            REQ = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (ACK == <span class="number">0</span>)</span><br><span class="line">                next_sm = ...;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                next_sm = state1;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>然而，如果让一个逻辑验证工程师来设计这个状态机，他不考虑硬件实现的细节，只需要在语义上满足要求即可。甚至可以不出现状态寄存器。如下例：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">/************************</span></span><br><span class="line"><span class="comment">行为描述</span></span><br><span class="line"><span class="comment">************************/</span></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    ...</span><br><span class="line">    REQ = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">wait</span> (ACK == <span class="number">1</span>);</span><br><span class="line">    REQ = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">wait</span> (ACK == <span class="number">0</span>);</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>从上例中可以看出，逻辑验证工程师设计的方式十分简单，仅仅利用了 <code>begin ... end</code> 语句组的顺序执行特性，同时利用 <code>wait</code> 语句来实现状态的转移。这是典型的行为级设计风格，也是逻辑验证工程师们所追求的思维方式。</p>
<h2 id="5-2-RTL-级"><a href="#5-2-RTL-级" class="headerlink" title="5.2. RTL 级"></a>5.2. RTL 级</h2><p>所谓寄存器传输级（RTL级），就是描述电路的时候，只需要关注寄存器本身，以及寄存器到寄存器之间的逻辑功能，而不用关心寄存器和组合逻辑的实现细节（具体用了多少逻辑门等）。</p>
<p>随着逻辑综合工具的兴起，工程师才可以从 RTL 级进行电路设计了，而不需要像传统设计方法一样从门级电路搭起。它们的 RTL 设计代码将直接通过逻辑综合工具，综合成门级的设计网表，通常是由基本的门单元组成的。逻辑综合是 EDA 流程的重要组成部分。</p>
<p>Verilog 设计电路最常用的设计层次就是 RTL 级。在 RTL 描述时，设计者需要关注寄存器的行为，其中保存着数据；同时需要关注寄存器和寄存器之间的组合逻辑功能，是否能满足功能需求和时序需求。RTL 级模型是严格精确到时钟周期的模型。</p>
<p>后续会重点介绍 RTL 设计的方法和技巧。</p>
<blockquote>
<p>RTL 级是 HDL 语言最重要的概念之一，RTL 级是综合器最常用的设计输入层次。目前使用 FPGA/CPLD 等可编程逻辑器件时，设计输入都为 RTL 级。这是因为门级输入过于繁琐；而对于行为级和系统级设计输入，很多综合器不支持，并容易产生综合歧义。</p>
</blockquote>
<h2 id="5-3-门级"><a href="#5-3-门级" class="headerlink" title="5.3. 门级"></a>5.3. 门级</h2><p>在 Verilog 语义中，使用一些基本的门原语可以直接描述电路的门级功能。例如：</p>
<figure class="highlight verilog"><figcaption><span>HalfAdd.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> HalfAdd(X, Y, sum, C_out);                   <span class="comment">// 半加器模块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span> X;</span><br><span class="line"><span class="keyword">input</span> Y;</span><br><span class="line"><span class="keyword">output</span> sum;</span><br><span class="line"><span class="keyword">output</span> C_out;</span><br><span class="line"></span><br><span class="line"><span class="keyword">xor</span> u_xor(sum, X, Y);                               <span class="comment">// 门级原语实例</span></span><br><span class="line"><span class="keyword">and</span> u_and(C_out, X, Y);                             <span class="comment">// 门级原语实例</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span> </span><br></pre></td></tr></table></figure>
<p>其中直接调用了 <code>xor</code> 和 <code>and</code> 的两个 Verilog 门原语。</p>
<p>门级设计就是指在逻辑门一级将电路搭出来。特别是对于大设计来说，这种设计非常耗时、效率低下，同时容易出错。但是对于一些逻辑容量较小，性能和面积要求非常高的设计，有时还采用门级设计，以满足一些特殊的需求。</p>
<p>门级设计类似于软件中的汇编语言设计，非常精确，但是耗时耗力。</p>
<h2 id="5-4-晶体管级"><a href="#5-4-晶体管级" class="headerlink" title="5.4. 晶体管级"></a>5.4. 晶体管级</h2><p>逻辑门是由一个个晶体管组成的。在 Verilog 语言中，有用于直接描述 NMOS 和 PMOS 的原语。这里不过多叙述，有兴趣可查阅相关资料。</p>
<h2 id="5-5-混合描述"><a href="#5-5-混合描述" class="headerlink" title="5.5. 混合描述"></a>5.5. 混合描述</h2><p>Verilog 支持不同设计层次的混描述。</p>
<p>实际上，这些描述层次之间没有严格的界限。这里只是想将概念描述清楚，这一点对初学者非常重要。</p>
<hr>
<p>在本篇笔记中，重点介绍了 Verilog 的 3 种描述方式以及 Verilog 可以应用的设计层次。至此，大家应该能感受到 Verilog 语言是一种非常灵活、强大的硬件描述语言。</p>
]]></content>
      <categories>
        <category>Verilog</category>
        <category>Josh 的学习笔记</category>
        <category>Verilog</category>
        <category>Verilog 设计</category>
      </categories>
      <tags>
        <tag>Verilog</tag>
        <tag>HDL</tag>
        <tag>Verilog 语法</tag>
        <tag>描述方式</tag>
        <tag>谁急层次</tag>
      </tags>
  </entry>
</search>
