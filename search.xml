<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>MATLAB 函数 —— rcosdesign</title>
    <url>/posts/5c45edfe.html</url>
    <content><![CDATA[<p><code>rcosdesign</code>：升余弦 FIR 脉冲成型滤波器设计</p>
<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><p><code>b = rcosdesign(beta,span,sps)</code><br><code>b = rcosdesign(beta,span,sps,shape)</code></p>
<a id="more"></a>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p><code>b = rcosdesign(beta,span,sps)</code> 返回系数 <code>b</code>，该系数对应于具有由 <code>beta</code> 指定的衰减因子的平方根升余弦 FIR 滤波器。滤波器有 <code>span</code> 个符号，每个符号包含 <code>sps</code> 个样本。 滤波器的阶次，也即 <code>sps * span</code> 必须是偶数。滤波器的能量为 1。<a href="#Examples-01">举例</a></p>
<p><code>b = rcosdesign(beta,span,sps,shape)</code> 根据 <code>shape</code> 返回不同的滤波器。当 <code>shape</code> 为 <code>sqrt</code> 时，将返回根升余弦滤波器；当 <code>shape</code> 为 <code>normal</code> 时，将返回升余弦 FIR 滤波器。<a href="#Examples-02">举例</a></p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><h2 id="设计根升余弦滤波器"><a href="#设计根升余弦滤波器" class="headerlink" title="设计根升余弦滤波器"></a>设计根升余弦滤波器<span id="Examples-01"></span></h2><p>将滚降系数设为 <code>0.25</code>，波器的符号数设为 <code>6</code>，每个符号 <code>4</code> 个采样点。验证 <code>sqrt</code> 是 <code>shape</code> 参数的默认值。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">h <span class="built_in">=</span> rcosdesign(<span class="number">0.25</span>,<span class="number">6</span>,<span class="number">4</span>);</span><br><span class="line">mx <span class="built_in">=</span> max(abs(h-rcosdesign(<span class="number">0.25</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="string">&#x27;sqrt&#x27;</span>)))</span><br></pre></td></tr></table></figure>
<blockquote>
<p><font face="Consolas">mx = 0</font><br></p>
</blockquote>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">fvtool(h,<span class="string">&#x27;Analysis&#x27;</span>,<span class="string">&#x27;impulse&#x27;</span>)</span><br></pre></td></tr></table></figure>
<div align="center">
  <img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-25-matlab-rcosdesign/2020-11-25-matlab-rcosdesign-010-DesignASquareRootRaisedCosineFilterExample-01.png?imageMogr2/thumbnail/!100p|watermark/2/text/QEpvc2ggR2Fv/fontsize/15/dissolve/60/gravity/southeast/dx/5/dy/5"/>
</div>

<h2 id="升余弦和根升余弦滤波器的脉冲响应"><a href="#升余弦和根升余弦滤波器的脉冲响应" class="headerlink" title="升余弦和根升余弦滤波器的脉冲响应"></a>升余弦和根升余弦滤波器的脉冲响应<span id="Examples-02"></span></h2><p>将升余弦滤波器与根升余弦滤波器进行比较。一个理想的（无限长）升余弦脉冲成型滤波器等效于两个级联的理想的根升余弦滤波器。因此，FIR 升余弦滤波器的脉冲响应应类似于与其自身卷积的根升余弦滤波器的脉冲响应。</p>
<p>设计一个衰减为 <code>0.25</code> 的升余弦滤波器。指定滤波器有 <code>4</code> 个符号，每个符号 <code>3</code> 个采样点。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">rf <span class="built_in">=</span> <span class="number">0.25</span>;</span><br><span class="line">span <span class="built_in">=</span> <span class="number">4</span>;</span><br><span class="line">sps <span class="built_in">=</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">h1 <span class="built_in">=</span> rcosdesign(rf,span,sps,<span class="string">&#x27;normal&#x27;</span>);</span><br><span class="line">fvtool(h1,<span class="string">&#x27;impulse&#x27;</span>)</span><br></pre></td></tr></table></figure>
<div align="center">
  <img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-25-matlab-rcosdesign/2020-11-25-matlab-rcosdesign-020-ImpulseResponsesOfNormalAndSquareRootRaisedCosineFiltersExample-01.png?imageMogr2/thumbnail/!100p|watermark/2/text/QEpvc2ggR2Fv/fontsize/15/dissolve/60/gravity/southeast/dx/5/dy/5"/>
</div>

<p><strong>升余弦滤波器在 <code>sps</code> 的整数倍处具有零值点</strong>。因此，它满足无码间串扰（ISI）的 Nyquist 准则。但是，根升余弦滤波器没有这样的特性：</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">h2 <span class="built_in">=</span> rcosdesign(rf,span,sps,<span class="string">&#x27;sqrt&#x27;</span>);</span><br><span class="line">fvtool(h2,<span class="string">&#x27;impulse&#x27;</span>)</span><br></pre></td></tr></table></figure>
<div align="center">
  <img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-25-matlab-rcosdesign/2020-11-25-matlab-rcosdesign-030-ImpulseResponsesOfNormalAndSquareRootRaisedCosineFiltersExample-02.png?imageMogr2/thumbnail/!100p|watermark/2/text/QEpvc2ggR2Fv/fontsize/15/dissolve/60/gravity/southeast/dx/5/dy/5"/>
</div>

<p>将根升余弦滤波器与自身进行卷积。在最大值处截断脉冲响应，使其长度与 <code>h1</code> 相同。使用最大值将响应归一化。然后，将卷积后的根升余弦滤波器与升余弦滤波器进行比较。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">h3 <span class="built_in">=</span> conv(h2,h2);</span><br><span class="line">p2 <span class="built_in">=</span> ceil(length(h3)/<span class="number">2</span>);</span><br><span class="line">m2 <span class="built_in">=</span> ceil(p2-length(h1)/<span class="number">2</span>);</span><br><span class="line">M2 <span class="built_in">=</span> floor(p2+length(h1)/<span class="number">2</span>);</span><br><span class="line">ct <span class="built_in">=</span> h3(m2:M2);</span><br><span class="line"></span><br><span class="line">stem([h1/max(abs(h1));ct/max(abs(ct))]<span class="string">&#x27;,&#x27;</span>filled<span class="string">&#x27;)</span></span><br><span class="line"><span class="string">xlabel(&#x27;</span>Samples<span class="string">&#x27;)</span></span><br><span class="line"><span class="string">ylabel(&#x27;</span>Normalized amplitude<span class="string">&#x27;)</span></span><br><span class="line"><span class="string">legend(&#x27;</span>h1<span class="string">&#x27;,&#x27;</span>h2 * h2<span class="string">&#x27;)</span></span><br></pre></td></tr></table></figure>
<div align="center">
  <img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-25-matlab-rcosdesign/2020-11-25-matlab-rcosdesign-040-ImpulseResponsesOfNormalAndSquareRootRaisedCosineFiltersExample-03.png?imageMogr2/thumbnail/!100p|watermark/2/text/QEpvc2ggR2Fv/fontsize/15/dissolve/60/gravity/southeast/dx/5/dy/5"/>
</div>

<p>卷积响应的长度是有限的，因此根升余弦滤波器与自身进行卷积得到的结果会与升余弦滤波器不一致。增加 <code>span</code> 可以在响应之间获得更紧密的一致性，并更好地符合 Nyquist 准则。</p>
<h2 id="将信号通过升余弦滤波器"><a href="#将信号通过升余弦滤波器" class="headerlink" title="将信号通过升余弦滤波器"></a>将信号通过升余弦滤波器<span id="Examples-03"></span></h2><p>本例说明如何将信号通过根升余弦滤波器。</p>
<p>指定滤波器参数。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">rolloff <span class="built_in">=</span> <span class="number">0.25</span>;     <span class="comment">% 滚降因子</span></span><br><span class="line">span <span class="built_in">=</span> <span class="number">6</span>;           <span class="comment">% 滤波器宽度（符号数）</span></span><br><span class="line">sps <span class="built_in">=</span> <span class="number">4</span>;            <span class="comment">% 每个符号的样本数</span></span><br></pre></td></tr></table></figure>
<p>生成根升余弦滤波器的系数。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">b <span class="built_in">=</span> rcosdesign(rolloff, span, sps);</span><br></pre></td></tr></table></figure>
<p>生成双极性数据向量。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">d <span class="built_in">=</span> <span class="number">2</span>*randi([<span class="number">0</span> <span class="number">1</span>], <span class="number">100</span>, <span class="number">1</span>) - <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>上采样并对数据进行滤波以实现脉冲成型。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">x <span class="built_in">=</span> upfirdn(d, b, sps);</span><br></pre></td></tr></table></figure>
<p>添加噪声。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">r <span class="built_in">=</span> x + randn(size(x))*<span class="number">0.01</span>;</span><br></pre></td></tr></table></figure>
<p>对接收到的信号进行滤波和下采样以进行匹配滤波。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">y <span class="built_in">=</span> upfirdn(r, b, <span class="number">1</span>, sps);</span><br></pre></td></tr></table></figure>
<p>有关如何使用根升余弦滤波器对信号进行插值和抽取的信息，请参见使<a href="https://ww2.mathworks.cn/help/comm/ug/interpolate-and-decimate-using-rrc-filter.html">用 RRC 滤波器进行插值和抽取</a>（Communications Toolbox）。</p>
<h1 id="输入参数"><a href="#输入参数" class="headerlink" title="输入参数"></a>输入参数</h1><h2 id="beta-滚降系数"><a href="#beta-滚降系数" class="headerlink" title="beta - 滚降系数"></a><code>beta</code> - 滚降系数</h2><p>滚降系数，指定为不大于 <code>1</code> 的<strong>实非负标量</strong>。滚降系数决定滤波器的多余带宽。滚降系数为 <code>0</code> 时为矩形滤波器（brick-wall filter），滚降因子为 <code>1</code> 时为纯升余弦滤波器。</p>
<p><strong>数据类型</strong>：<code>double</code> | <code>single</code></p>
<h2 id="span-符号数"><a href="#span-符号数" class="headerlink" title="span - 符号数"></a><code>span</code> - 符号数</h2><p>符号数，指定为<strong>正整数标量</strong>。</p>
<p><strong>数据类型</strong>：<code>double</code> | <code>single</code></p>
<h2 id="sps-每个符号的样本数"><a href="#sps-每个符号的样本数" class="headerlink" title="sps - 每个符号的样本数"></a><code>sps</code> - 每个符号的样本数</h2><p>每个符号的样本数（上采样因子），指定为<strong>正整数标量</strong>。</p>
<p><strong>数据类型</strong>：<code>double</code> | <code>single</code></p>
<h2 id="shape-升余弦滤波器的形状"><a href="#shape-升余弦滤波器的形状" class="headerlink" title="shape - 升余弦滤波器的形状"></a><code>shape</code> - 升余弦滤波器的形状</h2><p>升余弦滤波器的形状，指定为 <code>normal</code> 或 <code>sqrt</code>。</p>
<h1 id="输出参数"><a href="#输出参数" class="headerlink" title="输出参数"></a>输出参数</h1><h2 id="b-FIR-滤波器系数"><a href="#b-FIR-滤波器系数" class="headerlink" title="b - FIR 滤波器系数"></a><code>b</code> - FIR 滤波器系数</h2><p>升余弦滤波器的系数，以<strong>列向量</strong>的形式返回。</p>
<p><strong>数据类型</strong>：<code>double</code> | <code>single</code></p>
<h1 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h1><ul>
<li>如果您拥有 Communications Toolbox™ 软件的许可证，则可以执行具有流传输行为的多速率升余弦滤波。为此，请使用 System object™ 滤波器——<code>comm.RaisedCosineTransmitFilter</code> 和 <code>comm.RaisedCosineReceiveFilter</code>。</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>[1] Tranter, William H., K. Sam Shanmugan, Theodore S. Rappaport, and Kurt L. Kosbar. <em>Principles of Communication Systems Simulation with Wireless Applications.</em> Upper Saddle River, NJ: Prentice Hall, 2004.</p>
<h1 id="扩展功能"><a href="#扩展功能" class="headerlink" title="扩展功能"></a>扩展功能</h1><h2 id="C-C-代码生成"><a href="#C-C-代码生成" class="headerlink" title="C/C++ 代码生成"></a>C/C++ 代码生成</h2><blockquote>
<p>使用 MATLAB® Coder™ 生成 C 代码和 C++ 代码。</p>
<blockquote>
<p>用法说明和限制：</p>
<p>所有输入必须为常数。 如果表达式或变量的值不变，则也允许使用。</p>
</blockquote>
</blockquote>
<h1 id="另请参阅"><a href="#另请参阅" class="headerlink" title="另请参阅"></a>另请参阅</h1><p><a href="https://ww2.mathworks.cn/help/signal/ref/gaussdesign.html"><code>gaussdesign</code></a></p>
<h2 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h2><p><a href="https://ww2.mathworks.cn/help/comm/ug/interpolate-and-decimate-using-rrc-filter.html">用 RRC 滤波器进行插值和抽取</a>（Communications Toolbox）</p>
<hr>
<p>在 R2013b 中推出</p>
<hr>
<p>原文参考：<a href="https://ww2.mathworks.cn/help/signal/ref/rcosdesign.html">https://ww2.mathworks.cn/help/signal/ref/rcosdesign.html</a></p>
]]></content>
      <categories>
        <category>MATLAB</category>
        <category>翻译</category>
        <category>帮助文档</category>
      </categories>
      <tags>
        <tag>MATLAB</tag>
        <tag>翻译</tag>
        <tag>成型滤波器</tag>
        <tag>滤波器</tag>
      </tags>
  </entry>
  <entry>
    <title>MATLAB 函数 —— gaussdesign</title>
    <url>/posts/a2967b00.html</url>
    <content><![CDATA[<p><code>gaussdesign</code>：高斯 FIR 脉冲成型滤波器设计</p>
<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><p><code>h = gaussdesign(bt,span,sps)</code></p>
<a id="more"></a>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p><code>h = gaussdesign(bt,span,sps)</code> 设计一个低通 FIR 高斯脉冲成型滤波器，并返回滤波器系数向量 <code>h</code>。滤波器有 <code>span</code> 个符号，每个符号包含 <code>sps</code> 个样本。滤波器的阶次，也即 <code>sps * span</code> 必须是偶数。<a href="#Examples-01">举例</a></p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><h2 id="GSM-GMSK-数字蜂窝通信系统的高斯滤波器"><a href="#GSM-GMSK-数字蜂窝通信系统的高斯滤波器" class="headerlink" title="GSM GMSK 数字蜂窝通信系统的高斯滤波器"></a>GSM GMSK 数字蜂窝通信系统的高斯滤波器<span id="Examples-01"></span></h2><p>指定用于传输比特位的调制是高斯最小频移键控（GMSK）脉冲。此脉冲的 3-dB 带宽等于比特率的 <code>0.3</code> 倍，滤波器的符号数为 <code>4</code>，每个符号 <code>8</code> 个采样点。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">bt <span class="built_in">=</span> <span class="number">0.3</span>;</span><br><span class="line">span <span class="built_in">=</span> <span class="number">4</span>;</span><br><span class="line">sps <span class="built_in">=</span> <span class="number">8</span>;</span><br><span class="line">h <span class="built_in">=</span> gaussdesign(bt,span,sps);</span><br><span class="line">fvtool(h,<span class="string">&#x27;impulse&#x27;</span>)</span><br></pre></td></tr></table></figure>
<div align="center">
  <img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-26-matlab-gaussdesign/2020-11-26-matlab-gaussdesign-010-GaussianFilterForAGSMGMSKDigitalCellularCommunicationSysExample-01.png?imageMogr2/thumbnail/!100p|watermark/2/text/QEpvc2ggR2Fv/fontsize/15/dissolve/60/gravity/southeast/dx/5/dy/5"/>
</div>

<h1 id="输入参数"><a href="#输入参数" class="headerlink" title="输入参数"></a>输入参数</h1><h2 id="bt-3-dB带宽符号时间积"><a href="#bt-3-dB带宽符号时间积" class="headerlink" title="bt - 3-dB带宽符号时间积"></a><code>bt</code> - 3-dB带宽符号时间积</h2><p>3-dB 单边带带宽（以 Hz 为单位）和符号时间（以秒为单位）的乘积，指定为<strong>正实标量</strong>。较小的 <code>bt</code> 值会产生较大的脉冲宽度。</p>
<p><strong>数据类型</strong>：<code>double</code> | <code>single</code></p>
<h2 id="span-符号数"><a href="#span-符号数" class="headerlink" title="span - 符号数"></a><code>span</code> - 符号数</h2><p>符号数，指定为<strong>正整数标量</strong>（默认为 3）。</p>
<p><strong>数据类型</strong>：<code>double</code> | <code>single</code></p>
<h2 id="sps-每个符号的样本数"><a href="#sps-每个符号的样本数" class="headerlink" title="sps - 每个符号的样本数"></a><code>sps</code> - 每个符号的样本数</h2><p>每个符号周期的样本数（上采样因子），指定为<strong>正整数标量</strong>（默认为 2）。</p>
<p><strong>数据类型</strong>：<code>double</code> | <code>single</code></p>
<h1 id="输出参数"><a href="#输出参数" class="headerlink" title="输出参数"></a>输出参数</h1><h2 id="h-FIR-滤波器系数"><a href="#h-FIR-滤波器系数" class="headerlink" title="h - FIR 滤波器系数"></a><code>h</code> - FIR 滤波器系数</h2><p>高斯脉冲成型滤波器的 FIR 系数，以<strong>行向量</strong>的形式返回。系数已被归一化，因此标称通带增益始终为 1。</p>
<p><strong>数据类型</strong>：<code>double</code> | <code>single</code></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>[1] Krishnapura, N., S. Pavan, C. Mathiazhagan, and B. Ramamurthi. “A baseband pulse shaping filter for Gaussian minimum shift keying.” <em>Proceedings of the 1998 IEEE International Symposium on Circuits and Systems</em>. Vol. 1, 1998, pp. 249–252.</p>
<p>[2] Rappaport, Theodore S. <em>Wireless Communications: Principles and Practice.</em> 2nd Ed. Upper Saddle River, NJ: Prentice Hall, 2002.</p>
<h1 id="另请参阅"><a href="#另请参阅" class="headerlink" title="另请参阅"></a>另请参阅</h1><p><a href="https://ww2.mathworks.cn/help/signal/ref/rcosdesign.html"><code>rcosdesign</code></a></p>
<hr>
<p>在 R2013b 中推出</p>
<hr>
<p>原文参考：<a href="https://ww2.mathworks.cn/help/signal/ref/gaussdesign.html">https://ww2.mathworks.cn/help/signal/ref/gaussdesign.html</a></p>
]]></content>
      <categories>
        <category>MATLAB</category>
        <category>翻译</category>
        <category>帮助文档</category>
      </categories>
      <tags>
        <tag>MATLAB</tag>
        <tag>翻译</tag>
        <tag>成型滤波器</tag>
        <tag>滤波器</tag>
      </tags>
  </entry>
  <entry>
    <title>MATLAB 函数 —— upsample（Signal Processing Toolbox）</title>
    <url>/posts/3a606c9c.html</url>
    <content><![CDATA[<p><code>upsample</code>：将采样率提高整数倍</p>
<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><p><code>y = upsample(x,n)</code><br><code>y = upsample(x,n,phase)</code></p>
<a id="more"></a>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p><code>y = upsample(x,n)</code> 通过在样本之间插入 <code>n - 1</code>个零来增加 <code>x</code> 的采样率。如果 <code>x</code> 是矩阵，则该函数将每一列视为单独的序列。<a href="#Examples-01">举例</a></p>
<p><code>y = upsample(x,n,phase)</code> 指定未采样序列所偏移的样本数。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><h2 id="提高采样率"><a href="#提高采样率" class="headerlink" title="提高采样率"></a>提高采样率<span id="Examples-01"></span></h2><p>将序列的采样率提高 <code>3</code> 倍。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">x <span class="built_in">=</span> [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>];</span><br><span class="line">y <span class="built_in">=</span> upsample(x,<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">y &#x3D; 1×12</span><br><span class="line"></span><br><span class="line">    1     0     0     2     0     0     3     0     0     4     0     0</span><br></pre></td></tr></table></figure>
<p>将序列的采样率增加 <code>3</code> 倍，并将相位偏移增加 <code>2</code>。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">x <span class="built_in">=</span> [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>];</span><br><span class="line">y <span class="built_in">=</span> upsample(x,<span class="number">3</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">y &#x3D; 1×12</span><br><span class="line"></span><br><span class="line">    0     0     1     0     0     2     0     0     3     0     0     4     0</span><br></pre></td></tr></table></figure>
<p>将矩阵的采样率提高3倍。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">x <span class="built_in">=</span> [<span class="number">1</span> <span class="number">2</span>;</span><br><span class="line">     <span class="number">3</span> <span class="number">4</span>;</span><br><span class="line">     <span class="number">5</span> <span class="number">6</span>];</span><br><span class="line">y <span class="built_in">=</span> upsample(x,<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">y &#x3D; 9×2</span><br><span class="line"></span><br><span class="line">    1     2</span><br><span class="line">    0     0</span><br><span class="line">    0     0</span><br><span class="line">    3     4</span><br><span class="line">    0     0</span><br><span class="line">    0     0</span><br><span class="line">    5     6</span><br><span class="line">    0     0</span><br><span class="line">    0     0</span><br></pre></td></tr></table></figure>
<h1 id="输入参数"><a href="#输入参数" class="headerlink" title="输入参数"></a>输入参数</h1><h2 id="x-输入数组"><a href="#x-输入数组" class="headerlink" title="x - 输入数组"></a><code>x</code> - 输入数组</h2><p>输入数组，指定为<strong>向量</strong>或<strong>矩阵</strong>。如果 <code>x</code> 是矩阵，该函数会将不同列向量视为独立的通道。</p>
<p><strong>举例</strong>：<code>cos(pi/4*(0:159)) + randn(1,160)</code> 指定加有高斯白噪声的正弦曲线。</p>
<p><strong>举例</strong>：<code>cos(pi./[4;2]*(0:159))&#39; + randn(160,2)</code> 指定一个两通道的正弦波。</p>
<h2 id="n-上采样因子"><a href="#n-上采样因子" class="headerlink" title="n - 上采样因子"></a><code>n</code> - 上采样因子</h2><p>上采样因子，指定为<strong>正整数</strong>。</p>
<p><strong>数据类型</strong>：<code>single</code> | <code>double</code></p>
<h2 id="phase-偏移量"><a href="#phase-偏移量" class="headerlink" title="phase - 偏移量"></a><code>phase</code> - 偏移量</h2><p>偏移量，指定为从 <code>0</code> 到 <code>n - 1</code> 的<strong>正整数</strong>。默认为 <code>0</code>。</p>
<p><strong>数据类型</strong>：<code>single</code> | <code>double</code></p>
<h1 id="输出参数"><a href="#输出参数" class="headerlink" title="输出参数"></a>输出参数</h1><h2 id="y-上采样数组"><a href="#y-上采样数组" class="headerlink" title="y - 上采样数组"></a><code>y</code> - 上采样数组</h2><p>上采样数组，以<strong>向量</strong>或<strong>矩阵</strong>的形式返回。<code>y</code> 有 <code>x × n</code> 个样本。</p>
<h1 id="扩展功能"><a href="#扩展功能" class="headerlink" title="扩展功能"></a>扩展功能</h1><h2 id="C-C-代码生成"><a href="#C-C-代码生成" class="headerlink" title="C/C++ 代码生成"></a>C/C++ 代码生成</h2><blockquote>
<p>使用 MATLAB® Coder™ 生成 C 代码和 C++ 代码。</p>
</blockquote>
<h1 id="另请参阅"><a href="#另请参阅" class="headerlink" title="另请参阅"></a>另请参阅</h1><p><a href="https://ww2.mathworks.cn/help/signal/ref/decimate.html"><code>decimate</code></a> | <a href="https://ww2.mathworks.cn/help/signal/ref/downsample.html"><code>downsample</code></a> | <a href="https://ww2.mathworks.cn/help/signal/ref/interp.html"><code>interp</code></a> | <a href="https://ww2.mathworks.cn/help/matlab/ref/interp1.html"><code>interp1</code></a> | <a href="https://ww2.mathworks.cn/help/signal/ref/resample.html"><code>resample</code></a> | <a href="https://ww2.mathworks.cn/help/matlab/ref/spline.html"><code>spline</code></a> | <a href="https://ww2.mathworks.cn/help/signal/ref/upfirdn.html"><code>upfirdn</code></a></p>
<hr>
<p>在 R2006a 之前推出</p>
<hr>
<p>原文参考：<a href="https://ww2.mathworks.cn/help/signal/ref/upsample.html">https://ww2.mathworks.cn/help/signal/ref/upsample.html</a></p>
]]></content>
      <categories>
        <category>MATLAB</category>
        <category>翻译</category>
        <category>帮助文档</category>
      </categories>
      <tags>
        <tag>MATLAB</tag>
        <tag>翻译</tag>
        <tag>上采样</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo NexT 主题不蒜子相关问题汇总</title>
    <url>/posts/e96c9b26.html</url>
    <content><![CDATA[<h1 id="什么是不蒜子"><a href="#什么是不蒜子" class="headerlink" title="什么是不蒜子"></a>什么是不蒜子</h1><p><a href="https://busuanzi.ibruce.info/">不蒜子</a>是 <a href="http://ibruce.info/">Bruce</a> 开发的一款轻量级的网页计数器，可以将网站访问计数直接显示在网页上。</p>
<h1 id="启用不蒜子"><a href="#启用不蒜子" class="headerlink" title="启用不蒜子"></a>启用不蒜子</h1><p>NexT 预置了不蒜子提供的网页计数功能。只需要在配置文件中启用即可。</p>
<figure class="highlight yaml"><figcaption><span>next/_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># Show Views / Visitors of the website / page with busuanzi.</span></span><br><span class="line"><span class="comment"># Get more information on http://ibruce.info/2015/04/04/busuanzi</span></span><br><span class="line"><span class="attr">busuanzi_count:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span>                          <span class="comment"># 启用不蒜子</span></span><br><span class="line">  <span class="attr">total_visitors:</span> <span class="literal">true</span>                  <span class="comment"># 网站总访客数</span></span><br><span class="line">  <span class="attr">total_visitors_icon:</span> <span class="string">fa</span> <span class="string">fa-user</span></span><br><span class="line">  <span class="attr">total_views:</span> <span class="literal">true</span>                     <span class="comment"># 网站总浏览数</span></span><br><span class="line">  <span class="attr">total_views_icon:</span> <span class="string">fa</span> <span class="string">fa-eye</span></span><br><span class="line">  <span class="attr">post_views:</span> <span class="literal">true</span>                      <span class="comment"># 文章浏览数</span></span><br><span class="line">  <span class="attr">post_views_icon:</span> <span class="string">fa</span> <span class="string">fa-eye</span></span><br></pre></td></tr></table></figure>
<h1 id="不蒜子和-Live2D-冲突的问题"><a href="#不蒜子和-Live2D-冲突的问题" class="headerlink" title="不蒜子和 Live2D 冲突的问题"></a>不蒜子和 Live2D 冲突的问题</h1><a id="more"></a>
<blockquote>
<p>Hexo 版本：5.2.0<br>NexT 版本：8.0.2<br>不蒜子版本: 2.3</p>
</blockquote>
<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>添加 Live2D 前的不蒜子显示情况如下。</p>
<div align="center">
  <img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-27-hexo-next-busuanzi-issues/2020-11-27-hexo-next-busuanzi-issues-010-Live2D-01.png?imageMogr2/thumbnail/!100p|watermark/2/text/QEpvc2ggR2Fv/fontsize/15/dissolve/60/gravity/southeast/dx/5/dy/5"/>
</div>

<div align="center">
  <img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-27-hexo-next-busuanzi-issues/2020-11-27-hexo-next-busuanzi-issues-020-Live2D-02.png?imageMogr2/thumbnail/!100p|watermark/2/text/QEpvc2ggR2Fv/fontsize/15/dissolve/60/gravity/southeast/dx/5/dy/5"/>
</div>

<p>添加 Live2D 后，不蒜子在页面中不显示。</p>
<div align="center">
  <img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-27-hexo-next-busuanzi-issues/2020-11-27-hexo-next-busuanzi-issues-030-Live2D-03.png?imageMogr2/thumbnail/!100p|watermark/2/text/QEpvc2ggR2Fv/fontsize/15/dissolve/60/gravity/southeast/dx/5/dy/5"/>
</div>

<div align="center">
  <img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-27-hexo-next-busuanzi-issues/2020-11-27-hexo-next-busuanzi-issues-040-Live2D-04.png?imageMogr2/thumbnail/!100p|watermark/2/text/QEpvc2ggR2Fv/fontsize/15/dissolve/60/gravity/southeast/dx/5/dy/5"/>
</div>

<h2 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h2><p>经查，添加 Live2D 后网页的不蒜子部分源码的 <code>style</code> 从 <code>&quot;display: inline;&quot;</code> 替换为了 <code>&quot;display: none;&quot;</code>。</p>
<figure class="highlight html"><figcaption><span>不蒜子不正常显示的网页源码</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item&quot;</span> <span class="attr">title</span>=<span class="string">&quot;阅读次数&quot;</span> <span class="attr">id</span>=<span class="string">&quot;busuanzi_container_page_pv&quot;</span> <span class="attr">style</span>=<span class="string">&quot;display: none;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item-icon&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fa fa-eye&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item-text&quot;</span>&gt;</span> 阅读次数：<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;busuanzi_value_page_pv&quot;</span>&gt;</span>19<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight html"><figcaption><span>不蒜子正常显示的网页源码</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item&quot;</span> <span class="attr">title</span>=<span class="string">&quot;阅读次数&quot;</span> <span class="attr">id</span>=<span class="string">&quot;busuanzi_container_page_pv&quot;</span> <span class="attr">style</span>=<span class="string">&quot;display: inline;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item-icon&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fa fa-eye&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item-text&quot;</span>&gt;</span> 阅读次数：<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;busuanzi_value_page_pv&quot;</span>&gt;</span>18<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>在网页生成引擎中修改代码，去掉不蒜子部分的 <code>id</code> 和 <code>style</code> 属性，重新生成网页即可解决该问题。若将 <code>class</code> 属性一并删除，会导不蒜子部分和前面的其他显示部分缺少分隔符，如下图。</p>
<div align="center">
  <img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-27-hexo-next-busuanzi-issues/2020-11-27-hexo-next-busuanzi-issues-050-Delimeter-01.png?imageMogr2/thumbnail/!100p|watermark/2/text/QEpvc2ggR2Fv/fontsize/15/dissolve/60/gravity/southeast/dx/5/dy/5"/>
</div>

<p>具体需要修改两个文件，<code>next/layout/_third-party/statistics/busuanzi-counter.swig</code> 中修改的是网页页脚部分的不蒜子显示，<code>next/layout/_macro/post.swig</code> 中修改的博客文章阅览数的不蒜子显示。</p>
<figure class="highlight html"><figcaption><span>next/layout/_third-party/statistics/busuanzi-counter.swig</span></figcaption><table><tr><td class="code"><pre><span class="line">&#123;%- if theme.busuanzi_count.total_visitors %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item&quot;</span> <span class="attr">id</span>=<span class="string">&quot;busuanzi_container_site_uv&quot;</span> <span class="attr">style</span>=<span class="string">&quot;display: none;&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">&#123;%- endif %&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line"></span><br><span class="line">&#123;%- if theme.busuanzi_count.total_views %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item&quot;</span> <span class="attr">id</span>=<span class="string">&quot;busuanzi_container_site_pv&quot;</span> <span class="attr">style</span>=<span class="string">&quot;display: none;&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">&#123;%- endif %&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><figcaption><span>next/layout/_macro/post.swig</span></figcaption><table><tr><td class="code"><pre><span class="line">&#123;%- if not is_index and theme.busuanzi_count.enable and theme.busuanzi_count.post_views %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item&quot;</span> <span class="attr">title</span>=<span class="string">&quot;&#123;&#123; __(&#x27;post.views&#x27;) &#125;&#125;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;busuanzi_container_page_pv&quot;</span> <span class="attr">style</span>=<span class="string">&quot;display: none;&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">&#123;%- endif %&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Blog</category>
        <category>Hexo</category>
        <category>Next</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title>Josh 的学习笔记之 Verilog（Part 1 —— 初识 HDL 设计方法）</title>
    <url>/posts/460433dd.html</url>
    <content><![CDATA[<p>本文阐述了 HDL 语言/设计方法的基本概念。主要介绍了数字系统建模方法的演变，引入了 HDL 语言的基本概念，对 Verilog HDL 和 VHDL、Verilog HDL 和 C 的联系与区别进行了说明，在最后引入了 HDL 的设计和验证流程，并对各个流程进行了简单介绍。</p>
<h1 id="设计方法的变迁"><a href="#设计方法的变迁" class="headerlink" title="设计方法的变迁"></a>设计方法的变迁<a name="01"></a></h1><p>随着微电子设计技术与工艺的发展，数字集成电路从电子管、晶体管、中小规模集成电路、超大规模集成电路（Very Large Scale Integrated Circuit, VLSIC）逐步发展到今天的专用集成电路（Application Specific Integrated Circuit, ASIC），愈发数字化的产品如计算机、手机、数字电视等都运用了复杂的专用数字集成电路。数字逻辑器件从简单的逻辑门到复杂的 SoC，种类繁多，提供了对复杂系统的灵活的支撑。</p>
<a id="more"></a>
<p>随着数字电路系统的不断发展，系统的逻辑复杂度与规模日益增加，数字系统的设计方法也随之不断演进。早期简单的门逻辑设计阶段，EDA 工具应用范围十分有限，工程师们习惯于使用<strong>卡诺图</strong>简化设计，然后通过面包板等实验系统验证设计；系统相对复杂后，工程师们借助 EDA 工具通过原理图描述数字系统。原理图由元件库中的元件构成，使用 EDA（Electronic Design Automation，电子设计自动化）工具可以对原理图进行仿真并分析其性能；当数字系统发展到 ASIC 与 PLD（Programmable Logic Device，可编程逻辑器件） 设计阶段后，原理图不利于移植、维护费时费力等缺点逐步显现，这时需要抽象度更高、更灵活的设计方式 —— HDL（Hardware Description Language，硬件描述语言）。</p>
<p>使用 HDL 语言，可以从算法、系统级（System Level）、功能模块级（Functional Model Level）、行为级（Behavioral Level）、寄存器传输级（RTL, Register Transfer Level）、门级（Gate Level）到开关级（Switch Level）等不同层次描述数字电路系统，然后通过 EDA 工具综合、仿真并实现该系统。可以说 HDL 语言的出现是数字系统设计方法的一个重大飞跃。</p>
<p>数字电路系统设计方法的另一个重大飞跃是随着 EDA 工具的不断推陈出新发生的。早期 ASIC 和 PLD 设计时，人们需要直接描述 CMOS 的开关电路或门级电路，其设计量庞大，仿真速度也非常慢，像当今系统门数量为千万门级的 FPGA 用开关级或门级方法描述在当时是不可想象的。这时人们就希望能够使用 HDL 直接从更高的层次描述电路，然后使用 EDA 工具自动将高层次的 HDL 电路描述解析到门级，这些将大大节约设计与仿真时间，这个<strong>从高层次的电路描述通过 EDA 工具解析到门级等低层次的电路描述的过程就叫“综合”（Synthesize），或者逻辑综合</strong>。综合工具能将高层次的 HDL 语言、原理图等设计描述翻译成由与、或、非门等基本逻辑单元组成的门级连接（<strong>网表</strong>）并根据设计目标与要求（约束条件）优化所生成的逻辑连接，输出门级网表文件。目前最成熟的综合工具是 RTL 级综合工具，它能将 RTL 级描述翻译并优化为门级网表。综合工具的产生支撑了直接从 RTL 级描述硬件电路，这种从门级描述抽象到 RTL 级描述数字电路是设计方法的又一次伟大飞跃。</p>
<p>从上面描述可以看到 HDL 语言是分层次的，关于上述 HDL 语言设计层次的含义在 <a href="#03">3. HDL 的设计与验证流程</a>小节和 <a href="https://josh-gao.blog.csdn.net/article/details/105262549#5__1023">《Part 3——描述方式和设计层次》的 5. 设计层次</a>小节有详细论述。)</p>
<h1 id="Verilog-语言的特点"><a href="#Verilog-语言的特点" class="headerlink" title="Verilog 语言的特点"></a>Verilog 语言的特点<a name="02"></a></h1><h2 id="Verilog-的由来"><a href="#Verilog-的由来" class="headerlink" title="Verilog 的由来"></a>Verilog 的由来</h2><p>Verilog 是 Verilog HDL 的简称。Verilog 语言最初于1983年由 Gateway Design Automation 公司开发，于1995年接受为 IEEE 标准。Verilog 语言不仅定义了语法，而且对每个语法结构都清晰定义了仿真语义，从而便于仿真调试。而且 Verilog 从 C 语言继承了很多操作符和语法结构，对初学者而言易学易用。另外 Verilog 语言具有很强的扩展能力，最新的 Verilog 2001 标准<sup><a href="#fn_1" id="reffn_1">1</a></sup>大大扩展了 Verilog 的应用灵活性。</p>
<p>另外一个流行的 HDL 语言是 VHDL，其发展初期受到美国国防部支持，并于 1987 年成为 IEEE 标准。VHDL 语言的特点是描述严谨。</p>
<h2 id="Verilog-和-VHDL"><a href="#Verilog-和-VHDL" class="headerlink" title="Verilog 和 VHDL"></a>Verilog 和 VHDL</h2><p>Verilog 和 VHDL 作为最为流行的 HDL 语言，从设计能力上而言都能胜任数字电路系统的设计任务。</p>
<p>VHDL 最初用作文档来描述数字硬件的行为，因此其<strong>描述性和抽象层次更高</strong>。也就是说，VHDL 更适合描述更高层次（如行为级、系统级等）的硬件电路。</p>
<p>Verilog 最初是为了更简洁有效地描述数字硬件电路和仿真而设计的，它的许多关键字与语法集成了 C 语言的体系，因此易学易懂，接受度很广。</p>
<p>前面已经提到最流行的 HDL 语言是 Verilog 和 VHDL。在其基础上发展出了许多抽象程度更高的硬件描述语言，如 SystemVerilog、Superlog、SystemC、CoWare C，这些高级 HDL 语言的语法结枃更加丰富，更适合做系统级、功能级等高层次的设计描述和仿真。</p>
<h2 id="Verilog-和-C"><a href="#Verilog-和-C" class="headerlink" title="Verilog 和 C"></a>Verilog 和 C</h2><p>Verilog 语言是根据 C 语言发明而来的，因此 Verilog 具备了 C 语言的简洁易用的特点。Verilog 从 C 语言中借鉴了许多语法，例如预编译指令和一些高级编程语言结构。</p>
<ol>
<li><p>C 语言与 Verilog 的最大区别</p>
<p> C 语言与 Verilog 的最大区别在于 C 缺乏硬件描述的 3 个基本概念：</p>
<ul>
<li><p><strong>互连（connectivity）</strong>：硬件系统中，互连是非常重要的组成部分，而在 C 语言中并没有直接可以用来表示模块间互连的变量；而 Verilog 的 <code>wire</code> 型变量配合一些驱动结构能有效地描述网线的互连。</p>
</li>
<li><p><strong>并发（concurrency）</strong>：C 语言天生是<strong>串行</strong>的，不能描述硬件之间并发的特性，C 语言编译后，其机器指令在 CPU 的高速缓冲队列中基本是顺序执行；而 Verilog 可以有效地描述并行的硬件系统，硬件系统比软件系统速度快、实时性高的一个重要原因就是硬件系统中<strong>各个单元的运算是独立的，信号流是并行的</strong>。</p>
</li>
<li><p><strong>时间（time）</strong>：C 程序运行的时候，没有一个严格的时间概念，程序运行的时间长短取决于处理器本身的性能；而 Verilog 语言本身定义了绝对和相对的时间度量，在仿真时可以通过时间度量与周期关系描述信号直接的时间关系。</p>
</li>
</ul>
</li>
<li><p>HDL 语言的本质</p>
<p> 硬件描述语言（HDL）同软件语言（如 C、C++ 等）是有本质区别的。Verilog 作为硬件描述语言，<strong>它的本质作用在于描述硬件</strong>。Verilog 虽然采用了 C 语言形式，但是它的最终描述结果是芯片内部的实际电路。所以评判一段 HDL 代码优劣的最终标准是其描述并实现的硬件电路的性能（包括面积和速度两个方面）。评价一个设计的代码水平较高，仅仅是说这个设计由硬件向 HDL 代码这种表现形式转换得更流畅、合理。而一个设计的最终性能更大程度上取决于设计工程师所构想的硬件实现方案的效率以及合理性。</p>
<blockquote>
<p>初学者，特别是由软件转行的初学者，片面追求代码的整洁、简短，这是错误的，是与评价 HDL 的标准背道而驰的。正确的编写代码的方法是，首先要做到对所需实现的硬件电路“胸有成竹”，对该部分硬件的结构与连接十分清晰，然后再用适当的 HDL 语句表达出来即可。</p>
</blockquote>
</li>
<li><p>Verilog 与 C 的结合</p>
<p> Verilog 毕竟是硬件描述语言，在抽象层次上比 C 语言要差一些，语法不如 C 灵活，例如文件输入和输出方面，Verilog 的功能显然不如 C。为了克服 Verilog 高级抽象的缺陷，Verilog 的设计者们发明了 PLI。PLI 可以在仿真器中将 C 语言的程序和 Verilog 的程序互相通信，或者在 Verilog 中调用 C 语言的函数库，这样就大大扩展了 Verilog 语言的灵活性和高层次抽象的能力。开发时，一方面，硬件设计者使用 Verilog 进行硬件建模；另一方面，验证工程师却常常使用 C 来编写测试向量，然后通过 Verilog 的 PLI 将 Verilog 和 C 联系起来。这样，C 语言就很好地弥补了 Verilog 高层次建模的缺陷。</p>
</li>
</ol>
<h1 id="HDL-的设计与验证流程"><a href="#HDL-的设计与验证流程" class="headerlink" title="HDL 的设计与验证流程"></a>HDL 的设计与验证流程<a name="03"></a></h1><p>HDL 的基本功能就是有效地描述并仿真硬件系统。在此部分，抛开具体的 PLD 或 ASIC 设计流程，从 HDL 语言层次入手，分析典型的 HDL 设计与验证流程。基于 HDL 的设计、仿真流程如下图所示。图中，虚线框表示的步骤可以根据项目的复杂度省略，而实线框表示的步骤为必须执行的步骤。</p>
<div align="center">
  <img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-27-josh-verilog-part-1/2020-11-27-josh-verilog-part-1-010-DesignSimulationFlowChartBasedonHDL.png?imageMogr2/thumbnail/!35p|watermark/2/text/QEpvc2ggR2Fv/fontsize/15/dissolve/60/gravity/southeast/dx/5/dy/5"/>
</div>

<p>下面对一些关键设计步骤与概念进行展开。</p>
<h2 id="系统与功能模块定义（系统与功能模块级）"><a href="#系统与功能模块定义（系统与功能模块级）" class="headerlink" title="系统与功能模块定义（系统与功能模块级）"></a>系统与功能模块定义（系统与功能模块级）</h2><p>在大型系统的设计与实现中，首先要进行详细的系统规划和描述，此时 HDL 描述<strong>侧重于整体系统的划分和实现</strong>。对系统级的仿真侧重于对整个系统的功能和性能指标的考量。功能模块级设计时将系统整体功能划分为可实现的具体功能模块，大致确定模块间的接口，如时钟、读写信号、数据流、控制信号等。在有些情况下，还要根据系统要求，描述每个模块或进程的时序约束。另外在此层次，必须权衡整个系统多种的实现方式的优劣，选出系统性能指标优并且可以高效实现的设计方案。功能模块级仿真主要是考察每个功能的功能和基本时序情况。系统与功能模块级设计与仿真常常要借助于 C 语言和抽象程度较高的 HDL 语言描述，如 SystemC、Coware C、SystemVerilog、Superlog 等。</p>
<h2 id="行为级描述测试激励（Behavioral-Level）"><a href="#行为级描述测试激励（Behavioral-Level）" class="headerlink" title="行为级描述测试激励（Behavioral Level）"></a>行为级描述测试激励（Behavioral Level）</h2><p>行为级模块描述的最大特点是<strong>必须明确每个模块间的所有接口和边界</strong>。此时模块内部的功能已经明确，模块间的所有接口，顶层的输入、输出信号等在行为级已经被清晰地描述出来。在 PLD 和 ASIC 设计流程中，常用行为级描述方式编写测试激励。延时描述、监视描述等命令都是在编写测试激励过程中常用的行为级语法。行为级描述常用 HDL 语言如 Verilog 和 VHDL 等。</p>
<h2 id="寄存器传输级（RTL）"><a href="#寄存器传输级（RTL）" class="headerlink" title="寄存器传输级（RTL）"></a>寄存器传输级（RTL）</h2><p>寄存器传输级指不关注寄存器和组合逻辑的细节（如使用了多少逻辑门，逻辑门之间的连接拓扑结构等），<strong>通过描述寄存器到寄存器之间的逻辑功能描述电路</strong>的 HDL 层次。RTL 级是比门级更高的抽象层次，一般使用 RTL 级语言描述硬件电路比门级描述电路简单、高效得多。寄存器传输级描述的最大特点是可以直接用综合工具综合门级网表。RTL 设计直接决定着设计的功能和效率。好的 RTL 设计能在满足逻辑功能的前提下，使设计的速度和面积达到一种平衡的优化。RTL 级描述最常用的 HDL 语言是 Verilog 和 VHDL 语言。</p>
<h2 id="对-RTL-级描述进行功能仿真"><a href="#对-RTL-级描述进行功能仿真" class="headerlink" title="对 RTL 级描述进行功能仿真"></a>对 RTL 级描述进行功能仿真</h2><p>一般来说需要对 RTL 级设计进行功能仿真，仿真的目的为<strong>验证 RTL 级描述是否与设计意图一致</strong>。为了提高效率，一般功能仿真的测试激励使用行为级的 HDL 语言描述。</p>
<h2 id="逻辑综合（使用-RTL-级-EDA-工具）"><a href="#逻辑综合（使用-RTL-级-EDA-工具）" class="headerlink" title="逻辑综合（使用 RTL 级 EDA 工具）"></a>逻辑综合（使用 RTL 级 EDA 工具）</h2><p>RTL 级综合指<strong>将 RTL 级 HDL 语言翻译成由与、或、非门等基本逻辑单元组成的门级连接（网表），并根据设计目标与要求（约束条件）优化所生成的逻辑连接，输出门级网表文件</strong>。随着综合工具的不断智能化，使用 RTL 级语言描述硬件电路越来越方便，特别是在 PLD（主要指 FPGA 和 CPLD）设计领域，最重要的代码设计层次就是 RTL 级。</p>
<h2 id="门级（Gate-Level）"><a href="#门级（Gate-Level）" class="headerlink" title="门级（Gate Level）"></a>门级（Gate Level）</h2><p>由于目前 FPGA 设计大多数依靠专业综合工具完成从 RTL 级代码向门级代码的转换，所有设计者直接用 HDL 语言描述门级模型的情况越来越少，高效的综合工具将设计者从复杂繁琐的门级描述中彻底解脱出来。目前直接使用门级描述的场合一般是 ASIC 和 FPGA 设计中<strong>某些面积或时序要求较高的模块</strong>。门级描述的特点是整个设计用逻辑门实现，通过逻辑门的组合显化描述了设计的引脚、功能、时钟周期等所有信息。</p>
<h2 id="综合后门级仿真"><a href="#综合后门级仿真" class="headerlink" title="综合后门级仿真"></a>综合后门级仿真</h2><p>综合完成后，如果需要检查综合结果是否与原设计一致，就需要做综合后仿真。在仿真时，把综合生成的标准延时文件反标注到综合仿真模型中去，可估计门延时带来的影响。综合后仿真虽然比功能仿真精确一些，但是<strong>只能估计门延时，不能估计线延时</strong>，仿真结果<strong>与布线后的实际情况还有一定的差距</strong>，并不十分准确。这种仿真的主要目的在于<strong>检查综合器的综合结果是否与设计输入一致</strong>。目前主流综合工具日益成熟，对于一般性设计，如果设计者确信自己表述明确，没有综合歧义发生，则可以省略综合后仿真步骤。<strong>一般情况下，综合后仿真与功能仿真的仿真激励相同</strong>。</p>
<h2 id="布局规划与布局布线"><a href="#布局规划与布局布线" class="headerlink" title="布局规划与布局布线"></a>布局规划与布局布线</h2><p>综合的门级结果最终要映射到目标库（如 ASIC 设计）或目标器件（如 PLD 设计）。ASIC 与 PLD 设计的相关流程在此不深究 。</p>
<h2 id="布局布线后时序仿真与验证"><a href="#布局布线后时序仿真与验证" class="headerlink" title="布局布线后时序仿真与验证"></a>布局布线后时序仿真与验证</h2><p>将最终布局规划或布局布线的时延信息反标注到设计网表中，所进行的仿真就叫时序仿真或布局规划与布局布线后仿真，简称后仿真。布局规划与布局布线之后生成的仿真时延文件包含的时延信息最全，不仅包含门延时，还包含实际布线延时，所以时序仿真最准确，能较好地反映芯片的实际工作情况。一般来说，建议进行时序仿真步骤，通过时序仿真能检查设计时序与芯片实际运行情况是否一致，确保设计的可靠性和稳定性。时序仿真的主要目的在于发现时序违规（Timing Violation），即不满足时序约束条件或者器件固有时序规则（建立时间、保持时间等）的情况。</p>
<blockquote id="fn_1">
<sup>1</sup>. 最新的 Verilog HDL标准为 1364-2005。<a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a>
</blockquote>
]]></content>
      <categories>
        <category>Verilog</category>
        <category>Verilog 简介</category>
        <category>Josh 的学习笔记</category>
        <category>Verilog</category>
      </categories>
      <tags>
        <tag>Verilog</tag>
        <tag>HDL</tag>
        <tag>硬件描述语言</tag>
        <tag>行为级</tag>
        <tag>RTL</tag>
        <tag>寄存器传输级</tag>
      </tags>
  </entry>
  <entry>
    <title>MATLAB 函数 —— awgn</title>
    <url>/posts/2f6db45b.html</url>
    <content><![CDATA[<p><code>awgn</code>：在信号中添加高斯白斯噪声</p>
<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><p><code>out = awgn(in,snr)</code><br><code>out = awgn(in,snr,signalpower)</code></p>
<p><code>out = awgn(in,snr,signalpower,randobject)</code><br><code>out = awgn(in,snr,signalpower,seed)</code><br><code>out = awgn(___,powertype)</code></p>
<a id="more"></a>
<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p><code>out = awgn(in,snr)</code> 将高斯白噪声添加到矢量信号 <code>in</code> 中。此条语句假定 <code>in</code> 的功率为 0 dBW。</p>
<p><code>out = awgn(in,snr,signalpower)</code> 接受以 dBW 为单位的输入信号功率值。要使该函数在添加噪声之前测量 <code>in</code> 的功率，请将 <code>signalpower</code> 指定为 <code>measured</code>。<a href="#Examples-01">举例</a></p>
<p><code>out = awgn(in,snr,signalpower,randobject)</code> 接受满足前述两条语法，外加随机数流对象的输入组合以生成满足正态分布的随机噪声样本。有关产生可重复噪声样本的信息，请参见<a href="#tips">提示</a>。<a href="#Examples-03">举例</a></p>
<p><code>out = awgn(in,snr,signalpower,seed)</code> 指定用于初始化正态随机数生成器的种子值，该种子在添加高斯白噪声到输入信号时使用。有关产生可重复噪声样本的信息，请参见<a href="#tips">提示</a>。</p>
<p><code>out = awgn(___,powertype)</code> 除了前面任何语法中的输入自变量之外，还将可信号和噪声功率类型指定为 <code>dB</code> 或 <code>linear</code>。</p>
<p>有关 SNR 与噪声相对功率的其他度量（例如 $E_\mathrm{S}/N_0$ 和 $E_\mathrm{b}/N_0$）之间的关系，请参阅 <a href="https://ww2.mathworks.cn/help/comm/ug/awgn-channel.html#a1071501088">AWGN 信道噪声级别</a>。</p>
<h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><h2 id="将-AWGN-添加到锯齿波"><a href="#将-AWGN-添加到锯齿波" class="headerlink" title="将 AWGN 添加到锯齿波"></a>将 AWGN 添加到锯齿波<span id="Examples-01"></span></h2><p>创建一个锯齿波。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">t <span class="built_in">=</span> (<span class="number">0</span>:<span class="number">0.1</span>:<span class="number">10</span>)<span class="string">&#x27;;</span></span><br><span class="line"><span class="string">x = sawtooth(t);</span></span><br></pre></td></tr></table></figure>
<p>添加高斯白噪声并绘制结果。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">y <span class="built_in">=</span> awgn(x,<span class="number">10</span>,<span class="string">&#x27;measured&#x27;</span>);</span><br><span class="line">plot(t,[x y])</span><br><span class="line">legend(<span class="string">&#x27;Original Signal&#x27;</span>,<span class="string">&#x27;Signal with AWGN&#x27;</span>)</span><br></pre></td></tr></table></figure>
<div align="center">
  <img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-27-matlab-awgn/2020-11-27-matlab-awgn-010-AddAWGNToSawtoothSignalExample-01.png?imageMogr2/thumbnail/!100p|watermark/2/text/QEpvc2ggR2Fv/fontsize/15/dissolve/60/gravity/southeast/dx/5/dy/5"/>
</div>

<h2 id="AWGN-信道中的常规-QAM-调制"><a href="#AWGN-信道中的常规-QAM-调制" class="headerlink" title="AWGN 信道中的常规 QAM 调制"></a>AWGN 信道中的常规 QAM 调制<span id="Examples-02"></span></h2><p>在存在高斯噪声的情况下，使用非矩形 16 元星座发送和接收数据。绘制噪声星座图，并针对两种不同的信噪比估算误符号率（SER）。</p>
<p>根据电话线调制解调器的 V.29 标准创建一个 16-QAM 星座。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">c <span class="built_in">=</span> [-<span class="number">5</span> -<span class="number">5</span>i <span class="number">5</span> <span class="number">5</span>i -<span class="number">3</span> -<span class="number">3</span>-<span class="number">3</span>i -<span class="number">3</span>i <span class="number">3</span>-<span class="number">3</span>i <span class="number">3</span> <span class="number">3</span>+<span class="number">3</span>i <span class="number">3</span>i -<span class="number">3</span>+<span class="number">3</span>i -<span class="number">1</span> -<span class="number">1</span>i <span class="number">1</span> <span class="number">1</span>i];</span><br><span class="line">M <span class="built_in">=</span> length(c);</span><br></pre></td></tr></table></figure>
<p>生成随机符号。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">data <span class="built_in">=</span> randi([<span class="number">0</span> M-<span class="number">1</span>],<span class="number">2000</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>使用 <code>genqammod</code> 函数调制数据。由于星座图不是矩形，因此必须进行常规 QAM 调制。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">modData <span class="built_in">=</span> genqammod(data,c);</span><br></pre></td></tr></table></figure>
<p>使信号通过具有 20 dB 信噪比（SNR）的 AWGN 信道。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">rxSig <span class="built_in">=</span> awgn(modData,<span class="number">20</span>,<span class="string">&#x27;measured&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>显示接收信号的星座图和参考星座图。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">h <span class="built_in">=</span> scatterplot(rxSig);</span><br><span class="line">hold on</span><br><span class="line">scatterplot(c,[],[],<span class="string">&#x27;r*&#x27;</span>,h)</span><br><span class="line">grid</span><br><span class="line">hold off</span><br></pre></td></tr></table></figure>
<div align="center">
  <img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-27-matlab-awgn/2020-11-27-matlab-awgn-020-GeneralQAMModulationInAnAWGNChannelExample-01.png?imageMogr2/thumbnail/!100p|watermark/2/text/QEpvc2ggR2Fv/fontsize/15/dissolve/60/gravity/southeast/dx/5/dy/5"/>
</div>

<p>使用 <code>genqamdemod</code> 函数解调接收到的信号。计算误符号数和误符号率。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">demodData <span class="built_in">=</span> genqamdemod(rxSig,c);</span><br><span class="line">[numErrors,ser] <span class="built_in">=</span> symerr(data,demodData)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">numErrors &#x3D; 1</span><br><span class="line">ser &#x3D; 5.0000e-04</span><br></pre></td></tr></table></figure>
<p>使用具有 10 dB SNR 的 AWGN 信道重复传输和解调过程。计算降低 SNR 后的误符号率。不出所料，当 SNR 降低时，性能会下降。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">rxSig <span class="built_in">=</span> awgn(modData,<span class="number">10</span>,<span class="string">&#x27;measured&#x27;</span>);</span><br><span class="line">demodData <span class="built_in">=</span> genqamdemod(rxSig,c);</span><br><span class="line">[numErrors,ser] <span class="built_in">=</span> symerr(data,demodData)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">numErrors &#x3D; 462</span><br><span class="line">ser &#x3D; 0.2310</span><br></pre></td></tr></table></figure>
<h2 id="用-RandStream-产生可重复的-AWGN"><a href="#用-RandStream-产生可重复的-AWGN" class="headerlink" title="用 RandStream 产生可重复的 AWGN"></a>用 RandStream 产生可重复的 AWGN<span id="Examples-03"></span></h2><p>使用 <a href="https://ww2.mathworks.cn/help/matlab/ref/randstream.html"><code>RandStream</code></a> 和 <a href="https://ww2.mathworks.cn/help/matlab/ref/randstream.reset.html"><code>reset</code></a> 对象函数生成高斯白噪声相加的结果。</p>
<p>将 X 的功率指定为 0 dBW，添加噪声以产生 10 dB 的 SNR，并利用本地随机流。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">S <span class="built_in">=</span> RandStream(<span class="string">&#x27;mt19937ar&#x27;</span>,<span class="string">&#x27;Seed&#x27;</span>,<span class="number">5489</span>);</span><br><span class="line">sigin <span class="built_in">=</span> sqrt(<span class="number">2</span>)*sin(<span class="number">0</span>:pi/<span class="number">8</span>:<span class="number">6</span>*pi);</span><br><span class="line">sigout1 <span class="built_in">=</span> awgn(sigin,<span class="number">10</span>,<span class="number">0</span>,S);</span><br></pre></td></tr></table></figure>
<p>将 AWGN 添加到 <code>sigin</code>。 使用 <a href="https://ww2.mathworks.cn/help/matlab/ref/isequal.html"><code>isequal</code></a> 比较 <code>sigout1</code> 和 <code>sigout2</code>。 当不重置随机流时，输出不相等。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">sigout2 <span class="built_in">=</span> awgn(sigin,<span class="number">10</span>,<span class="number">0</span>,S);</span><br><span class="line">isequal(sigout1,sigout2)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ans &#x3D; logical</span><br><span class="line">   0</span><br></pre></td></tr></table></figure>
<p>重置随机流对象，将对象置为初始状态，然后再将 AWGN 添加到 <code>sigout1</code>。将 AWGN 添加到 <code>sigin</code> 并将 <code>sigout1</code> 与 <code>sigout3</code> 比较。 重置随机流后，输出相等。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">reset(S);</span><br><span class="line">sigout3 <span class="built_in">=</span> awgn(sigin,<span class="number">10</span>,<span class="number">0</span>,S);</span><br><span class="line">isequal(sigout1,sigout3)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ans &#x3D; logical</span><br><span class="line">   1</span><br></pre></td></tr></table></figure>
<h1 id="输入参数"><a href="#输入参数" class="headerlink" title="输入参数"></a>输入参数</h1><h2 id="in-输入信号"><a href="#in-输入信号" class="headerlink" title="in - 输入信号"></a><code>in</code> - 输入信号</h2><p>输入信号，指定为<strong>标量</strong>，<strong>向量</strong>或<strong>数组</strong>。假定输入信号的功率为0 dBW。</p>
<p><strong>数据类型</strong>：<code>double</code><br><strong>复数支持</strong>：是</p>
<h2 id="snr-信噪比（SNR）"><a href="#snr-信噪比（SNR）" class="headerlink" title="snr - 信噪比（SNR）"></a><code>snr</code> - 信噪比（SNR）</h2><p>信噪比（以 dB 为单位），指定为<strong>标量</strong>。</p>
<div class="note info">
            <p>注意：</p><p>加上噪声后，此函数会将相同的 <code>snr</code> 应用于完整输入信号的所有元素。阵列输入信号没有独立通道的概念。 要独立考虑多个频道，请参阅 <a href="https://ww2.mathworks.cn/help/comm/ref/comm.awgnchannel-system-object.html"><code>comm.AWGNChannel</code></a>。</p>
          </div>
<p><strong>数据类型</strong>：<code>double</code></p>
<h2 id="signalpower-信号功率"><a href="#signalpower-信号功率" class="headerlink" title="signalpower - 信号功率"></a><code>signalpower</code> - 信号功率</h2><p>信号功率，指定为<strong>标量</strong>或 <code>measured</code>。</p>
<ul>
<li><p>当 <code>signalpower</code> 为标量时，该值用作 <code>in</code> 的信号电平，以便根据 <code>snr</code> 的值确定适当的噪声电平。</p>
</li>
<li><p>当 <code>signalpower</code> 为 <code>measured</code> 时，将计算 <code>in</code> 的信号电平，以根据 <code>snr</code> 的值确定适当的噪声电平。</p>
</li>
</ul>
<div class="note info">
            <p>注意：</p><p>当指定 <code>measured</code> 时，此函数将使用完整输入信号的所有元素来计算信号功率。在计算功率时，阵列输入信号没有独立通道的概念。</p>
          </div>
<p><strong>数据类型</strong>：<code>double</code></p>
<h2 id="randobject-随机数流对象"><a href="#randobject-随机数流对象" class="headerlink" title="randobject - 随机数流对象"></a><code>randobject</code> - 随机数流对象</h2><p>随机数流对象，指定为 <a href="https://ww2.mathworks.cn/help/matlab/ref/randstream.html"><code>RandStream</code></a> 对象。 随机流对象的状态确定 <a href="https://ww2.mathworks.cn/help/matlab/ref/randn.html"><code>randn</code></a> 函数产生的数字序列。使用 <a href="https://ww2.mathworks.cn/help/matlab/ref/randstream.reset.html"><code>reset (RandStream)</code></a> 函数及其属性来配置随机流对象。</p>
<p><code>wgn</code> 使用 <a href="https://ww2.mathworks.cn/help/matlab/ref/randn.html"><code>randn</code></a> 生成正常的随机噪声样本。<a href="https://ww2.mathworks.cn/help/matlab/ref/randn.html"><code>randn</code></a> 函数使用 <a href="https://ww2.mathworks.cn/help/matlab/ref/randstream.html"><code>RandStream</code></a> 对象中的一个或多个统一值来生成每个正态值。</p>
<p>有关产生可重复噪声样本的信息，请参见<a href="#tips">提示</a>。</p>
<h2 id="seed-随机数生成器种子"><a href="#seed-随机数生成器种子" class="headerlink" title="seed - 随机数生成器种子"></a><code>seed</code> - 随机数生成器种子</h2><p>随机数生成器种子，指定为<strong>标量</strong>。</p>
<h2 id="powertype-信号功率单元"><a href="#powertype-信号功率单元" class="headerlink" title="powertype - 信号功率单元"></a><code>powertype</code> - 信号功率单元</h2><p>信号功率单元，指定为 <code>dB</code> 或 <code>linear</code>。默认为 <code>dB</code>。</p>
<ul>
<li><p>当功率类型为 <code>dB</code> 时，以 dB 为单位测量 snr，以 dBW 为单位测量信号功率。</p>
</li>
<li><p>当功率类型为 <code>linear</code> 时，<code>snr</code> 以比率进行测量，<code>signalpower</code> 以瓦特为单位。</p>
</li>
</ul>
<p>有关 SNR 与噪声相对功率的其他度量（例如 $E_\mathrm{S}/N_0$ 和 $E_\mathrm{b}/N_0$）之间的关系，请参阅 <a href="https://ww2.mathworks.cn/help/comm/ug/awgn-channel.html#a1071501088">AWGN 信道噪声级别</a>。</p>
<h1 id="输出参数"><a href="#输出参数" class="headerlink" title="输出参数"></a>输出参数</h1><h2 id="out-输出信号"><a href="#out-输出信号" class="headerlink" title="out  - 输出信号"></a><code>out</code>  - 输出信号</h2><p>输出信号，以<strong>标量</strong>，<strong>向量</strong>或<strong>数组</strong>形式返回。 返回的输出信号是添加了高斯白噪声的输入信号。</p>
<h1 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示<span id="tips"></span></h1><ul>
<li><p>要生成可重复的高斯白噪声样本，请使用以下技巧之一：</p>
<ul>
<li><p>提供静态 <code>seed</code> 值作为 <code>awgn</code> 的输入。</p>
</li>
<li><p>在将 <code>randobject</code> 传递为 <code>awgn</code> 的输入之前，请对 <code>randobject</code> 使用 <a href="https://ww2.mathworks.cn/help/matlab/ref/randstream.reset.html"><code>reset (RandSteam)</code></a> 函数。</p>
</li>
<li><p>将处于已知状态的 <code>randobject</code> 提供给 <code>awgn</code>。有关更多信息，请参见 <a href="https://ww2.mathworks.cn/help/matlab/ref/randstream.html"><code>RandStream</code></a>。</p>
</li>
</ul>
</li>
</ul>
<h1 id="扩展功能"><a href="#扩展功能" class="headerlink" title="扩展功能"></a>扩展功能</h1><h2 id="C-C-代码生成"><a href="#C-C-代码生成" class="headerlink" title="C/C++ 代码生成"></a>C/C++ 代码生成</h2><blockquote>
<p>使用 MATLAB® Coder™ 生成 C 代码和 C++ 代码。</p>
<blockquote>
<p>用法说明和限制：</p>
<p>支持代码生成，但包括 <a href="https://ww2.mathworks.cn/help/matlab/ref/randstream.html"><code>RandStream</code></a> 对象的语法除外。</p>
</blockquote>
</blockquote>
<h1 id="另请参阅"><a href="#另请参阅" class="headerlink" title="另请参阅"></a>另请参阅</h1><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p><a href="https://ww2.mathworks.cn/help/matlab/ref/randstream.html"><code>RandStream</code></a> | <a href="[RandStream](https://ww2.mathworks.cn/help/matlab/ref/randstream.html"><code>bsc</code></a>) | <a href="https://ww2.mathworks.cn/help/matlab/ref/randn.html"><code>randn</code></a> | <a href="https://ww2.mathworks.cn/help/comm/ref/wgn.html"><code>wgn</code></a></p>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p><a href="https://ww2.mathworks.cn/help/comm/ref/comm.awgnchannel-system-object.html"><code>comm.AWGNChannel</code></a></p>
<h2 id="话题"><a href="#话题" class="headerlink" title="话题"></a>话题</h2><p><a href="https://ww2.mathworks.cn/help/comm/ug/awgn-channel.html#a1071501088">AWGN Channel Noise Level</a></p>
<hr>
<p>在 R2006a 之前推出</p>
<hr>
<p>原文参考：<a href="https://ww2.mathworks.cn/help/comm/ref/awgn.html">https://ww2.mathworks.cn/help/comm/ref/awgn.html</a></p>
]]></content>
      <categories>
        <category>MATLAB</category>
        <category>翻译</category>
        <category>帮助文档</category>
        <category>信号处理</category>
        <category>噪声</category>
      </categories>
      <tags>
        <tag>MATLAB</tag>
        <tag>翻译</tag>
        <tag>高斯白噪声</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo-NexT 折腾就完事儿了</title>
    <url>/posts/b158f1b4.html</url>
    <content><![CDATA[<h1 id="瞎折腾-美化侧边栏"><a href="#瞎折腾-美化侧边栏" class="headerlink" title="瞎折腾/美化侧边栏"></a>瞎折腾/<del>美化</del>侧边栏</h1><p>在博客根目录下的 <code>source/_data</code> 文件夹中新建 <code>sidebar.swig</code> 文件。</p>
<h2 id="添加-Tag-Cloud"><a href="#添加-Tag-Cloud" class="headerlink" title="添加 Tag Cloud"></a>添加 Tag Cloud</h2><p>安装 <code>hexo-tag-cloud</code> 插件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-tag-cloud --save</span><br></pre></td></tr></table></figure>
<p>添加相关代码写入 <code>sidebar.swig</code>。不喜欢标题的把 <code>&lt;h3 class=&quot;widget-title&quot;&gt;Tag Cloud&lt;/h3&gt;</code> 去掉即可。</p>
<figure class="highlight html"><figcaption><span>source/_data/sidebar.swig</span></figcaption><table><tr><td class="code"><pre><span class="line">&#123;% if site.tags.length &gt; 1 %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/js/tagcloud.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/js/tagcanvas.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;widget-wrap&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span> <span class="attr">class</span>=<span class="string">&quot;widget-title&quot;</span>&gt;</span>Tag Cloud<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;myCanvasContainer&quot;</span> <span class="attr">class</span>=<span class="string">&quot;widget tagcloud&quot;</span> <span class="attr">style</span>=<span class="string">&quot;font-size:20px;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">width</span>=<span class="string">&quot;220&quot;</span> <span class="attr">height</span>=<span class="string">&quot;200&quot;</span> <span class="attr">id</span>=<span class="string">&quot;resCanvas&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width=100%&quot;</span>&gt;</span></span><br><span class="line">            &#123;&#123; list_tags() &#125;&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<h1 id="瞎折腾-美化页面"><a href="#瞎折腾-美化页面" class="headerlink" title="瞎折腾/美化页面"></a>瞎折腾/<del>美化</del>页面</h1><p>在博客根目录下的 <code>source/_data</code> 文件夹中新建 <code>variables.styl</code> 文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd hexo</span><br><span class="line">vi source/_data/variables.styl</span><br></pre></td></tr></table></figure>
<h2 id="页面圆角"><a href="#页面圆角" class="headerlink" title="页面圆角"></a>页面圆角</h2><p>在 <code>variables.styl</code> 文件里添加圆角半径值</p>
<figure class="highlight"><figcaption><span>source/_data/variables.styl</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// 圆角设置</span></span><br><span class="line">$border-radius-inner     = 0px;     // 内部圆角半径</span><br><span class="line">$border-radius           = 8px;     // 外部圆角半径</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Blog</category>
        <category>Hexo</category>
        <category>Next</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title>Josh 的学习笔记之 Verilog（Part 2 —— Verilog 语言基础）</title>
    <url>/posts/fd2ca242.html</url>
    <content><![CDATA[<p>本文从一个 Verilog 用例出发，对 Verilog 语言的语法进行了阐释。包括的内容主要有 Verilog 语言的基本词法，常用的编译指令，逻辑值、常量、变量的含义，操作符的概念和分类等，还对 Verilog 中的参数、并发以及系统任务和系统函数进行了简要说明。</p>
<h1 id="两种设计方法（Top-Down-和-Bottom-Up）"><a href="#两种设计方法（Top-Down-和-Bottom-Up）" class="headerlink" title="两种设计方法（Top-Down 和 Bottom-Up）"></a>两种设计方法（Top-Down 和 Bottom-Up）</h1><p>在传统意义上，设计硬件电路主要是使用自底向上（Bottom-Up）的设计方法。工程师们总是从最底层的逻辑门开始，逐渐搭建成较大的模块，然后再将这些模块组成更大的模块，最后形成整个设计。</p>
<p>在  <a href="https://josh-gao.top/posts/460433dd.html">Part 1——初识 HDL 设计方法</a>中已经提到，随着 HDL 和逻辑综合技术的进步，工程师们逐渐可以使用自顶向下（Top-Down）的方法来设计硬件。这样，工程师们<strong>首先关注于设计的规格（Specification），然后将规格分解为一个个模块，再分解为更小的模块</strong>。然后采用 HDL 的可综合子集直接描述硬件的行为，由逻辑综合工具自动完成由 HDL 到门级电路的转换。</p>
<a id="more"></a>
<p>最近几年，随着 IP核 市场的逐渐兴起，许多设计者逐渐意识到<strong>利用现有的 IP核 可以帮助节约设计成本、减少设计周期</strong>，有许多设计工程师，甚至希望所有的设计模块都使用现成的模块，自己仅仅开发一些简单的粘合逻辑。这就有点像电路板设计的过程，工程师将各种芯片集成到一块电路板上，自己完成这些芯片间的互连和一些简单的 CPLD 逻辑设计，以及对微处理器的编程。使用现有的 IP 来搭建系统实际上也是一种自底向上（Bottom-Up）的设计方法。</p>
<p>从以上描述可以看出，设计硬件电路时，这两种设计方法都有可能采用。Verilog HDL 可以完全支持这两种设计方法。</p>
<ul>
<li>在门级的设计中，用户可以直接实例化 Verilog 语言中的门级原语构建系统；</li>
<li>如果需要描述硬件的行为，可以使用 Verilog 的行为级描述功能；</li>
<li>如果要使用 IP核 ，只要在设计中直接实例化 IP核 即可。</li>
</ul>
<p>EDA 行业的先行者们发明了 Verilog 硬件描述语言，其最根本的目的就是用 Verilog 来描述硬件的行为，但是有的描述是不需要实现为硬件电路的。</p>
<p>如果用户的 Verilog 描述的最终目的是要实现为硬件电路，那么要<strong>时刻提醒自己是在设计电路</strong>，这与用 C 语言对处理器编程有很大的区别。</p>
<p>硬件电路最大的特点是由一个个模块组成，模块之间使用互连线，各个模块<strong>独立并行</strong>工作。同时，它们通过输人和输出端口与相邻的模块互相沟通。每个硬件单元都有相应的<strong>延时特性</strong>，硬件的延时也是设计的目标之一。</p>
<h1 id="从-Verilog-实例出发"><a href="#从-Verilog-实例出发" class="headerlink" title="从 Verilog 实例出发"></a>从 Verilog 实例出发</h1><h2 id="Verilog-实例"><a href="#Verilog-实例" class="headerlink" title="Verilog 实例"></a>Verilog 实例</h2><p><a name="JoshVerilog模块"></a>首先看一个简单的如下图所示的电路（模块）：JoshVerilog。它可以是一个独立的设计，也可以是更大的系统的一个组成部分。</p>
<div align="center">
  <img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-28-josh-verilog-part-2/2020-11-28-josh-verilog-part-2-010-JoshVerilog.png?imageMogr2/thumbnail/!60p|watermark/2/text/QEpvc2ggR2Fv/fontsize/15/dissolve/60/gravity/southeast/dx/5/dy/5"/>
</div>

<p>该电路首先在两个 2 位的输人数据 <code>A_in[1:0]</code> 的和 <code>B_in[1:0]</code> 之间，由 <code>sel</code> 信号做二选一。后面是一个 2-4 译码电路，将输人的信号 <code>result[1:0]</code>解析成 <code>eq0</code>、<code>eql</code>、<code>eq2</code> 和 <code>eq3</code> 这4个信号，它们同时只有一个为 1。</p>
<p>将 <code>eq0</code> 和 <code>eql</code> 相异或（xor），<code>eq2</code> 和 <code>eq3</code> 相异或。然后，将两个异或的结果 <code>A_xor_wire</code> 和 <code>XOR_B</code> 分别寄存输出给 <code>A_xor_out</code> 和 <code>B_xor_out</code> 两个输出寄存器带有低有效（active low）的异步复位端。</p>
<p><strong>这些电路单元都是同时并行工作的，相互之间并没有先后顺序关系，这一点与软件设计程序很不一样。</strong></p>
<p>下面具体分析 <a href="#JoshVerilog模块">JoshVerilog 模块</a>的电路功能。源代码如下。</p>
<p><a name="JoshVerilog代码"></a></p>
<figure class="highlight verilog"><figcaption><span>Josh.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编译指令, 定义时间单位和时间精度</span></span><br><span class="line"><span class="meta">`<span class="meta-keyword">timescale</span> 1ns/100p             // 每个时间单位是1ns, 仿真精度是100ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// module名 + 端口列表</span></span><br><span class="line"><span class="keyword">module</span> Josh( clk, rst_n, A_in, B_in, sel, A_xor_out, B_xor_out );</span><br><span class="line"></span><br><span class="line"><span class="comment">// IO端口声明</span></span><br><span class="line"><span class="keyword">input</span>       clk;</span><br><span class="line"><span class="keyword">input</span>       rst_n;</span><br><span class="line"><span class="keyword">input</span> [<span class="number">1</span>:<span class="number">0</span>] A_in;               <span class="comment">// 该信号的输入位宽为2</span></span><br><span class="line"><span class="keyword">input</span> [<span class="number">1</span>:<span class="number">0</span>] B_in;</span><br><span class="line"><span class="keyword">input</span>       sel;</span><br><span class="line"><span class="keyword">output</span>      A_xor_out;</span><br><span class="line"><span class="keyword">output</span>      B_xor_out;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内部线网和寄存器声明</span></span><br><span class="line"><span class="keyword">wire</span>        A_xor_wire;         <span class="comment">// 模块内wire型变量</span></span><br><span class="line"><span class="keyword">wire</span>        B_xor_wire;</span><br><span class="line"><span class="keyword">wire</span>  [<span class="number">1</span>:<span class="number">0</span>] result;</span><br><span class="line"><span class="keyword">reg</span>         eq0, eq1, eq2, eq3; <span class="comment">// 模块内reg型变量</span></span><br><span class="line"><span class="keyword">reg</span>         A_xor_out;</span><br><span class="line"><span class="keyword">reg</span>         B_xor_out;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 行为描述, DFF_A</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">    <span class="keyword">if</span> (~rst_n)</span><br><span class="line">        A_xor_out &lt;= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        A_xor_out &lt;= A_xor_wire;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 行为描述, DFF_B</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">    <span class="keyword">if</span> (~rst_n)</span><br><span class="line">        B_xor_out &lt;= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        B_xor_out &lt;= B_xor_wire;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据流描述, A_xor_wire</span></span><br><span class="line"><span class="keyword">assign</span> #<span class="number">1</span> A_xor_wire = eq0 ^ eq1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构化描述, XOR_B, 直接使用 Verilog 自带的 xor 门原句</span></span><br><span class="line"><span class="keyword">xor</span> #<span class="number">1</span> XOR_B(B_xor_wire, eq2, eq3);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据流描述, MUX21</span></span><br><span class="line"><span class="keyword">assign</span> #<span class="number">3</span> result = sel ? B_in : A_in;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 行为描述, DECODER, 一个2-4译码器</span></span><br><span class="line"><span class="keyword">always</span> @(result) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">case</span>(result)</span><br><span class="line">        <span class="number">2&#x27;b00</span>: <span class="keyword">begin</span></span><br><span class="line">            &#123;eq3, eq2, eq1, eq0&#125; = #<span class="number">2</span> <span class="number">4&#x27;b0001</span>;</span><br><span class="line">            <span class="built_in">$display</span> (<span class="string">&quot;At time %t-&quot;</span>, <span class="built_in">$time</span>, <span class="string">&quot;eq0 = 1&quot;</span>);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="number">2&#x27;b01</span>: <span class="keyword">begin</span></span><br><span class="line">            &#123;eq3, eq2, eq1, eq0&#125; = #<span class="number">2</span> <span class="number">4&#x27;b0010</span>;</span><br><span class="line">            <span class="built_in">$display</span> (<span class="string">&quot;At time %t-&quot;</span>, <span class="built_in">$time</span>, <span class="string">&quot;eq1 = 1&quot;</span>);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="number">2&#x27;b10</span>: <span class="keyword">begin</span></span><br><span class="line">            &#123;eq3, eq2, eq1, eq0&#125; = #<span class="number">2</span> <span class="number">4&#x27;b0100</span>;</span><br><span class="line">            <span class="built_in">$display</span> (<span class="string">&quot;At time %t-&quot;</span>, <span class="built_in">$time</span>, <span class="string">&quot;eq2 = 1&quot;</span>);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="number">2&#x27;b11</span>: <span class="keyword">begin</span></span><br><span class="line">            &#123;eq3, eq2, eq1, eq0&#125; = #<span class="number">2</span> <span class="number">4&#x27;b1000</span>;</span><br><span class="line">            <span class="built_in">$display</span> (<span class="string">&quot;At time %t-&quot;</span>, <span class="built_in">$time</span>, <span class="string">&quot;eq3 = 1&quot;</span>);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">default</span>: ;</span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">// module结束</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>代码分析如下。</p>
<ol>
<li><p>二选一多路选择器</p>
<p> 对于 <code>MUX21</code> 这样二选一的电路，将采用如下的数据流描述（assign语句）：</p>
 <figure class="highlight verilog"><figcaption><span>Josh.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> #<span class="number">3</span> result = sel ? B_in : A_in;</span><br></pre></td></tr></table></figure>
<p> <code>assign</code> 是 Verilog 中的关键词，用它赋值的语言称为<strong>连续赋值语句</strong>。</p>
<p> 如果 <code>sel</code>为真（1），则选择 <code>B_in</code>，否则将选择 <code>A_in</code>，而 <code>#3</code> 表示经过 3 个延时单位，再将选择结果赋值给 <code>result</code>，这也模拟了组合逻辑的延时。由于在<a href="#JoshVerilog代码">代码</a>最开头已经使用 Verilog 的编译指令将延时单位定义为 1ns（<code>timescale 1ns/100ps</code>），因此这里的 <code>#3</code> 代表 3ns 的延时。</p>
</li>
<li><p>2 - 4 译码器</p>
<p> 关于实现 2 - 4 译码器，则采用了如下的描述：</p>
 <figure class="highlight verilog"><figcaption><span>Josh.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @(result) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">case</span>(result)</span><br><span class="line">        <span class="number">2&#x27;b00</span>: <span class="keyword">begin</span></span><br><span class="line">            &#123;eq3, eq2, eq1, eq0&#125; = #<span class="number">2</span> <span class="number">4&#x27;b0001</span>;</span><br><span class="line">            <span class="built_in">$display</span> (<span class="string">&quot;At time %t-&quot;</span>, <span class="built_in">$time</span>, <span class="string">&quot;eq0 = 1&quot;</span>);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">default</span>: ;</span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p> 这里采用了另一种描述方式：用 <code>always</code> 语句来描述电路的行为。通过 <code>case</code> 判断 <code>result</code> 的值来决定 <code>eq0</code>、<code>eq3</code> 的值。同样，也采用 <code>#2</code> 来模拟组合逻辑的延时。<code>always</code> 和 <code>case</code> 也是 Verilog 中的关键词。这样的描述方法称之为<strong>行为描述</strong>，它侧重于描述电路的行为。</p>
 <figure class="highlight verilog"><figcaption><span>Josh.v</span></figcaption><table><tr><td class="code"><pre><span class="line">&#123;eq3, eq2, eq1, eq0&#125; = #<span class="number">2</span> <span class="number">4&#x27;b0001</span>;</span><br></pre></td></tr></table></figure>
<p> 该语句表示将 <code>4&#39;b0001</code> 赋值给 <code>eq3~eq0</code> 合并成的 4 位变量。<code>&#123;&#125;</code> 是 Verilog 的合并符号。</p>
</li>
<li><p>异或门</p>
<p> 对于 <code>A_xor_wire</code> 和 <code>XOR_B</code> 的两个完全一样的异或门，也采用了两种不同的描述方式：</p>
 <figure class="highlight verilog"><figcaption><span>Josh.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> #<span class="number">1</span> A_xor_wire = eq0 ^ eq1;</span><br></pre></td></tr></table></figure>
<p> 和</p>
 <figure class="highlight verilog"><figcaption><span>Josh.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">xor</span> #<span class="number">1</span> XOR_B(B_xor_wire, eq2, eq3);</span><br></pre></td></tr></table></figure>
<p> <code>xor</code> 是 Verilog 中自带的基本逻辑门原语。这里相当于调用了该 <code>xor</code> 门。而 <code>B_xor_wire</code>、<code>eq2</code> 和 <code>eq3</code> 是代人到 <code>xor</code> 门中的参数。<code>eq2</code> 和 <code>eq3</code> 是输人，<code>B_xor_wire</code> 是输出。这里 <code>B_xor_wire</code> 是 <code>eq2</code> 和 <code>eq3</code> 相异或的结果。</p>
<p> 在 Verilog 中，<strong>将调用其他功能模块（包括 Verilog 的内嵌基本逻辑门）称为“实例化（lnstantiate）”</strong>。实例化<strong>类似</strong>于软件设计中的调用，但不能简单理解为软件中的调用。软件调用过程是顺序执行的，而实例化的硬件电路在设计中是独立于其他功能块，并行运行的。</p>
<p> 这种<strong>在模块中实例化其他功能模块</strong>的描述方式被称之为<strong>结构化描述</strong>。</p>
</li>
</ol>
<h2 id="3-种描述方法"><a href="#3-种描述方法" class="headerlink" title="3 种描述方法"></a>3 种描述方法</h2><p>从以上的描述可以看出 Verilog 语言的 3 种基本的描述方法（基本上所有的 Verilog 功能模块都是由这 3 种方式来描述）：</p>
<ul>
<li><strong>数据流描述</strong>：采用 <code>assign</code> 语句，该语句被称为连续赋值语句；</li>
<li><strong>行为描述</strong>：使用 <code>always</code> 或 <code>initial</code> 语句块，其中出现的语句被称为过程赋值语句；</li>
<li><p><strong>结构化描述</strong>：实例化已有的功能模块。结构化描述主要有以下3种：</p>
<ul>
<li>Module实例化：实例化已有的 module；</li>
<li>门实例化：实例化基本的门电路原语；</li>
<li>用户定义原语（UDP）实例化：实例化用户定义的原语。</li>
</ul>
</li>
</ul>
<p>在<a href="https://josh-gao.blog.csdn.net/article/details/105262549">《Part 3——描述方式和设计层次》</a>中会将详细介绍 Verilog 语言中的这 3 种描述方式。</p>
<h1 id="Verilog-的基本词法"><a href="#Verilog-的基本词法" class="headerlink" title="Verilog 的基本词法"></a>Verilog 的基本词法</h1><p>Verilog HDL 是一种<strong>大小写敏感</strong>的语言，这一点与 VHDL 不同，因此在书写的时候要格外注意。在 Verilog 语言中，<strong>所有的关键字（又叫保留字）都为小写</strong>。Verilog 的内部信号名（或称为标识符）使用大写和小写都可以。标识符可以是字母、数字、<code>$</code>（美元符号）和 <code>_</code>（下划线）任意组合，只要<strong>第一个字符是字母或者下划线</strong>即可。</p>
<blockquote>
<p>因为 Verilog HDL 对大小写敏感，因此养成良好的信号定义习惯非常重要，否则容易因为大小写不同造成信号的歧义。推荐的信号定义习惯为：<strong>所有信号和网线名均小写，用下划线分割单词，而宏变量全部用大写字母。</strong></p>
</blockquote>
<p>在上述<a href="#JoshVerilog代码">代码</a>中，用双反斜线 <code>//</code> 表示注释。另外，还有一种注释方式，用 <code>/* ...... */</code> 来表示。所不同的是前者为单行注释，而后者将 <code>/*</code> 和 <code>*/</code> 之间的内容全部看作注释内容。</p>
<blockquote>
<p>通常，注释的内容只是作者为了增强代码的可读性而增加的内容，对整个代码的功能没有任何影响。不过，在一些工具中，尤其是逻辑综合工具，定义了一些特殊的指令，用于控制工具编译过程。这些指令也是以注释的方式出现的。例如：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">moduleblbox(out, data, clk) <span class="comment">/* synthesis syn_black_box */</span>;</span><br></pre></td></tr></table></figure>
<p>在 <code>modulebl_box</code> 的声明处有一行注释，用 <code>/* ...... */</code> 表示。它看起来是一个注释，实际上，是综合工具Synplify中的一个指令，指示 Synplify 将该模块看作一个黑盒（black_box），不处理模块内部的描述。</p>
</blockquote>
<p>在 Verilog 中，通常使用空格符、跳格符和换行符作为间隔。在书写代码的时候，适当运用间隔符可以提高代码的可读性。比如在声明 4 个 <code>reg</code> 型数据 <code>eq0~eq3</code> 时，可以采用上述<a href="#JoshVerilog代码">例子</a>中的方法：</p>
<figure class="highlight verilog"><figcaption><span>Josh.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">reg</span> eq0, eq1, eq2, eq3;</span><br></pre></td></tr></table></figure>
<p>也可以用换行符将其分开：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">reg</span> eq0;</span><br><span class="line"><span class="keyword">reg</span> eq1;</span><br><span class="line"><span class="keyword">reg</span> eq2;</span><br><span class="line"><span class="keyword">reg</span> eq3;</span><br></pre></td></tr></table></figure>
<p>在verilog中，还有一些转义字符。比如 <code>\n</code> 表示换行符；<code>\t</code> 表示 Tab 键；防止引起歧义，就用 <code>\</code> 表示 <code>\</code> 符号本身等等。这里不再对 Verilog 的词法做过多的描述，更多可以参考 Verilog IEEE 国际标准（<a href="https://standards.ieee.org/standard/1364-2005.html">IEEE Std. 1364-2005</a>）。</p>
<h1 id="模块和端口"><a href="#模块和端口" class="headerlink" title="模块和端口"></a>模块和端口</h1><p>大型设计往往是由一个个模块构成的。实际上，模块可大可小，大到一个复杂的微处理器系统，小到一个基本的晶体管，都可以作为一个模块来设计。例如，在上述代码中描述的 <a href="#JoshVerilog代码">JoshVerilog</a> 就是一个模块。</p>
<p>在 Verilog 中，模块（module）是基本的组成单位。</p>
<blockquote>
<p>通常，建议在一个 Verilog 文件中，只放一个 <code>module</code> 定义，而且使文件名称和 <code>module</code> 名称一致。这是一个良好的设计习惯。</p>
</blockquote>
<p>以下是 Verilog 中 <code>module</code> 的基本语法：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> 模块名称( 端口列表 );</span><br><span class="line"><span class="comment">// 声明：</span></span><br><span class="line">    <span class="keyword">reg</span>, <span class="keyword">parameter</span>,</span><br><span class="line">    <span class="keyword">input</span>, <span class="keyword">output</span>, </span><br><span class="line">    <span class="keyword">function</span>, <span class="keyword">task</span>, ...</span><br><span class="line"><span class="comment">// 语句：</span></span><br><span class="line">    <span class="keyword">initial</span> 语句</span><br><span class="line">    <span class="keyword">always</span> 语句</span><br><span class="line">    <span class="keyword">module</span> 实例化</span><br><span class="line">    门实例化</span><br><span class="line">    用户定义原语 (UDP) 实例化</span><br><span class="line">    连续赋值 (Continous assignment)</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>首先，需要有一个名称来标识这个 <code>module</code>。</p>
<p>通常 <code>module</code> 具有输入和输出端口，在 <code>module</code> 名称后面的括号中列出所有的输入、输出和双向的端口名称。</p>
<p>有些 <code>module</code> 也不包含端口。例如，在仿真平台的顶层模块中，其内部已经实例化了所有的设计模块和激励模块，是一个封闭的系统，没有输入和输出。一般这种没有端口的模块都是用于仿真的，不用作实际电路。</p>
<p>在 <code>module</code> 内部的声明部分，需要声明端口的方向，（<code>input</code>, <code>output</code> 和 <code>inout</code>）和位宽。按照 Verilog 的习惯，<strong>高位写在左边，低位写在右边</strong>。比如</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">input</span> [<span class="number">1</span>:<span class="number">0</span>] A_in；</span><br></pre></td></tr></table></figure>
<p>就表示两位的总线。</p>
<p>模块内部使用的 <code>reg</code>（寄存器类型的一种）、<code>wire</code>（线网类型的一种）、参数、函数以及任务等，都将在 <code>module</code> 中声明。</p>
<p>一般来说，<code>module</code> 的 </p>
<ul>
<li><code>input</code> 默认定义为 <code>wire</code> 类型；</li>
<li><code>output</code> 信号可以是 <code>wire</code>，也可以是 <code>reg</code> 类型（如果在 <code>always</code> 或 <code>initial</code> 语句块中被赋值）；</li>
<li><code>inout</code> 是双向信号，一般将其设为 <code>tri</code> 类型，表示其有多个驱动源，如无驱动时为三态。</li>
</ul>
<p>虽然变量声明只要出现在使用的相应语句之间即可，但还是建议将所有的声明放在所有的语句之前，这样具有较好的可读性。在声明之后，就应该是语句了。语句有如下几种：</p>
<ul>
<li><code>initial</code> 语句；</li>
<li><code>always</code> 语句；</li>
<li>其他子 <code>module</code> 实例化；</li>
<li>门实例化；</li>
<li>用户定义原语（UDP）实例化；</li>
<li>连续赋值（Continous assignment）。</li>
</ul>
<p>Verilog 中所有的功能描述都是通过以上几种描述方式进行的。</p>
<blockquote>
<p>需要格外注意的是，以上几种语句如果出现在同一个 <code>module</code> 内，其<strong>相互之间是没有任何顺序关系的</strong>，它们在 <code>module</code> 中出现顺序的改变不会改变 <code>module</code> 的功能，这正是硬件的一大特点。有硬件电路原理图设计经验的读者们可以想象一下画原理图的过程，先画哪个，后画哪个器件根本没有任何关系。在 Verilog 中也是类似的道理。</p>
</blockquote>
<h1 id="编译指令"><a href="#编译指令" class="headerlink" title="编译指令"></a>编译指令</h1><p>在 Verilog 语言中，提供了一些编译指令，用于指导编译器的工作。例如，定义宏、文件包含、条件编译、时间单位和精度定义等。</p>
<p>Verilog 中的编译指令是从 C 语言中的“预处理指令”演变得来的。这里列出了一些常用的编译指令如下：</p>
<ul>
<li><code>`timescale</code>；</li>
<li><code>`define, `undef</code>；</li>
<li><code>`ifdef, `else, `endif</code>；</li>
<li><code>`include</code>；</li>
<li><code>`resetall</code>。</li>
</ul>
<p>与 C 语言中使用的 <code>#</code> 不同，Verilog 中使用反引号一来标识编译指令。编译器一旦遇到某个编译指令，则其在整个编译过程中有效，可以包含多个文件，直到编译器遇到另一个相同的编译指令。</p>
<h2 id="timescale"><a href="#timescale" class="headerlink" title="`timescale"></a><code>`timescale</code></h2><p>在每一个 <code>module</code> 文件前面加上<code>` </code>的编译指令，就可以保证该文件中的延时信息受其自身文件中的 <code>`timescale</code> 编译指令指导。<strong>否则在编译过程中，该模块将沿用上一个</strong> <code>`timescale</code> <strong>的值，或者使用缺省值</strong>。</p>
<p>在上述实例代码中描述的 <a href="#JoshVerilog代码">JoshVerilog</a> 模块中使用了一个<code>`timescale 1ns/100ps</code> 编译指令。其中 <code>1ns</code> 表示延时单位，<code>100ps</code> 表示时间精度，也就是编译器所能接收的最小仿真时间粒度。<code>`timescale</code> 编译指令在模块外部出现，并且影响后面模块中所有的时延值，直到遇到下一个 <code>`timescale</code> 或 <code>`resetall</code>指令。</p>
<p>比如语句：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> #<span class="number">1</span><span class="variable">.16</span> A_xor_wire = eq0 ^ eq1;</span><br></pre></td></tr></table></figure>
<p>如果采用 <code>`timescale 1ns/100ps</code> 编译指令由于延时单位是 <code>1ns</code>，同时最小时间粒度是 <code>100ps</code>，即 <code>0.1ns</code> ，那么根据四舍五入的规则，<code>1.16ns</code> 则实际上对应 <code>1.2ns</code> 延时。如果采用 <code>`timescale 1ns/10ps</code> 编译指令，由于延时单位是 <code>1ns</code>，同时最小时间粒度是 <code>10ps</code>，即 <code>0.01ns</code>，那么 <code>1.16ns</code> 则实际上对应 <code>1.16ns</code> 延时。</p>
<h2 id="define-和-undef"><a href="#define-和-undef" class="headerlink" title="`define 和 `undef"></a><code>`define</code> 和 <code>`undef</code></h2><p><code>`define</code> 用于定义宏。例如，首先定义一个总线宽度的宏为 16，然后利用这个宏定义一个宽度为 16 的 <code>reg</code>类型数据 <code>Data</code>，方法如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="meta-keyword">define</span> BUS_WIDTH 16</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="meta">`BUS_WIDTH - 1 : 0] Data</span></span><br></pre></td></tr></table></figure>
<p>在一个文件中出现的 <code>`define</code>，可以被多个文件使用。也就是说 <code>`define</code> 是一种<strong>全局的定义</strong>。这是 <code>`define</code> 与 <code>parameter</code> 定义的最大区别，在后面也会提到。</p>
<p><code>`define</code> 指令被编译以后，则在整个编译过程中都有效，直到遇到 <code>`undef</code> 指令，该宏就不再有效。如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="meta-keyword">undef</span> BUS_WIDTH</span></span><br></pre></td></tr></table></figure>
<p>遇到该编译指令后，先前的 <code>`define</code> 指令失效。</p>
<h2 id="ifdef、-else-和-endif"><a href="#ifdef、-else-和-endif" class="headerlink" title="`ifdef、`else 和`endif"></a><code>`ifdef</code>、<code>`else</code> 和<code>`endif</code></h2><p>再来看看如下的条件编译指令：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="meta-keyword">ifdef</span> NARROW</span></span><br><span class="line">    <span class="keyword">parameter</span> BUS_WIDTH = <span class="number">16</span>；</span><br><span class="line"><span class="meta">`<span class="meta-keyword">else</span></span></span><br><span class="line">    paramete rBUS_WIDTH = <span class="number">32</span>；</span><br><span class="line"><span class="meta">`<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>在这个条件编译指令中，如果先前已经定义了 <code>NARROW</code> 宏，那么参数 <code>BUS_WIDTH</code> 被设置为 16，否则其被设置为 32。<code>`else</code> 指令对于 <code>`ifdef</code> 来说是可选的，也就是说可以单独使用。</p>
<h2 id="include"><a href="#include" class="headerlink" title="`include"></a><code>`include</code></h2><p>在 Verilog 中，可以使用 <code>`include</code> 指令来嵌人某个文件的内容。例如：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="meta-keyword">include</span> &quot;HEADFILE.h&quot;</span></span><br></pre></td></tr></table></figure>
<p>那么，在编译的时候，就将使用 <code>HEADFILE.h</code> 文件中的内容完全替换这一行语句。而双引号中的文件可以使用相对路径，或绝对路径，或者默认在当前路径以下。</p>
<h2 id="resetall"><a href="#resetall" class="headerlink" title="`resetall"></a><code>`resetall</code></h2><p><code>`resetall</code> 编译指令会将所有其他编译指令重新设置为缺省值，要谨慎使用。</p>
<blockquote>
<p>Verilog 语言中的编译指令不止这几条，其他不常用的指令这里不一一介绍，有兴趣可以参考其他文献。</p>
</blockquote>
<h1 id="逻辑值与常量"><a href="#逻辑值与常量" class="headerlink" title="逻辑值与常量"></a>逻辑值与常量</h1><h2 id="逻辑值"><a href="#逻辑值" class="headerlink" title="逻辑值"></a>逻辑值</h2><p>在二进制计数中，单位逻辑值只有 <code>1</code> 和 <code>0</code> 两种状态。而在 Verilog 语言中，为了对电路进行精确建模，于是增加了两种逻辑状态 <code>X</code> 和 <code>Z</code>。</p>
<ul>
<li><code>X</code> 表示未知值（unknown），或者不关心（don’t care），<code>X</code> 用作信号状态时表示未知，用在条件判断时（在 <code>casex</code> 或 <code>casez</code>中）表示不关心；</li>
<li><code>Z</code> 表示高阻状态，也就是<strong>没有任何驱动</strong>，通常用来对<strong>三态总线</strong>进行建模。</li>
</ul>
<p>在后面将提到 Verilog 语言中的变量类型。通常 <code>net</code> 型变量如果没有初始化，其值为 <code>Z</code>，<code>register</code> 型变量如果没有初始化，其值为 <code>X</code> 。这一点在仿真时显得比较有意义。</p>
<blockquote>
<p>但是，对综合工具而言（或者说在实际电路中），并没有什么 <code>X</code> 值，只存在 <code>0</code>、<code>1</code> 和 <code>Z</code> 这 3 种状态。在实际电路中还可能出现亚稳态，它既不是 <code>0</code>，也不是 <code>1</code>，是一种暂时的不稳定状态。</p>
</blockquote>
<p>Verilog 语言中所有数据都是由以上描述的 4 种基本的逻辑值 <code>0</code>、<code>1</code>、<code>X</code> 和 <code>Z</code> 构成。同时，<code>X</code> 和 <code>Z</code> 是不区分大小写的。例如：<code>0z1x</code> 和 <code>0Z1X</code> 表示同一个数据。</p>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>常量是 Verilog 中不变的数值。在上述<a href="#JoshVerilog代码">实例代码</a>中，<code>4&#39;b0001</code> 就表示一个 4 位的二进制整型常量：0001。</p>
<p>Verilog中的常量有3种：</p>
<ul>
<li>整数型；</li>
<li>实数型；</li>
<li>字符串型。</li>
</ul>
<h3 id="整型常量"><a href="#整型常量" class="headerlink" title="整型常量"></a>整型常量</h3><p>可以使用简单的十进制表示一个整型常量，例如：</p>
<ul>
<li><code>16</code> 表示十进制的 16；</li>
<li><code>-15</code> 表示十进制的 -15，用二进制补码表示，至少需要 5 位，即 10001，最高一位为符号位；如果用 6 位表示，则是 110001，同样最高一位为符号位。</li>
</ul>
<p>整数型常量也可以采用基数表示法，例如：</p>
<ul>
<li><code>8&#39;haa</code>：表示 8 位的<strong>十六进制数</strong>，换算成二进制是 1010_1010。</li>
<li><code>6&#39;o33</code>：表示 6 位的<strong>八进制数</strong>，换算成二进制是 011_011。</li>
<li><code>4&#39;b1011</code>：表示 4 位的<strong>二进制数</strong> 1011。</li>
<li><code>3&#39;d7</code>：表示 3 位<strong>十进制</strong>的 7。</li>
</ul>
<p>在基数表示法中，都是以如下格式写的：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">[长度]&#x27;数值符号 数字</span><br></pre></td></tr></table></figure>
<p>其中长度可有可无，数值符号中，<code>h</code> 表示十六进制，<code>o</code> 表示八进制，<code>b</code> 表示二进制，<code>d</code> 表示十进制数据。如果长度比后面数字的实际位数多，则<strong>自动在数字的左边补足 0</strong>；如果位数少，则<strong>自动截断数字左边超出的位数</strong>。</p>
<p>如果将数字写成 <code>&#39;haa</code>，那么这个十六进制数的长度就决定于数字本身的长度。</p>
<p>在基数表示法中，如果遇到 <code>X</code>，十六进制数中表示 4 个 <code>X</code>，八进制数中表示 3 个 <code>X</code>。</p>
<p>另外，数字中的下划线没有任何意义，只是增强可读性。例如：<code>4&#39;b1011</code> 和 <code>4&#39;b10_11</code> 一样。</p>
<h3 id="实数型常量"><a href="#实数型常量" class="headerlink" title="实数型常量"></a>实数型常量</h3><p>Verilog 语言中的实数型变量可以采用十进制，也可以采用科学计数法，例如：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span><span class="variable">.512</span></span><br><span class="line"><span class="number">13_2</span><span class="variable">.18e2</span>       <span class="comment">// 表示13218</span></span><br></pre></td></tr></table></figure>
<h3 id="字符串型常量"><a href="#字符串型常量" class="headerlink" title="字符串型常量"></a>字符串型常量</h3><p>字符串是双引号中的字符序列，例如：<code>&quot;HeIIo World&quot;</code>。字符串是 8 位 ASCII 码值的序列，<code>&quot;HeIIo World&quot;</code> 就需要 11 字节存储，方法如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">reg</span>[<span class="number">1</span>:<span class="number">8</span> * <span class="number">11</span>] Message;</span><br><span class="line">Message = <span class="string">&quot;HeIIo World&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>这样就将字符串常量存人到 Message 变量中。</p>
<h1 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h1><p>在 Verilog 语言中，有两大变量类型：</p>
<ul>
<li>线网型：表示电路间的物理连线。</li>
<li>寄存器型：Verilog 中的一个抽象的存储数据单元。</li>
</ul>
<p>对于初学者而言，则需要首先遵守如下的简单规则：</p>
<ul>
<li><strong>凡是在</strong> <code>always</code> <strong>或</strong> <code>initial</code> <strong>语句中赋值的变量，一定是寄存器变量</strong>；</li>
<li><strong>在</strong> <code>assign</code> <strong>中赋值的一定是线网变量</strong>。</li>
</ul>
<h2 id="线网类型"><a href="#线网类型" class="headerlink" title="线网类型"></a>线网类型</h2><p>在线网类型下，分为几种子类，它们具有线网的共性：</p>
<ul>
<li><code>wire</code>、<code>tri</code>：表示电路间连线，<code>tri</code> 主要用于多驱动源建模；</li>
<li><code>wor</code>、<code>trior</code>：表示该连线具有“线或”功能；</li>
<li><code>wand</code>、<code>triand</code>：表示该连线具有“线与”功能；</li>
<li><code>trireg</code>：表示该连线具有总线保持功能；</li>
<li><code>tri1</code>、<code>tri0</code>：表示当无驱动时，连线状态为1（<code>tri1</code>）和0（<code>tri0</code>）；</li>
<li><code>supply1</code>、<code>supply0</code>：分别表示电源和地信号。</li>
</ul>
<p>在以上描述的线网类型中，除了 <code>trireg</code> 未初始化时为 <code>X</code> 以外，其余的未初始化时的值为 <code>Z</code>。</p>
<p>线网类型主要用在连续赋值语句中，以及作为模块之间的互连信号。</p>
<p>在后面的内容中会详细阐述常用线网类型的使用方法。</p>
<h2 id="寄存器类型"><a href="#寄存器类型" class="headerlink" title="寄存器类型"></a>寄存器类型</h2><p>寄存器类型变量在 Verilog 语言中通常表示一个存储数据的空间。尤其是在 Verilog 仿真器中，寄存器类型变量通常占据一个仿真内存空间。</p>
<ul>
<li><code>reg</code>：是最常用的寄存器类型数，可以是 1 位或者多位，或者是二维数组（存储器）；</li>
<li><code>integer</code>：整型数据，存储一个至少 32 位</li>
<li><code>time</code>：时间类型，存储一个至少 64 位的时间值；</li>
<li><code>real</code>，<code>realtime</code>：实数和实数时间寄存器。</li>
</ul>
<h3 id="reg-类型"><a href="#reg-类型" class="headerlink" title="reg 类型"></a><code>reg</code> 类型</h3><ol>
<li><p>寄存器类型数</p>
<p> <code>reg</code> 类型可以定位为一个寄存器，可以定义一位或者多位，例如：</p>
 <figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">reg</span>         AB;             <span class="comment">// 定义一个名为 AB 的 1 位寄存器</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>]   ABC;            <span class="comment">// 定义一个名为 ABC 的 4 位寄存器</span></span><br></pre></td></tr></table></figure>
<p> 在多位寄存器中，可以作“位选择”或“部分选择”，例如：</p>
 <figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">ABC [<span class="number">3</span>] = <span class="number">1</span>;                <span class="comment">// 将 ABC 的第 3 位赋值为 1</span></span><br><span class="line">ABC [<span class="number">0</span>] = <span class="number">0</span>;                <span class="comment">// 将 ABC 的第 0 位赋为 0</span></span><br><span class="line">ABC [<span class="number">2</span>:<span class="number">1</span>] = <span class="number">2&#x27;b01</span>;          <span class="comment">// 将 ABC 的第 1、2 位赋值为 1 和 0</span></span><br></pre></td></tr></table></figure>
<p> 这样，整个 <code>ABC</code> 变量的值为 <code>4&#39;b1010</code>。</p>
</li>
<li><p>寄存器类型数组</p>
<p> <code>reg</code> 类型可以作为二维数组，也就是存储器，例如：</p>
 <figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] MEMABC [<span class="number">0</span>:<span class="number">7</span>];     <span class="comment">// 定义一个存储器，地址为 0~7，每个存储单元是 4 位</span></span><br></pre></td></tr></table></figure>
<p> 与一维的 <code>reg</code> 变量不同的是，存储器中的存储单元不能再做位选择或部分选择，而每个单元可以单独赋值。比如：</p>
 <figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">MEMABC[<span class="number">1</span>] = <span class="number">4&#x27;b0101</span>;        <span class="comment">// 为 MEMABC 中的第 1 个存储单元赋值 4&#x27;b0101</span></span><br></pre></td></tr></table></figure>
<p> 同时，在 Verilog 中，不存可以对整个存储器赋值的语句，必须对每个单元独立赋值。除非使用 <code>$readmemb</code> 或 <code>$readmemh</code> 系统任务从文件中读入整个或者部分存储器的数据。</p>
</li>
</ol>
<h3 id="integer-类型"><a href="#integer-类型" class="headerlink" title="integer 类型"></a><code>integer</code> 类型</h3><p><code>integer</code> 变量通常用于高层次建模，也常用在 <code>for</code> 语句的索引中，例如：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">initial</span></span><br><span class="line"><span class="keyword">begin</span>: ACCESS</span><br><span class="line">    <span class="keyword">integer</span> i;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">7</span>; i = i + <span class="number">1</span> )        <span class="comment">// 定义一个整数变量 i</span></span><br><span class="line">        MEMABC[i] = i                       <span class="comment">// 遍历 0～7 地址</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3 id="其他寄存器类型"><a href="#其他寄存器类型" class="headerlink" title="其他寄存器类型"></a>其他寄存器类型</h3><p>另外，<code>time</code> 变量用于存储和处理系统时间，<code>real</code> 和 <code>realtime</code> 用来存储实数和实数时间。</p>
<h2 id="7-3-变量的物理含义"><a href="#7-3-变量的物理含义" class="headerlink" title="7.3 变量的物理含义"></a>7.3 变量的物理含义</h2><p>这里需要引起重视，<strong>“线网”变量可以理解为电路模块中的连线，但“寄存器”并不严格对应于电路上的存储单元</strong>，包括触发器（flip-flop）或锁存器（latch）。从纯粹语言表达的语义角度来说，寄存器类型变量的值，从一个赋值到下一个赋值被保存下来，并且在仿真过程中会保持而不会丢失。</p>
<p>实际上，从语义上来讲，在 Verilog 仿真工具对语言进行仿真的时候，<strong>寄存器类型的变量是占用仿真环境的物理内存的</strong>，这与 C 语言中的变量类似。寄存器在被赋值后，便一直保存在内存中，保持该值不变，直到再次对该寄存器变量进行赋值。而<strong>线网类型是不占用仿内存的</strong>，它的值是由当前所有驱动该线网的其他变量（可以是寄存器或线网）决定的。这是寄存器和线网最大的区别，也是当初 Verilog 的发明者定义“线网”和“寄存器”变量的根本动机。</p>
<p>在下一小节中，将引人“驱动”和“赋值”两个概念，深人探讨两种变量的含义。</p>
<h2 id="驱动和赋值"><a href="#驱动和赋值" class="headerlink" title="驱动和赋值"></a>驱动和赋值</h2><p>为了更清楚地描述寄存器和线网变量的概念，将以上述<a href="#JoshVerilog代码">实例代码</a>中的语句来说明。首先，引人Verilog 语言中两个重要的概念：驱动（Driving）和赋值（Assigning)。</p>
<ul>
<li><strong>线网是被驱动的，该值不被保持，在任意一个仿真步进上都需要重新计算</strong>；</li>
<li><strong>寄存器是被赋值的，且该值在仿真过程中被保持，直到下一个赋值的出现</strong>。</li>
</ul>
<p>在上述<a href="#JoshVerilog代码">实例代码</a>中，定义了一个 <code>A_xor_wire</code> 的 <code>wire</code>，它是 <code>eq0</code> 和 <code>eq1</code> 相异或的结果。采用如下描述方式：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> #<span class="number">1</span> A_xor_wire = eq0 ^ eq1;</span><br></pre></td></tr></table></figure>
<p>实际上，也可以采用如下的另一种描述方式：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @(eq0 <span class="keyword">or</span> eq1)</span><br><span class="line">    A_xor_wire = #<span class="number">1</span> eq0 ^ eq1;</span><br></pre></td></tr></table></figure>
<p>当然需要在 <code>module</code> 的声明处，将 <code>A_xor_wire</code> 首先定义成 <code>reg</code> 变量，而不是 <code>wire</code> 变量，即需要做如下定义：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">reg</span> A_xor_wire</span><br></pre></td></tr></table></figure>
<p>这两者描述的目的一样，都是一个异或门，如下图所示。</p>
<div align="center">
  <img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-28-josh-verilog-part-2/2020-11-28-josh-verilog-part-2-020-XORGate.png?imageMogr2/thumbnail/!35p|watermark/2/text/QEpvc2ggR2Fv/fontsize/15/dissolve/60/gravity/southeast/dx/5/dy/5"/>
</div>

<p>下面从语义上的角度探讨两种描述方式的不同。</p>
<p>第一种描述方式使用 <code>assign</code> 语句，Verilog 中将其称为连续赋值语句（Continously Assignment）实际上是<strong>连续驱动</strong>的过程。也就是说，在任意一个仿真时刻，当前时刻 <code>eq0</code> 和 <code>eq1</code> 相异或的结果决定了 <code>1ns</code> 以后（语句 <code>#1</code> 的延时控制）的线网变量 <code>A_xor_wire</code> 的值，<strong>不管 <code>eq0</code> 和 <code>eq1</code> 变化与否，这个驱动过程一直存在</strong>，因此称为连续驱动。（在仿真器中，线网变量是不占用仿真内存空间的。）如上<a href="#异或门">异或门图</a>中的时序所示，这个驱动过程在任意时刻都存在。</p>
<p>在第二种描述方式中使用了 <code>always</code> 语句，后面紧跟着一个敏感列表：<code>@(eq0 or eq1)</code> 因此，这个语句只有在 <code>eq0</code> 或 <code>eq1</code> 发生变化时才会执行。如上<a href="#异或门">异或门图</a>中，在时刻 2、3 和 6，该语句都将执行，将 <code>eq0</code> 和 <code>eq1</code> 赋值的结果延时 1ns 以后赋值给 <code>A_xor_wire</code> 变量。<strong>在其他时刻，<code>A_xor_wire</code> 变量必须保持</strong>。因此，<strong>从仿真语义上讲，需要一个存储单元，也可以说是寄存器，来保存 <code>A_xor_wire</code> 变量的中间值</strong>。这就是Verilog 语言的“寄存器类型”变量的来历，而这个 <code>A_xor_wire</code> 变量首先需要定义为 <code>reg</code> 类型。</p>
<p>不管采用哪种方式，所描述的是一样的组合逻辑电路。尤其是第二种描述，虽然其在语言中被定义为 reg 型，但并不是对应硬件上的触发器（flip-flop），而是 Verilog 语言仿真语义上的寄存器概念。</p>
<p>但是，在对实际电路中D触发器建模的时候，必须采用 <code>reg</code> 型的变量。下图是 D 触发器的模型。</p>
<div align="center">
  <img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-28-josh-verilog-part-2/2020-11-28-josh-verilog-part-2-030-DFlipFlop.png?imageMogr2/thumbnail/!40p|watermark/2/text/QEpvc2ggR2Fv/fontsize/15/dissolve/60/gravity/southeast/dx/5/dy/5"/>
</div>

<p>在上述<a href="#JoshVerilog代码">实例代码</a>中相应的描述如下：</p>
<figure class="highlight verilog"><figcaption><span>Josh.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">    <span class="keyword">if</span> (~rst_n)</span><br><span class="line">        A_xor_out &lt;= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        A_xor_out &lt;= A_xor_wire;</span><br></pre></td></tr></table></figure>
<p>D 触发器只对时钟和复位（置位）敏感，因此在敏感列表中，列出了 <code>clk</code> 的上升沿和 <code>rst_n</code> 的下降沿。如果 <code>rst_n</code> 为 0，就对触发器的输出复位，否则在 <code>clk</code> 的时钟上升沿发生的时候，将输人的 <code>A_xor_wire</code> 寄存到触发器的输出端 <code>A_xor_out</code>。</p>
<p>这样的代码精确地描述了一个 D 触发器的行为。这里的 <code>reg</code> 变量就对应了硬件中的 D 触发器。</p>
<p>在叙述时，为了简单起见，常常将“驱动”和“赋值”都统一说成是赋值，但是一定要清楚其中的本质。</p>
<h1 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h1><p>参数是一种常量，通常出现在 <code>module</code> 内部。它常常被用作定义状态机的状态、数据位宽和延时大小等等。例如：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">parameter</span> and_delay = <span class="number">2</span>；</span><br><span class="line"><span class="keyword">parameter</span> xor_delay = <span class="number">4</span>；</span><br></pre></td></tr></table></figure>
<p><strong>参数的值可以在编译时被改变</strong>，因此它又<strong>经常被用于一些参数可调的模块中</strong>，让用户在实例化模块时，根据需要配置参数。</p>
<p>前面介绍的 <code>`define</code> 是一种全局的定义，而 <code>parameter</code> 是出现在模块内部的<strong>局部定义</strong>，而且可以被<strong>灵活改变</strong>，这是 <code>parameter</code> 的一个重要特征。</p>
<p>在<a href="https://josh-gao.blog.csdn.net/article/details/105262549#42__865">《Part 3——描述方式和设计层次》的 4.2 小节</a>中会详细探讨改变模块参数的方法。</p>
<h1 id="Verilog-中的并发与顺序"><a href="#Verilog-中的并发与顺序" class="headerlink" title="Verilog 中的并发与顺序"></a>Verilog 中的并发与顺序</h1><p>并行概念是硬件中的一个非常重要的概念，特别是初学者或软件工程师们需要重点理解。</p>
<p>与在处理器上运行的软件不同的是，<strong>硬件电路之间的工作是并行的</strong>。</p>
<p>为了描述硬件的并行性，Verilog 语言本身就具有并发的特性。在 Verilog 语言的 <code>module</code> 中，所有的描述语句（包括连续赋值语句，行为语句块：<code>always</code> 和 <code>initial</code>，模块实例化等）之间都是并行发生的。任何功能描述语句，在 Verilog 的 module 中的顺序都不重要。</p>
<p>但是，在语句块（<code>always</code> 和 <code>initial</code>）内部，则可以存在两种语句组：</p>
<ul>
<li><code>begin ... end</code>：顺序语句组；</li>
<li><code>fork ... join</code>：并行语句组。</li>
</ul>
<p>在 <code>begin ... end</code> 中存在的语句，按照 Veilog 的语义，应该是顺序执行的。而在 <code>fork ... join</code> 中的语句，则是并行执行的。</p>
<p>相比较顺序运行的事物，并行的事物比较难以理解和建模。同时，用于仿真的计算机是串行执行的，而 Verilog 语言本身的语义是用计算机进行模拟的语义，是用一种串行的语义来模拟并行的硬件。</p>
<p>Verilog 仿真器用来模拟硬件的并行行为的方式类似于软件中的多任务操作系统，在某个时刻只能执行一个任务，这样，不同的任务之间看起来是并行执行的。</p>
<p>后续将会重点介绍 Verilog 语言中的这一并行特性，同时阐述 Verilog 的高级仿真原理，希望能帮助大家领会 Verilog 的语义精髓。</p>
<h1 id="操作数、操作符和表达式"><a href="#操作数、操作符和表达式" class="headerlink" title="操作数、操作符和表达式"></a>操作数、操作符和表达式</h1><h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><p>操作符是操作数之间的运算符号。在介绍操作数之前，先来看看 Verilog 中的各种操作符。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">操作符</th>
<th style="text-align:left">含义</th>
<th style="text-align:left">操作符</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>+</code></td>
<td style="text-align:left">一元加</td>
<td style="text-align:left"><code>&gt;&gt;</code></td>
<td style="text-align:left">右移</td>
</tr>
<tr>
<td style="text-align:left"><code>-</code></td>
<td style="text-align:left">一元减</td>
<td style="text-align:left"><code>&lt;</code></td>
<td style="text-align:left">小于</td>
</tr>
<tr>
<td style="text-align:left"><code>!</code></td>
<td style="text-align:left">一元逻辑非</td>
<td style="text-align:left"><code>&lt;=</code></td>
<td style="text-align:left">小于等于</td>
</tr>
<tr>
<td style="text-align:left"><code>~</code></td>
<td style="text-align:left">一元按位求反</td>
<td style="text-align:left"><code>&gt;</code></td>
<td style="text-align:left">大于</td>
</tr>
<tr>
<td style="text-align:left"><code>&amp;</code></td>
<td style="text-align:left">归约与</td>
<td style="text-align:left"><code>&gt;=</code></td>
<td style="text-align:left">大于等于</td>
</tr>
<tr>
<td style="text-align:left"><code>~&amp;</code></td>
<td style="text-align:left">归约与非</td>
<td style="text-align:left"><code>==</code></td>
<td style="text-align:left">逻辑相等</td>
</tr>
<tr>
<td style="text-align:left"><code>^</code></td>
<td style="text-align:left">归约异或</td>
<td style="text-align:left"><code>!=</code></td>
<td style="text-align:left">逻辑不等</td>
</tr>
<tr>
<td style="text-align:left"><code>^~</code> 或 <code>~^</code></td>
<td style="text-align:left">归约异或非</td>
<td style="text-align:left"><code>===</code></td>
<td style="text-align:left">全等</td>
</tr>
<tr>
<td style="text-align:left"><code>&#124;</code></td>
<td style="text-align:left">归约或</td>
<td style="text-align:left"><code>!==</code></td>
<td style="text-align:left">非全等</td>
</tr>
<tr>
<td style="text-align:left"><code>~&#124;</code></td>
<td style="text-align:left">归约或非</td>
<td style="text-align:left"><code>&amp;</code></td>
<td style="text-align:left">按位与</td>
</tr>
<tr>
<td style="text-align:left"><code>*</code></td>
<td style="text-align:left">乘</td>
<td style="text-align:left"><code>^</code></td>
<td style="text-align:left">按位异或</td>
</tr>
<tr>
<td style="text-align:left"><code>/</code></td>
<td style="text-align:left">除以</td>
<td style="text-align:left"><code>^~</code> 或 <code>~^</code></td>
<td style="text-align:left">按位异或非</td>
</tr>
<tr>
<td style="text-align:left"><code>%</code></td>
<td style="text-align:left">取模</td>
<td style="text-align:left"><code>&#124;</code></td>
<td style="text-align:left">按位或</td>
</tr>
<tr>
<td style="text-align:left"><code>+</code></td>
<td style="text-align:left">二元加</td>
<td style="text-align:left"><code>&amp;&amp;</code></td>
<td style="text-align:left">逻辑与</td>
</tr>
<tr>
<td style="text-align:left"><code>-</code></td>
<td style="text-align:left">二元减</td>
<td style="text-align:left"><code>&#124;&gt;&#124;</code></td>
<td style="text-align:left">逻辑或</td>
</tr>
<tr>
<td style="text-align:left"><code>&lt;&lt;</code></td>
<td style="text-align:left">左移</td>
<td style="text-align:left"><code>? :</code></td>
<td style="text-align:left">条件操作符</td>
</tr>
</tbody>
</table>
</div>
<p>其中，一元操作表示仅有一个操作数，二元操作表示有两个操作数。归约操作也是只有一个操作数，它是该操作数中的所有位之间的计算。</p>
<h3 id="算术操作符"><a href="#算术操作符" class="headerlink" title="算术操作符"></a>算术操作符</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">操作符</th>
<th style="text-align:center">表达式</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>+</code></td>
<td style="text-align:center"><code>m + n</code></td>
<td style="text-align:center">将 <code>n</code> 与 <code>m</code> 相加</td>
</tr>
<tr>
<td style="text-align:center"><code>-</code></td>
<td style="text-align:center"><code>m - n</code></td>
<td style="text-align:center">将 <code>m</code> 减去 <code>n</code></td>
</tr>
<tr>
<td style="text-align:center"><code>-</code></td>
<td style="text-align:center"><code>-m</code></td>
<td style="text-align:center">将 <code>m</code> 取反（二进制补码）</td>
</tr>
<tr>
<td style="text-align:center"><code>*</code></td>
<td style="text-align:center"><code>m * n</code></td>
<td style="text-align:center">将 <code>m</code> 与 <code>n</code> 相乘</td>
</tr>
<tr>
<td style="text-align:center"><code>/</code></td>
<td style="text-align:center"><code>m / n</code></td>
<td style="text-align:center">将 <code>m</code> 除以 <code>n</code></td>
</tr>
<tr>
<td style="text-align:center"><code>%</code></td>
<td style="text-align:center"><code>m % n</code></td>
<td style="text-align:center">对 <code>m / n</code> 求模</td>
</tr>
</tbody>
</table>
</div>
<h3 id="按位操作符"><a href="#按位操作符" class="headerlink" title="按位操作符"></a>按位操作符</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">操作符</th>
<th style="text-align:center">表达式</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>~</code></td>
<td style="text-align:center"><code>~m</code></td>
<td style="text-align:center">将 <code>m</code> 的每个位取反</td>
</tr>
<tr>
<td style="text-align:center"><code>&amp;</code></td>
<td style="text-align:center"><code>m &amp; n</code></td>
<td style="text-align:center">将 <code>m</code> 的每个位与 <code>n</code> 的相应位相与</td>
</tr>
<tr>
<td style="text-align:center"><code>&#124;</code></td>
<td style="text-align:center"><code>m &#124; n</code></td>
<td style="text-align:center">将 <code>m</code> 的每个位与 <code>n</code> 的相应位相或</td>
</tr>
<tr>
<td style="text-align:center"><code>^</code></td>
<td style="text-align:center"><code>m ^ n</code></td>
<td style="text-align:center">将 <code>m</code> 的每个位与 <code>n</code> 的相应位相异或</td>
</tr>
<tr>
<td style="text-align:center"><code>~^</code><br><code>^~</code></td>
<td style="text-align:center"><code>m ~^ n</code><br><code>m ^~ n</code></td>
<td style="text-align:center">将 <code>m</code> 的每个位与 <code>n</code> 的相应位相异或非</td>
</tr>
</tbody>
</table>
</div>
<h3 id="归约操作符"><a href="#归约操作符" class="headerlink" title="归约操作符"></a>归约操作符</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">操作符</th>
<th style="text-align:center">表达式</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>&amp;</code></td>
<td style="text-align:center"><code>&amp;m</code></td>
<td style="text-align:center">将 <code>m</code> 中的所有位相与（1位结果）</td>
</tr>
<tr>
<td style="text-align:center"><code>~&amp;</code></td>
<td style="text-align:center"><code>~&amp;m</code></td>
<td style="text-align:center">将 <code>m</code> 中的所有位相与非（1位结果）</td>
</tr>
<tr>
<td style="text-align:center"><code>&#124;</code></td>
<td style="text-align:center"><code>&#124;m</code></td>
<td style="text-align:center">将 <code>m</code> 中的所有位相或（1位结果）</td>
</tr>
<tr>
<td style="text-align:center"><code>~&#124;</code></td>
<td style="text-align:center"><code>~&#124;m</code></td>
<td style="text-align:center">将 <code>m</code> 中的所有位或非（1位结果）</td>
</tr>
<tr>
<td style="text-align:center"><code>^</code></td>
<td style="text-align:center"><code>^m</code></td>
<td style="text-align:center">将 <code>m</code> 中的所有位异或（1位结果）</td>
</tr>
<tr>
<td style="text-align:center"><code>~^</code><br><code>^~</code></td>
<td style="text-align:center"><code>~^m</code><br><code>^~m</code></td>
<td style="text-align:center">将 <code>m</code> 中的所有位相异或非（1位结果）</td>
</tr>
</tbody>
</table>
</div>
<h3 id="逻辑操作符"><a href="#逻辑操作符" class="headerlink" title="逻辑操作符"></a>逻辑操作符</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">操作符</th>
<th style="text-align:center">表达式</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>!</code></td>
<td style="text-align:center"><code>!m</code></td>
<td style="text-align:center"><code>m</code> 是否不为真？（1 位 真/假结果）</td>
</tr>
<tr>
<td style="text-align:center"><code>&amp;&amp;</code></td>
<td style="text-align:center"><code>m &amp;&amp; n</code></td>
<td style="text-align:center"><code>m</code> 和 <code>n</code> 是否都为真？（1位 真/假结果）</td>
</tr>
<tr>
<td style="text-align:center"><code>&#124;&#124;</code></td>
<td style="text-align:center"><code>m &#124;&#124; n</code></td>
<td style="text-align:center"><code>m</code> 或 <code>n</code> 是否为真？（1位 真/假结果）</td>
</tr>
</tbody>
</table>
</div>
<h3 id="相等操作符"><a href="#相等操作符" class="headerlink" title="相等操作符"></a>相等操作符</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">操作符</th>
<th style="text-align:center">表达式</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>==</code></td>
<td style="text-align:center"><code>m == n</code></td>
<td style="text-align:center"><code>m</code> 和 <code>n</code> 相等吗？（1 位 正确/错误结果）</td>
</tr>
<tr>
<td style="text-align:center"><code>!=</code></td>
<td style="text-align:center"><code>m != n</code></td>
<td style="text-align:center"><code>m</code> 和 <code>n</code> 不等吗？（1 位 正确/错误结果）</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>相等操作符仅比较逻辑 1 和 0。</p>
</blockquote>
<h3 id="全等操作符"><a href="#全等操作符" class="headerlink" title="全等操作符"></a>全等操作符</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">操作符</th>
<th style="text-align:center">表达式</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>===</code></td>
<td style="text-align:center"><code>m === n</code></td>
<td style="text-align:center"><code>m</code> 和 <code>n</code> 全等吗？（1 位 正确/错误结果）</td>
</tr>
<tr>
<td style="text-align:center"><code>!==</code></td>
<td style="text-align:center"><code>m !== n</code></td>
<td style="text-align:center"><code>m</code> 和 <code>n</code> 不全等吗？（1 位 正确/错误结果）</td>
</tr>
</tbody>
</table>
</div>
<h3 id="关系操作符"><a href="#关系操作符" class="headerlink" title="关系操作符"></a>关系操作符</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">操作符</th>
<th style="text-align:center">表达式</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>&lt;</code></td>
<td style="text-align:center"><code>m &lt; n</code></td>
<td style="text-align:center"><code>m</code> 小于 <code>n</code> ？（1 位 正确/错误结果）</td>
</tr>
<tr>
<td style="text-align:center"><code>&gt;</code></td>
<td style="text-align:center"><code>m &gt; n</code></td>
<td style="text-align:center"><code>m</code> 大于 <code>n</code> ？（1 位 正确/错误结果）</td>
</tr>
<tr>
<td style="text-align:center"><code>&lt;=</code></td>
<td style="text-align:center"><code>m &lt;= n</code></td>
<td style="text-align:center"><code>m</code> 小于等于 <code>n</code> ？（1 位 正确/错误结果）</td>
</tr>
<tr>
<td style="text-align:center"><code>&gt;=</code></td>
<td style="text-align:center"><code>m &gt;= n</code></td>
<td style="text-align:center"><code>m</code> 大于等于 <code>n</code> ？（1 位 正确/错误结果）</td>
</tr>
</tbody>
</table>
</div>
<h3 id="逻辑移位操作符"><a href="#逻辑移位操作符" class="headerlink" title="逻辑移位操作符"></a>逻辑移位操作符</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">操作符</th>
<th style="text-align:center">表达式</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>&lt;&lt;</code></td>
<td style="text-align:center"><code>m &lt;&lt; n</code></td>
<td style="text-align:center">将 <code>m</code> 左移 <code>n</code> 位</td>
</tr>
<tr>
<td style="text-align:center"><code>&gt;&gt;</code></td>
<td style="text-align:center"><code>m &gt;&gt; n</code></td>
<td style="text-align:center">将 <code>m</code> 右移 <code>n</code> 位</td>
</tr>
</tbody>
</table>
</div>
<h3 id="条件操作符"><a href="#条件操作符" class="headerlink" title="条件操作符"></a>条件操作符</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">操作符</th>
<th style="text-align:center">表达式</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>? :</code></td>
<td style="text-align:center"><code>sel ? m : n</code></td>
<td style="text-align:center">如果 <code>sel</code> 为真，选择 <code>m</code>，否则选择 <code>n</code></td>
</tr>
</tbody>
</table>
</div>
<h3 id="连接复制操作符"><a href="#连接复制操作符" class="headerlink" title="连接复制操作符"></a>连接复制操作符</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">操作符</th>
<th style="text-align:center">表达式</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>&#123; &#125;</code></td>
<td style="text-align:center"><code>&#123;m,n&#125;</code></td>
<td style="text-align:center">将 <code>m</code> 和 <code>n</code> 连接起来，产生更大的向量</td>
</tr>
<tr>
<td style="text-align:center"><code>&#123;&#123; &#125;&#125;</code></td>
<td style="text-align:center"><code>&#123;n&#123;m&#125;&#125;</code></td>
<td style="text-align:center">将 <code>m</code> 重复 <code>n</code> 次</td>
</tr>
</tbody>
</table>
</div>
<p>在以上描述的操作符之间有优先级之分，下表体现了不同的操作数优先级由高到低排列。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">操作符</th>
<th style="text-align:center">优先级</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>!</code>、<code>~</code>、<code>+</code>、<code>-</code>（一元）</td>
<td style="text-align:center">最高优先级</td>
</tr>
<tr>
<td style="text-align:center"><code>*</code>、<code>/</code>、<code>%</code></td>
<td style="text-align:center">$\vdots$</td>
</tr>
<tr>
<td style="text-align:center"><code>+</code>、<code>-</code>（二元）</td>
<td style="text-align:center">$\vdots$</td>
</tr>
<tr>
<td style="text-align:center"><code>&lt;&lt;</code>、<code>&gt;&gt;</code></td>
<td style="text-align:center">$\vdots$</td>
</tr>
<tr>
<td style="text-align:center"><code>&lt;</code>、<code>&lt;=</code>、<code>&gt;</code>、<code>&gt;=</code></td>
<td style="text-align:center">$\vdots$</td>
</tr>
<tr>
<td style="text-align:center"><code>==</code>、<code>!=</code>、<code>===</code>、<code>!==</code></td>
<td style="text-align:center">$\vdots$</td>
</tr>
<tr>
<td style="text-align:center"><code>&amp;</code>、<code>~&amp;</code></td>
<td style="text-align:center">$\vdots$</td>
</tr>
<tr>
<td style="text-align:center"><code>^</code>、<code>~^</code></td>
<td style="text-align:center">$\vdots$</td>
</tr>
<tr>
<td style="text-align:center"><code>&#124;</code>、<code>~&#124;</code></td>
<td style="text-align:center">$\vdots$</td>
</tr>
<tr>
<td style="text-align:center"><code>&amp;&amp;</code></td>
<td style="text-align:center">$\vdots$</td>
</tr>
<tr>
<td style="text-align:center"><code>&#124;&#124;</code></td>
<td style="text-align:center">$\vdots$</td>
</tr>
<tr>
<td style="text-align:center"><code>? :</code></td>
<td style="text-align:center">最低优先级</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>例如：<code>A + B &amp; C + D</code> 就表示 <code>(A + B) &amp; (C + D)</code>，而不是 <code>A + (B &amp; C) + D</code>。</p>
</blockquote>
<h2 id="二进制数值"><a href="#二进制数值" class="headerlink" title="二进制数值"></a>二进制数值</h2><p>在讨论操作数之前，先来看看二进制数中如何表示有符号数和无符号数。</p>
<p>例如，在一个 6 位二进制整形变量中，</p>
<ul>
<li>无符号数能表示的范围是：<code>0~63</code>；</li>
<li>有符号数采用二进制补码（Two’s complement）方式，能表示的范围是：<code>-32～31</code>。其中二进制的最高位表示符号，最高位为 1 表示该数是负数，为 0 表示该数是正数。</li>
</ul>
<p>这里对具体的编码方式不过多介绍，但学过数字电路的同学必须掌握二进制中无符号数和有符号数的表示方法，以及计算的机制。</p>
<h2 id="操作数"><a href="#操作数" class="headerlink" title="操作数"></a>操作数</h2><p>在 Verilog 语言中，操作数可以是如下几种：</p>
<ul>
<li>常数；</li>
<li>参数；</li>
<li>线网；</li>
<li>寄存器；</li>
<li>向量的位选择;</li>
<li>向量的部分选择；</li>
<li>存储器单元；</li>
<li>系统函数或用户自定义函数调用的返回值。</li>
</ul>
<p>在选择操作数时，需要用户尤其注意的是操作数的极性。通常在 Verilog 中，无符号数用以下3种形式存在：</p>
<ul>
<li>线网变量；</li>
<li>一般寄存器变量；</li>
<li>基数格式表示形式的整数常数。</li>
</ul>
<p>而有符号数有：</p>
<ul>
<li>整型寄存器变量；</li>
<li>十进制形式的整型常量。</li>
</ul>
<p>首先讨论常量，如果采用基数格式表示一个数，例如：<code>-4&#39;d12</code>，其二进制表示方式是：<code>1111_1111_1111_1111_1111_1111_1111_0100</code>（<code>1100</code> 的补码），由于基数格式的整数为无符号数，因此<code>-4&#39;d12</code> 的值就是十进制的 <code>429496728</code>。</p>
<p>当采用普通十进制数来表示 <code>-12</code> 的时候，虽然它的二进制表示方式与上面的数相同，但 <code>-12</code> 是一个有符号数，它在运算时就表示十进制的 <code>-12</code>。</p>
<p>这里定义两个变量，一个是无符号的 <code>reg</code> 型，另一个是有符号的整型：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">reg</span> [<span class="number">4</span>:<span class="number">0</span>] Opreg;            <span class="comment">// 一个 5 位的 reg 型，存储无符号数</span></span><br><span class="line"><span class="keyword">integer</span> Opint;              <span class="comment">// 一个 32 位的 integer 型，存储有符号数</span></span><br></pre></td></tr></table></figure>
<p>做如下运算：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">Opreg = -<span class="number">4</span>d&#x27;<span class="number">12</span>/<span class="number">4</span>;           <span class="comment">// Opreg 被赋值 29，(-4d&#x27;12/4)的最低5位</span></span><br><span class="line">Opint = -<span class="number">4</span>d&#x27;<span class="number">12</span>/<span class="number">4</span>;           <span class="comment">// Opint 被赋值为 1073741821，共 32 位</span></span><br><span class="line">Opreg = -<span class="number">12</span>/<span class="number">4</span>;              <span class="comment">// Opreg 被赋值29，(-12/4)的最低5位</span></span><br><span class="line">Opint = -<span class="number">12</span>/<span class="number">4</span>;              <span class="comment">// Opint 被赋值为 -3，采用 32 位的二进制补码表示方式</span></span><br></pre></td></tr></table></figure>
<p>通过以上的计算结果可以看出，无符号数和有符号数的算术运算非常不同，用户在设计常量和变量并用它们计算的时候，一定要搞清楚它们中哪些表示有符号数，哪些表示无符号数，这很重要。</p>
<h1 id="系统任务和系统函数"><a href="#系统任务和系统函数" class="headerlink" title="系统任务和系统函数"></a>系统任务和系统函数</h1><p>在 Verilog 语中，预先定义了一些任务和函数，用于完成一些特殊的功能，它们被称为系统任务和系统函数。Verilog 能提供的系统任务和系统函数类型如下：</p>
<ul>
<li>显示任务（display task）；</li>
<li>文件输人/输出任务（file I/O task）；</li>
<li>时间标度任务（timescale task）；</li>
<li>拟控制任务（simulation control task）；</li>
<li>时序验证任务（timing check task）；</li>
<li>PLA建模任务（PLA modeling task）；</li>
<li>机建模任务（stochastic modeling task）；</li>
<li>实数变换函数（conversion functions for real）；</li>
<li>概率分布数（probabilistic distribution function)。</li>
</ul>
<p>由于 Verilog 的系统任务和函数种类很多，在这里，只重点介绍一些常用的内容，希望通过介绍可以能让大家迅速掌握，灵活使用。相信通过以下的介绍，大家可以举一反三，通过参考 Verilog 的语法文献，迅速查找到需要的系统任务和函数，完成需要的功能。</p>
<h2 id="显示任务"><a href="#显示任务" class="headerlink" title="显示任务"></a>显示任务</h2><p><code>$display</code> 是显示任务，通常用来显示变量值、字符串，以及仿真时间等信息。</p>
<p>在 <a href="#JoshVerilog代码">JoshVerilog 模块</a>中使用了这样的系统任务。</p>
<figure class="highlight verilog"><figcaption><span>Josh.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="built_in">$display</span> (<span class="string">&quot;At time %t-&quot;</span>, <span class="built_in">$time</span>, <span class="string">&quot;eq0 = 1&quot;</span>);     <span class="comment">// 显示时间</span></span><br></pre></td></tr></table></figure>
<p>其中，双引号中的是字符串，<code>％t</code> 是时间格式。<code>$time</code> 是产生模拟时间的系统函数，它的返回值显示在字符串中的 <code>％t</code> 位置。</p>
<p>再如：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$display</span>(<span class="string">&quot;The value of ABC is %d&quot;</span>, ABC);        <span class="comment">// 显示当前 ABC 变量的值</span></span><br></pre></td></tr></table></figure>
<p>其中，<code>%d</code> 表示十进制数。<code>ABC</code> 的值显示在字符串中的 <code>%d</code> 位置。</p>
<h2 id="文件输入出任务"><a href="#文件输入出任务" class="headerlink" title="文件输入出任务"></a>文件输入出任务</h2><p>系统函数 <code>$fopen</code> 用于打开一个文件，并返回一个整数的文件指针。然后，<code>$fdisplay</code> 就可以使用这个文件指针向文件中写人信息。写完后，则可以使用 <code>$fclose</code> 这个系统关闭这个文件。例如：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span> Write_Out_File;                     <span class="comment">// 定义一个文件指针</span></span><br><span class="line">Write_Out_File = <span class="built_in">$fopen</span>(<span class="string">&quot;Write_Out_File.txt&quot;</span>);</span><br><span class="line"><span class="built_in">$fdisplay</span>(Write_Out_File, <span class="string">&quot;@ %h\n%h&quot;</span>, Mpi_addr, Data_in);</span><br><span class="line"><span class="built_in">$fclose</span>(Write_Out_File);</span><br></pre></td></tr></table></figure>
<p>以上的语法，将 <code>Mpi_addr</code> 和 <code>Data_in</code> 分别显示在 <code>@ %h\n%h</code> 中两个 <code>%h</code> 的位置，写入 <code>Write_Out_File</code> 指针所指的文件 <code>Write_Out_File.txt</code> 中。</p>
<p>用户可以通过 <code>$readmemb</code> 或者 <code>$readmemh</code> 来从文件中读人数据，但是这个文件中的数据格式是一定的。例如：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] DataSource [<span class="number">0</span>:<span class="number">47</span>];</span><br><span class="line"><span class="built_in">$readmemh</span> (<span class="string">&quot;Read_In_File.txt, DataSource);</span></span><br></pre></td></tr></table></figure>
<p>就是将 <code>Read_In_FiIe</code> 文件中数据读人到 <code>DataSource</code> 数组中，然后就可以直接使用。</p>
<p><code>Read_In_File</code> 数据文件的格式，可以参考如下写法：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">@<span class="number">2</span>f</span><br><span class="line"><span class="number">24</span></span><br><span class="line">@<span class="number">2</span>e</span><br><span class="line"><span class="number">81</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>其中，<code>@2f</code> 表示地址，是十六进制；<code>24</code> 表示该地址的数据，以此类推。</p>
<h2 id="其他系统任务和数"><a href="#其他系统任务和数" class="headerlink" title="其他系统任务和数"></a>其他系统任务和数</h2><ol>
<li><p>仿真控制任务</p>
<p> Verilog 中有一些仿真控制任务，例如：<br> <code>$finish</code> 表示使仿真器退出。<br> <code>$stop</code> 使仿真挂起。</p>
</li>
<li><p>时序验证任务和仿真时间函数</p>
<p> Verilog 仿真器也可以检查设计时序，以及返回当前仿真时间，例如：<br> <code>$setup</code> 系统任务用来检查建立时间。<br> <code>$hold</code> 系统任务用来检查保持时间。<br> <code>$time</code> 系统函数用来返回一个64位的模拟时间。</p>
</li>
<li><p>概率分布函数</p>
<p> <code>$random</code> 系统函数可以用来返回一个32位的有符号整型随机数。</p>
</li>
</ol>
<p>需要注意的是，<strong>系统任务/函数只可以在 Verilog 仿真器中运行，仅仅对代码仿真有意义</strong>，综合和布线工具将忽略所有的系统任务和函数。</p>
<p>除了系统任务和系统函数之外，VeriIog还允许用户自己定义任务和函数。关于自定义的任务和函数的特点及使用方法，请参考后续的相关内容。</p>
<hr>
<p>在本篇笔记中，以一个实例为出发点，系统介绍了 Verilog 的基本语法，相信能为大家深入学习 Verilog 语言打下坚实的基础。</p>
]]></content>
      <categories>
        <category>Verilog</category>
        <category>Josh 的学习笔记</category>
        <category>Verilog</category>
        <category>Verilog 语法</category>
      </categories>
      <tags>
        <tag>Verilog</tag>
        <tag>HDL</tag>
        <tag>自顶向下</tag>
        <tag>自底向上</tag>
        <tag>Verilog 语法</tag>
      </tags>
  </entry>
</search>
