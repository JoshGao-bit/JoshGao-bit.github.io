<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>MATLAB 函数 —— rcosdesign</title>
    <url>/posts/5c45edfe.html</url>
    <content><![CDATA[<p><code>rcosdesign</code>：升余弦 FIR 脉冲成型滤波器设计</p>
<h1 id="语法">语法</h1>
<p><code>b = rcosdesign(beta,span,sps)</code> <code>b = rcosdesign(beta,span,sps,shape)</code></p>
<a id="more"></a>
<h1 id="说明">说明</h1>
<p><code>b = rcosdesign(beta,span,sps)</code> 返回系数 <code>b</code>，该系数对应于具有由 <code>beta</code> 指定的衰减因子的平方根升余弦 FIR 滤波器。滤波器有 <code>span</code> 个符号，每个符号包含 <code>sps</code> 个样本。 滤波器的阶次，也即 <code>sps * span</code> 必须是偶数。滤波器的能量为 1。<a href="#Examples-01">举例</a></p>
<p><code>b = rcosdesign(beta,span,sps,shape)</code> 根据 <code>shape</code> 返回不同的滤波器。当 <code>shape</code> 为 <code>sqrt</code> 时，将返回根升余弦滤波器；当 <code>shape</code> 为 <code>normal</code> 时，将返回升余弦 FIR 滤波器。<a href="#Examples-02">举例</a></p>
<h1 id="示例">示例</h1>
<h2 id="设计根升余弦滤波器">设计根升余弦滤波器<span id="Examples-01"></span></h2>
<p>将滚降系数设为 <code>0.25</code>，波器的符号数设为 <code>6</code>，每个符号 <code>4</code> 个采样点。验证 <code>sqrt</code> 是 <code>shape</code> 参数的默认值。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">h <span class="built_in">=</span> rcosdesign(<span class="number">0.25</span>,<span class="number">6</span>,<span class="number">4</span>);</span><br><span class="line">mx <span class="built_in">=</span> max(abs(h-rcosdesign(<span class="number">0.25</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="string">&#x27;sqrt&#x27;</span>)))</span><br></pre></td></tr></table></figure>
<blockquote>
<p><font face="Consolas">mx = 0</font><br></p>
</blockquote>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">fvtool(h,<span class="string">&#x27;Analysis&#x27;</span>,<span class="string">&#x27;impulse&#x27;</span>)</span><br></pre></td></tr></table></figure>
<div data-align="center">
<p><img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-25-matlab-rcosdesign/2020-11-25-matlab-rcosdesign-010-DesignASquareRootRaisedCosineFilterExample-01.png?imageMogr2/thumbnail/!100p|watermark/2/text/QEpvc2ggR2Fv/fontsize/15/dissolve/60/gravity/southeast/dx/5/dy/5"/></p>
</div>
<h2 id="升余弦和根升余弦滤波器的脉冲响应">升余弦和根升余弦滤波器的脉冲响应<span id="Examples-02"></span></h2>
<p>将升余弦滤波器与根升余弦滤波器进行比较。一个理想的（无限长）升余弦脉冲成型滤波器等效于两个级联的理想的根升余弦滤波器。因此，FIR 升余弦滤波器的脉冲响应应类似于与其自身卷积的根升余弦滤波器的脉冲响应。</p>
<p>设计一个衰减为 <code>0.25</code> 的升余弦滤波器。指定滤波器有 <code>4</code> 个符号，每个符号 <code>3</code> 个采样点。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">rf <span class="built_in">=</span> <span class="number">0.25</span>;</span><br><span class="line">span <span class="built_in">=</span> <span class="number">4</span>;</span><br><span class="line">sps <span class="built_in">=</span> <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">h1 <span class="built_in">=</span> rcosdesign(rf,span,sps,<span class="string">&#x27;normal&#x27;</span>);</span><br><span class="line">fvtool(h1,<span class="string">&#x27;impulse&#x27;</span>)</span><br></pre></td></tr></table></figure>
<div data-align="center">
<p><img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-25-matlab-rcosdesign/2020-11-25-matlab-rcosdesign-020-ImpulseResponsesOfNormalAndSquareRootRaisedCosineFiltersExample-01.png?imageMogr2/thumbnail/!100p|watermark/2/text/QEpvc2ggR2Fv/fontsize/15/dissolve/60/gravity/southeast/dx/5/dy/5"/></p>
</div>
<p><strong>升余弦滤波器在 <code>sps</code> 的整数倍处具有零值点</strong>。因此，它满足无码间串扰（ISI）的 Nyquist 准则。但是，根升余弦滤波器没有这样的特性：</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">h2 <span class="built_in">=</span> rcosdesign(rf,span,sps,<span class="string">&#x27;sqrt&#x27;</span>);</span><br><span class="line">fvtool(h2,<span class="string">&#x27;impulse&#x27;</span>)</span><br></pre></td></tr></table></figure>
<div data-align="center">
<p><img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-25-matlab-rcosdesign/2020-11-25-matlab-rcosdesign-030-ImpulseResponsesOfNormalAndSquareRootRaisedCosineFiltersExample-02.png?imageMogr2/thumbnail/!100p|watermark/2/text/QEpvc2ggR2Fv/fontsize/15/dissolve/60/gravity/southeast/dx/5/dy/5"/></p>
</div>
<p>将根升余弦滤波器与自身进行卷积。在最大值处截断脉冲响应，使其长度与 <code>h1</code> 相同。使用最大值将响应归一化。然后，将卷积后的根升余弦滤波器与升余弦滤波器进行比较。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">h3 <span class="built_in">=</span> conv(h2,h2);</span><br><span class="line">p2 <span class="built_in">=</span> ceil(length(h3)/<span class="number">2</span>);</span><br><span class="line">m2 <span class="built_in">=</span> ceil(p2-length(h1)/<span class="number">2</span>);</span><br><span class="line">M2 <span class="built_in">=</span> floor(p2+length(h1)/<span class="number">2</span>);</span><br><span class="line">ct <span class="built_in">=</span> h3(m2:M2);</span><br><span class="line"></span><br><span class="line">stem([h1/max(abs(h1));ct/max(abs(ct))]<span class="string">&#x27;,&#x27;</span>filled<span class="string">&#x27;)</span></span><br><span class="line"><span class="string">xlabel(&#x27;</span>Samples<span class="string">&#x27;)</span></span><br><span class="line"><span class="string">ylabel(&#x27;</span>Normalized amplitude<span class="string">&#x27;)</span></span><br><span class="line"><span class="string">legend(&#x27;</span>h1<span class="string">&#x27;,&#x27;</span>h2 * h2<span class="string">&#x27;)</span></span><br></pre></td></tr></table></figure>
<div data-align="center">
<p><img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-25-matlab-rcosdesign/2020-11-25-matlab-rcosdesign-040-ImpulseResponsesOfNormalAndSquareRootRaisedCosineFiltersExample-03.png?imageMogr2/thumbnail/!100p|watermark/2/text/QEpvc2ggR2Fv/fontsize/15/dissolve/60/gravity/southeast/dx/5/dy/5"/></p>
</div>
<p>卷积响应的长度是有限的，因此根升余弦滤波器与自身进行卷积得到的结果会与升余弦滤波器不一致。增加 <code>span</code> 可以在响应之间获得更紧密的一致性，并更好地符合 Nyquist 准则。</p>
<h2 id="将信号通过升余弦滤波器">将信号通过升余弦滤波器<span id="Examples-03"></span></h2>
<p>本例说明如何将信号通过根升余弦滤波器。</p>
<p>指定滤波器参数。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">rolloff <span class="built_in">=</span> <span class="number">0.25</span>;     <span class="comment">% 滚降因子</span></span><br><span class="line">span <span class="built_in">=</span> <span class="number">6</span>;           <span class="comment">% 滤波器宽度（符号数）</span></span><br><span class="line">sps <span class="built_in">=</span> <span class="number">4</span>;            <span class="comment">% 每个符号的样本数</span></span><br></pre></td></tr></table></figure>
<p>生成根升余弦滤波器的系数。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">b <span class="built_in">=</span> rcosdesign(rolloff, span, sps);</span><br></pre></td></tr></table></figure>
<p>生成双极性数据向量。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">d <span class="built_in">=</span> <span class="number">2</span>*randi([<span class="number">0</span> <span class="number">1</span>], <span class="number">100</span>, <span class="number">1</span>) - <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>上采样并对数据进行滤波以实现脉冲成型。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">x <span class="built_in">=</span> upfirdn(d, b, sps);</span><br></pre></td></tr></table></figure>
<p>添加噪声。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">r <span class="built_in">=</span> x + randn(size(x))*<span class="number">0.01</span>;</span><br></pre></td></tr></table></figure>
<p>对接收到的信号进行滤波和下采样以进行匹配滤波。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">y <span class="built_in">=</span> upfirdn(r, b, <span class="number">1</span>, sps);</span><br></pre></td></tr></table></figure>
<p>有关如何使用根升余弦滤波器对信号进行插值和抽取的信息，请参见使<a href="https://ww2.mathworks.cn/help/comm/ug/interpolate-and-decimate-using-rrc-filter.html">用 RRC 滤波器进行插值和抽取</a>（Communications Toolbox）。</p>
<h1 id="输入参数">输入参数</h1>
<h2 id="beta---滚降系数"><code>beta</code> - 滚降系数</h2>
<p>滚降系数，指定为不大于 <code>1</code> 的<strong>实非负标量</strong>。滚降系数决定滤波器的多余带宽。滚降系数为 <code>0</code> 时为矩形滤波器（brick-wall filter），滚降因子为 <code>1</code> 时为纯升余弦滤波器。</p>
<p><strong>数据类型</strong>：<code>double</code> | <code>single</code></p>
<h2 id="span---符号数"><code>span</code> - 符号数</h2>
<p>符号数，指定为<strong>正整数标量</strong>。</p>
<p><strong>数据类型</strong>：<code>double</code> | <code>single</code></p>
<h2 id="sps---每个符号的样本数"><code>sps</code> - 每个符号的样本数</h2>
<p>每个符号的样本数（上采样因子），指定为<strong>正整数标量</strong>。</p>
<p><strong>数据类型</strong>：<code>double</code> | <code>single</code></p>
<h2 id="shape---升余弦滤波器的形状"><code>shape</code> - 升余弦滤波器的形状</h2>
<p>升余弦滤波器的形状，指定为 <code>normal</code> 或 <code>sqrt</code>。</p>
<h1 id="输出参数">输出参数</h1>
<h2 id="b---fir-滤波器系数"><code>b</code> - FIR 滤波器系数</h2>
<p>升余弦滤波器的系数，以<strong>列向量</strong>的形式返回。</p>
<p><strong>数据类型</strong>：<code>double</code> | <code>single</code></p>
<h1 id="提示">提示</h1>
<ul>
<li>如果您拥有 Communications Toolbox™ 软件的许可证，则可以执行具有流传输行为的多速率升余弦滤波。为此，请使用 System object™ 滤波器——<code>comm.RaisedCosineTransmitFilter</code> 和 <code>comm.RaisedCosineReceiveFilter</code>。</li>
</ul>
<h1 id="参考">参考</h1>
<p>[1] Tranter, William H., K. Sam Shanmugan, Theodore S. Rappaport, and Kurt L. Kosbar. <em>Principles of Communication Systems Simulation with Wireless Applications.</em> Upper Saddle River, NJ: Prentice Hall, 2004.</p>
<h1 id="扩展功能">扩展功能</h1>
<h2 id="cc-代码生成">C/C++ 代码生成</h2>
<blockquote>
<p>使用 MATLAB® Coder™ 生成 C 代码和 C++ 代码。</p>
<blockquote>
<p>用法说明和限制：</p>
<p>所有输入必须为常数。 如果表达式或变量的值不变，则也允许使用。</p>
</blockquote>
</blockquote>
<h1 id="另请参阅">另请参阅</h1>
<p><a href="https://ww2.mathworks.cn/help/signal/ref/gaussdesign.html"><code>gaussdesign</code></a></p>
<h2 id="主题">主题</h2>
<p><a href="https://ww2.mathworks.cn/help/comm/ug/interpolate-and-decimate-using-rrc-filter.html">用 RRC 滤波器进行插值和抽取</a>（Communications Toolbox）</p>
<hr />
<p>在 R2013b 中推出</p>
<hr />
<p>原文参考：<a href="https://ww2.mathworks.cn/help/signal/ref/rcosdesign.html">https://ww2.mathworks.cn/help/signal/ref/rcosdesign.html</a></p>
]]></content>
      <categories>
        <category>MATLAB</category>
        <category>翻译</category>
        <category>帮助文档</category>
      </categories>
      <tags>
        <tag>MATLAB</tag>
        <tag>翻译</tag>
        <tag>成型滤波器</tag>
        <tag>滤波器</tag>
      </tags>
  </entry>
  <entry>
    <title>MATLAB 函数 —— gaussdesign</title>
    <url>/posts/a2967b00.html</url>
    <content><![CDATA[<p><code>gaussdesign</code>：高斯 FIR 脉冲成型滤波器设计</p>
<h1 id="语法">语法</h1>
<p><code>h = gaussdesign(bt,span,sps)</code></p>
<a id="more"></a>
<h1 id="说明">说明</h1>
<p><code>h = gaussdesign(bt,span,sps)</code> 设计一个低通 FIR 高斯脉冲成型滤波器，并返回滤波器系数向量 <code>h</code>。滤波器有 <code>span</code> 个符号，每个符号包含 <code>sps</code> 个样本。滤波器的阶次，也即 <code>sps * span</code> 必须是偶数。<a href="#Examples-01">举例</a></p>
<h1 id="示例">示例</h1>
<h2 id="gsm-gmsk-数字蜂窝通信系统的高斯滤波器">GSM GMSK 数字蜂窝通信系统的高斯滤波器<span id="Examples-01"></span></h2>
<p>指定用于传输比特位的调制是高斯最小频移键控（GMSK）脉冲。此脉冲的 3-dB 带宽等于比特率的 <code>0.3</code> 倍，滤波器的符号数为 <code>4</code>，每个符号 <code>8</code> 个采样点。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">bt <span class="built_in">=</span> <span class="number">0.3</span>;</span><br><span class="line">span <span class="built_in">=</span> <span class="number">4</span>;</span><br><span class="line">sps <span class="built_in">=</span> <span class="number">8</span>;</span><br><span class="line">h <span class="built_in">=</span> gaussdesign(bt,span,sps);</span><br><span class="line">fvtool(h,<span class="string">&#x27;impulse&#x27;</span>)</span><br></pre></td></tr></table></figure>
<div data-align="center">
<p><img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-26-matlab-gaussdesign/2020-11-26-matlab-gaussdesign-010-GaussianFilterForAGSMGMSKDigitalCellularCommunicationSysExample-01.png?imageMogr2/thumbnail/!100p|watermark/2/text/QEpvc2ggR2Fv/fontsize/15/dissolve/60/gravity/southeast/dx/5/dy/5"/></p>
</div>
<h1 id="输入参数">输入参数</h1>
<h2 id="bt---3-db带宽符号时间积"><code>bt</code> - 3-dB带宽符号时间积</h2>
<p>3-dB 单边带带宽（以 Hz 为单位）和符号时间（以秒为单位）的乘积，指定为<strong>正实标量</strong>。较小的 <code>bt</code> 值会产生较大的脉冲宽度。</p>
<p><strong>数据类型</strong>：<code>double</code> | <code>single</code></p>
<h2 id="span---符号数"><code>span</code> - 符号数</h2>
<p>符号数，指定为<strong>正整数标量</strong>（默认为 3）。</p>
<p><strong>数据类型</strong>：<code>double</code> | <code>single</code></p>
<h2 id="sps---每个符号的样本数"><code>sps</code> - 每个符号的样本数</h2>
<p>每个符号周期的样本数（上采样因子），指定为<strong>正整数标量</strong>（默认为 2）。</p>
<p><strong>数据类型</strong>：<code>double</code> | <code>single</code></p>
<h1 id="输出参数">输出参数</h1>
<h2 id="h---fir-滤波器系数"><code>h</code> - FIR 滤波器系数</h2>
<p>高斯脉冲成型滤波器的 FIR 系数，以<strong>行向量</strong>的形式返回。系数已被归一化，因此标称通带增益始终为 1。</p>
<p><strong>数据类型</strong>：<code>double</code> | <code>single</code></p>
<h1 id="参考">参考</h1>
<p>[1] Krishnapura, N., S. Pavan, C. Mathiazhagan, and B. Ramamurthi. “A baseband pulse shaping filter for Gaussian minimum shift keying.” <em>Proceedings of the 1998 IEEE International Symposium on Circuits and Systems</em>. Vol. 1, 1998, pp. 249–252.</p>
<p>[2] Rappaport, Theodore S. <em>Wireless Communications: Principles and Practice.</em> 2nd Ed. Upper Saddle River, NJ: Prentice Hall, 2002.</p>
<h1 id="另请参阅">另请参阅</h1>
<p><a href="https://ww2.mathworks.cn/help/signal/ref/rcosdesign.html"><code>rcosdesign</code></a></p>
<hr />
<p>在 R2013b 中推出</p>
<hr />
<p>原文参考：<a href="https://ww2.mathworks.cn/help/signal/ref/gaussdesign.html">https://ww2.mathworks.cn/help/signal/ref/gaussdesign.html</a></p>
]]></content>
      <categories>
        <category>MATLAB</category>
        <category>翻译</category>
        <category>帮助文档</category>
      </categories>
      <tags>
        <tag>MATLAB</tag>
        <tag>翻译</tag>
        <tag>成型滤波器</tag>
        <tag>滤波器</tag>
      </tags>
  </entry>
  <entry>
    <title>MATLAB 函数 —— upsample（Signal Processing Toolbox）</title>
    <url>/posts/3a606c9c.html</url>
    <content><![CDATA[<p><code>upsample</code>：将采样率提高整数倍</p>
<h1 id="语法">语法</h1>
<p><code>y = upsample(x,n)</code> <code>y = upsample(x,n,phase)</code></p>
<a id="more"></a>
<h1 id="说明">说明</h1>
<p><code>y = upsample(x,n)</code> 通过在样本之间插入 <code>n - 1</code>个零来增加 <code>x</code> 的采样率。如果 <code>x</code> 是矩阵，则该函数将每一列视为单独的序列。<a href="#Examples-01">举例</a></p>
<p><code>y = upsample(x,n,phase)</code> 指定未采样序列所偏移的样本数。</p>
<h1 id="示例">示例</h1>
<h2 id="提高采样率">提高采样率<span id="Examples-01"></span></h2>
<p>将序列的采样率提高 <code>3</code> 倍。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">x <span class="built_in">=</span> [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>];</span><br><span class="line">y <span class="built_in">=</span> upsample(x,<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">y &#x3D; 1×12</span><br><span class="line"></span><br><span class="line">    1     0     0     2     0     0     3     0     0     4     0     0</span><br></pre></td></tr></table></figure>
<p>将序列的采样率增加 <code>3</code> 倍，并将相位偏移增加 <code>2</code>。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">x <span class="built_in">=</span> [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>];</span><br><span class="line">y <span class="built_in">=</span> upsample(x,<span class="number">3</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">y &#x3D; 1×12</span><br><span class="line"></span><br><span class="line">    0     0     1     0     0     2     0     0     3     0     0     4     0</span><br></pre></td></tr></table></figure>
<p>将矩阵的采样率提高3倍。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">x <span class="built_in">=</span> [<span class="number">1</span> <span class="number">2</span>;</span><br><span class="line">     <span class="number">3</span> <span class="number">4</span>;</span><br><span class="line">     <span class="number">5</span> <span class="number">6</span>];</span><br><span class="line">y <span class="built_in">=</span> upsample(x,<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">y &#x3D; 9×2</span><br><span class="line"></span><br><span class="line">    1     2</span><br><span class="line">    0     0</span><br><span class="line">    0     0</span><br><span class="line">    3     4</span><br><span class="line">    0     0</span><br><span class="line">    0     0</span><br><span class="line">    5     6</span><br><span class="line">    0     0</span><br><span class="line">    0     0</span><br></pre></td></tr></table></figure>
<h1 id="输入参数">输入参数</h1>
<h2 id="x---输入数组"><code>x</code> - 输入数组</h2>
<p>输入数组，指定为<strong>向量</strong>或<strong>矩阵</strong>。如果 <code>x</code> 是矩阵，该函数会将不同列向量视为独立的通道。</p>
<p><strong>举例</strong>：<code>cos(pi/4*(0:159)) + randn(1,160)</code> 指定加有高斯白噪声的正弦曲线。</p>
<p><strong>举例</strong>：<code>cos(pi./[4;2]*(0:159))' + randn(160,2)</code> 指定一个两通道的正弦波。</p>
<h2 id="n---上采样因子"><code>n</code> - 上采样因子</h2>
<p>上采样因子，指定为<strong>正整数</strong>。</p>
<p><strong>数据类型</strong>：<code>single</code> | <code>double</code></p>
<h2 id="phase---偏移量"><code>phase</code> - 偏移量</h2>
<p>偏移量，指定为从 <code>0</code> 到 <code>n - 1</code> 的<strong>正整数</strong>。默认为 <code>0</code>。</p>
<p><strong>数据类型</strong>：<code>single</code> | <code>double</code></p>
<h1 id="输出参数">输出参数</h1>
<h2 id="y---上采样数组"><code>y</code> - 上采样数组</h2>
<p>上采样数组，以<strong>向量</strong>或<strong>矩阵</strong>的形式返回。<code>y</code> 有 <code>x × n</code> 个样本。</p>
<h1 id="扩展功能">扩展功能</h1>
<h2 id="cc-代码生成">C/C++ 代码生成</h2>
<blockquote>
<p>使用 MATLAB® Coder™ 生成 C 代码和 C++ 代码。</p>
</blockquote>
<h1 id="另请参阅">另请参阅</h1>
<p><a href="https://ww2.mathworks.cn/help/signal/ref/decimate.html"><code>decimate</code></a> | <a href="https://ww2.mathworks.cn/help/signal/ref/downsample.html"><code>downsample</code></a> | <a href="https://ww2.mathworks.cn/help/signal/ref/interp.html"><code>interp</code></a> | <a href="https://ww2.mathworks.cn/help/matlab/ref/interp1.html"><code>interp1</code></a> | <a href="https://ww2.mathworks.cn/help/signal/ref/resample.html"><code>resample</code></a> | <a href="https://ww2.mathworks.cn/help/matlab/ref/spline.html"><code>spline</code></a> | <a href="https://ww2.mathworks.cn/help/signal/ref/upfirdn.html"><code>upfirdn</code></a></p>
<table>
<colgroup>
<col style="width: 100%" />
</colgroup>
<tbody>
<tr class="odd">
<td style="text-align: left;">在 R2006a 之前推出</td>
</tr>
</tbody>
</table>
<p>原文参考：<a href="https://ww2.mathworks.cn/help/signal/ref/upsample.html">https://ww2.mathworks.cn/help/signal/ref/upsample.html</a></p>
]]></content>
      <categories>
        <category>MATLAB</category>
        <category>翻译</category>
        <category>帮助文档</category>
      </categories>
      <tags>
        <tag>MATLAB</tag>
        <tag>翻译</tag>
        <tag>上采样</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo NexT 主题不蒜子相关问题汇总</title>
    <url>/posts/e96c9b26.html</url>
    <content><![CDATA[<h1 id="什么是不蒜子">什么是不蒜子</h1>
<p><a href="https://busuanzi.ibruce.info/">不蒜子</a>是 <a href="http://ibruce.info/">Bruce</a> 开发的一款轻量级的网页计数器，可以将网站访问计数直接显示在网页上。</p>
<h1 id="启用不蒜子">启用不蒜子</h1>
<p>NexT 预置了不蒜子提供的网页计数功能。只需要在配置文件中启用即可。</p>
<figure class="highlight yaml"><figcaption><span>next/_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># Show Views / Visitors of the website / page with busuanzi.</span></span><br><span class="line"><span class="comment"># Get more information on http://ibruce.info/2015/04/04/busuanzi</span></span><br><span class="line"><span class="attr">busuanzi_count:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span>                          <span class="comment"># 启用不蒜子</span></span><br><span class="line">  <span class="attr">total_visitors:</span> <span class="literal">true</span>                  <span class="comment"># 网站总访客数</span></span><br><span class="line">  <span class="attr">total_visitors_icon:</span> <span class="string">fa</span> <span class="string">fa-user</span></span><br><span class="line">  <span class="attr">total_views:</span> <span class="literal">true</span>                     <span class="comment"># 网站总浏览数</span></span><br><span class="line">  <span class="attr">total_views_icon:</span> <span class="string">fa</span> <span class="string">fa-eye</span></span><br><span class="line">  <span class="attr">post_views:</span> <span class="literal">true</span>                      <span class="comment"># 文章浏览数</span></span><br><span class="line">  <span class="attr">post_views_icon:</span> <span class="string">fa</span> <span class="string">fa-eye</span></span><br></pre></td></tr></table></figure>
<h1 id="不蒜子和-live2d-冲突的问题">不蒜子和 Live2D 冲突的问题</h1>
<a id="more"></a>
<blockquote>
<p>Hexo 版本：5.2.0 NexT 版本：8.0.2 不蒜子版本: 2.3</p>
</blockquote>
<h2 id="问题描述">问题描述</h2>
<p>添加 Live2D 前的不蒜子显示情况如下。</p>
<div data-align="center">
<p><img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-27-hexo-next-busuanzi-issues/2020-11-27-hexo-next-busuanzi-issues-010-Live2D-01.png?imageMogr2/thumbnail/!100p|watermark/2/text/QEpvc2ggR2Fv/fontsize/15/dissolve/60/gravity/southeast/dx/5/dy/5"/></p>
</div>
<div data-align="center">
<p><img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-27-hexo-next-busuanzi-issues/2020-11-27-hexo-next-busuanzi-issues-020-Live2D-02.png?imageMogr2/thumbnail/!100p|watermark/2/text/QEpvc2ggR2Fv/fontsize/15/dissolve/60/gravity/southeast/dx/5/dy/5"/></p>
</div>
<p>添加 Live2D 后，不蒜子在页面中不显示。</p>
<div data-align="center">
<p><img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-27-hexo-next-busuanzi-issues/2020-11-27-hexo-next-busuanzi-issues-030-Live2D-03.png?imageMogr2/thumbnail/!100p|watermark/2/text/QEpvc2ggR2Fv/fontsize/15/dissolve/60/gravity/southeast/dx/5/dy/5"/></p>
</div>
<div data-align="center">
<p><img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-27-hexo-next-busuanzi-issues/2020-11-27-hexo-next-busuanzi-issues-040-Live2D-04.png?imageMogr2/thumbnail/!100p|watermark/2/text/QEpvc2ggR2Fv/fontsize/15/dissolve/60/gravity/southeast/dx/5/dy/5"/></p>
</div>
<h2 id="问题原因">问题原因</h2>
<p>经查，添加 Live2D 后网页的不蒜子部分源码的 <code>style</code> 从 <code>"display: inline;"</code> 替换为了 <code>"display: none;"</code>。</p>
<figure class="highlight html"><figcaption><span>不蒜子不正常显示的网页源码</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item&quot;</span> <span class="attr">title</span>=<span class="string">&quot;阅读次数&quot;</span> <span class="attr">id</span>=<span class="string">&quot;busuanzi_container_page_pv&quot;</span> <span class="attr">style</span>=<span class="string">&quot;display: none;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item-icon&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fa fa-eye&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item-text&quot;</span>&gt;</span> 阅读次数：<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;busuanzi_value_page_pv&quot;</span>&gt;</span>19<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight html"><figcaption><span>不蒜子正常显示的网页源码</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item&quot;</span> <span class="attr">title</span>=<span class="string">&quot;阅读次数&quot;</span> <span class="attr">id</span>=<span class="string">&quot;busuanzi_container_page_pv&quot;</span> <span class="attr">style</span>=<span class="string">&quot;display: inline;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item-icon&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&quot;fa fa-eye&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item-text&quot;</span>&gt;</span> 阅读次数：<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;busuanzi_value_page_pv&quot;</span>&gt;</span>18<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="解决方法">解决方法</h2>
<p>在网页生成引擎中修改代码，去掉不蒜子部分的 <code>id</code> 和 <code>style</code> 属性，重新生成网页即可解决该问题。若将 <code>class</code> 属性一并删除，会导不蒜子部分和前面的其他显示部分缺少分隔符，如下图。</p>
<div data-align="center">
<p><img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-27-hexo-next-busuanzi-issues/2020-11-27-hexo-next-busuanzi-issues-050-Delimeter-01.png?imageMogr2/thumbnail/!100p|watermark/2/text/QEpvc2ggR2Fv/fontsize/15/dissolve/60/gravity/southeast/dx/5/dy/5"/></p>
</div>
<p>具体需要修改两个文件，<code>next/layout/_third-party/statistics/busuanzi-counter.swig</code> 中修改的是网页页脚部分的不蒜子显示，<code>next/layout/_macro/post.swig</code> 中修改的博客文章阅览数的不蒜子显示。</p>
<figure class="highlight html"><figcaption><span>next/layout/_third-party/statistics/busuanzi-counter.swig</span></figcaption><table><tr><td class="code"><pre><span class="line">&#123;%- if theme.busuanzi_count.total_visitors %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item&quot;</span> <span class="attr">id</span>=<span class="string">&quot;busuanzi_container_site_uv&quot;</span> <span class="attr">style</span>=<span class="string">&quot;display: none;&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">&#123;%- endif %&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line"></span><br><span class="line">&#123;%- if theme.busuanzi_count.total_views %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item&quot;</span> <span class="attr">id</span>=<span class="string">&quot;busuanzi_container_site_pv&quot;</span> <span class="attr">style</span>=<span class="string">&quot;display: none;&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">&#123;%- endif %&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight html"><figcaption><span>next/layout/_macro/post.swig</span></figcaption><table><tr><td class="code"><pre><span class="line">&#123;%- if not is_index and theme.busuanzi_count.enable and theme.busuanzi_count.post_views %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;post-meta-item&quot;</span> <span class="attr">title</span>=<span class="string">&quot;&#123;&#123; __(&#x27;post.views&#x27;) &#125;&#125;&quot;</span> <span class="attr">id</span>=<span class="string">&quot;busuanzi_container_page_pv&quot;</span> <span class="attr">style</span>=<span class="string">&quot;display: none;&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">&#123;%- endif %&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Blog</category>
        <category>Hexo</category>
        <category>Next</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title>Josh 的学习笔记之 Verilog（Part 1 —— 初识 HDL 设计方法）</title>
    <url>/posts/460433dd.html</url>
    <content><![CDATA[<p>本文阐述了 HDL 语言/设计方法的基本概念。主要介绍了数字系统建模方法的演变，引入了 HDL 语言的基本概念，对 Verilog HDL 和 VHDL、Verilog HDL 和 C 的联系与区别进行了说明，在最后引入了 HDL 的设计和验证流程，并对各个流程进行了简单介绍。</p>
<h1 id="设计方法的变迁">1. 设计方法的变迁<a name="01"></a></h1>
<p>随着微电子设计技术与工艺的发展，数字集成电路从电子管、晶体管、中小规模集成电路、超大规模集成电路（Very Large Scale Integrated Circuit, VLSIC）逐步发展到今天的专用集成电路（Application Specific Integrated Circuit, ASIC），愈发数字化的产品如计算机、手机、数字电视等都运用了复杂的专用数字集成电路。数字逻辑器件从简单的逻辑门到复杂的 SoC，种类繁多，提供了对复杂系统的灵活支撑。</p>
<a id="more"></a>
<p>随着数字电路系统的不断发展，系统的逻辑复杂度与规模日益增加，数字系统的设计方法也随之不断演进。早期简单的门逻辑设计阶段，EDA 工具应用范围十分有限，工程师们习惯于使用<strong><span class="label default">卡诺图</span></strong>简化设计，然后通过面包板等实验系统验证设计；系统相对复杂后，工程师们借助 EDA 工具通过原理图描述数字系统。</p>
<div class="note default">
            <p>原理图由元件库中的元件构成，使用 EDA（Electronic Design Automation，电子设计自动化）工具可以对原理图进行仿真并分析其性能。</p>
          </div>
<p>当数字系统发展到 ASIC 与 PLD（Programmable Logic Device，可编程逻辑器件） 设计阶段后，原理图不利于移植、维护费时费力等缺点逐步显现，这时需要抽象度更高、更灵活的设计方式 —— HDL（Hardware Description Language，硬件描述语言）。</p>
<p>使用 HDL 语言，可以从算法、系统级（System Level）、功能模块级（Functional Model Level）、行为级（Behavioral Level）、寄存器传输级（RTL, Register Transfer Level）、门级（Gate Level）到开关级（Switch Level）等不同层次描述数字电路系统，然后通过 EDA 工具综合、仿真并实现该系统。可以说 HDL 语言的出现是数字系统设计方法的一个重大飞跃。</p>
<p>数字电路系统设计方法的另一个重大飞跃是随着 EDA 工具的不断推陈出新发生的。早期 ASIC 和 PLD 设计时，人们需要直接描述 CMOS 的开关电路或门级电路，其设计量庞大，仿真速度也非常慢，像当今系统门数量为千万门级的 FPGA 用开关级或门级方法描述在当时是不可想象的。这时人们就希望能够使用 HDL 直接从更高的层次描述电路，然后使用 EDA 工具自动将高层次的 HDL 电路描述解析到门级，这些将大大节约设计与仿真时间，这个<strong><span class="label default">从高层次的电路描述通过 EDA 工具解析到门级等低层次的电路描述的过程就叫“综合”（Synthesize），或者逻辑综合</span></strong>。</p>
<div class="note default">
            <p>综合工具能将高层次的 HDL 语言、原理图等设计描述翻译成由与、或、非门等基本逻辑单元组成的门级连接（<strong>网表</strong>）并根据设计目标与要求（约束条件）优化所生成的逻辑连接，输出门级网表文件。</p>
          </div>
<p>目前最成熟的综合工具是 RTL 级综合工具，它能将 RTL 级描述翻译并优化为门级网表。综合工具的产生支撑了直接从 RTL 级描述硬件电路，这种从门级描述抽象到 RTL 级描述数字电路是设计方法的又一次伟大飞跃。</p>
<p>从上面描述可以看到 HDL 语言是分层次的，关于上述 HDL 语言设计层次的含义在 <a href="#03">3. HDL 的设计与验证流程</a>小节和 <a href="https://josh-gao.blog.csdn.net/article/details/105262549#5__1023">《Part 3——描述方式和设计层次》的 5. 设计层次</a>小节有详细论述。)</p>
<h1 id="verilog-语言的特点">2. Verilog 语言的特点<a name="02"></a></h1>
<h2 id="verilog-的由来">2.1. Verilog 的由来</h2>
<p>Verilog 是 Verilog HDL 的简称。</p>
<div class="note info">
            <p>Verilog 语言最初于1983年由 Gateway Design Automation 公司开发，于1995年接受为 IEEE 标准。</p>
          </div>
<p>Verilog 语言不仅定义了语法，而且对每个语法结构都清晰定义了仿真语义，从而便于仿真调试。而且 Verilog 从 C 语言继承了很多操作符和语法结构，对初学者而言易学易用。另外 Verilog 语言具有很强的扩展能力，最新的 Verilog 2001 标准<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>大大扩展了 Verilog 的应用灵活性。</p>
<p>另外一个流行的 HDL 语言是 VHDL，其发展初期受到美国国防部支持，并于 1987 年成为 IEEE 标准。VHDL 语言的特点是描述严谨。</p>
<h2 id="verilog-和-vhdl">2.2. Verilog 和 VHDL</h2>
<p>Verilog 和 VHDL 作为最为流行的 HDL 语言，从设计能力上而言都能胜任数字电路系统的设计任务。</p>
<p>VHDL 最初用作文档来描述数字硬件的行为，因此其<strong>描述性和抽象层次更高</strong>。也就是说，VHDL 更适合描述更高层次（如行为级、系统级等）的硬件电路。</p>
<p>Verilog 最初是为了更简洁有效地描述数字硬件电路和仿真而设计的，它的许多关键字与语法集成了 C 语言的体系，因此易学易懂，接受度很广。</p>
<p>前面已经提到最流行的 HDL 语言是 Verilog 和 VHDL。在其基础上发展出了许多抽象程度更高的硬件描述语言，如 SystemVerilog、Superlog、SystemC、CoWare C，这些高级 HDL 语言的语法结枃更加丰富，更适合做系统级、功能级等高层次的设计描述和仿真。</p>
<h2 id="verilog-和-c">2.3. Verilog 和 C</h2>
<p>Verilog 语言是根据 C 语言发明而来的，因此 Verilog 具备了 C 语言的简洁易用的特点。Verilog 从 C 语言中借鉴了许多语法，例如预编译指令和一些高级编程语言结构。</p>
<ol type="1">
<li><p>C 语言与 Verilog 的最大区别</p>
<p>C 语言与 Verilog 的最大区别在于 C 缺乏硬件描述的 3 个基本概念：</p>
<ul>
<li><p><strong><span class="label primary">互连（connectivity）</span></strong>：硬件系统中，互连是非常重要的组成部分，而在 C 语言中并没有直接可以用来表示模块间互连的变量；而 Verilog 的 <code>wire</code> 型变量配合一些驱动结构能有效地描述网线的互连。</p></li>
<li><p><strong><span class="label primary">并发（concurrency）</span></strong>：C 语言天生是<strong>串行</strong>的，不能描述硬件之间并发的特性，C 语言编译后，其机器指令在 CPU 的高速缓冲队列中基本是顺序执行；而 Verilog 可以有效地描述并行的硬件系统，硬件系统比软件系统速度快、实时性高的一个重要原因就是硬件系统中<strong>各个单元的运算是独立的，信号流是并行的</strong>。</p></li>
<li><p><strong><span class="label primary">时间（time）</span></strong>：C 程序运行的时候，没有一个严格的时间概念，程序运行的时间长短取决于处理器本身的性能；而 Verilog 语言本身定义了绝对和相对的时间度量，在仿真时可以通过时间度量与周期关系描述信号直接的时间关系。</p></li>
</ul></li>
<li><p>HDL 语言的本质</p>
<p>硬件描述语言（HDL）同软件语言（如 C、C++ 等）是有本质区别的。Verilog 作为硬件描述语言，<strong>它的本质作用在于描述硬件</strong>。Verilog 虽然采用了 C 语言形式，但是它的最终描述结果是芯片内部的实际电路。所以评判一段 HDL 代码优劣的最终标准是其描述并实现的硬件电路的性能（包括面积和速度两个方面）。评价一个设计的代码水平较高，仅仅是说这个设计由硬件向 HDL 代码这种表现形式转换得更流畅、合理。而一个设计的最终性能更大程度上取决于设计工程师所构想的硬件实现方案的效率以及合理性。</p>
<p><div class="note warning">
            <p>初学者，特别是由软件转行的初学者，片面追求代码的整洁、简短，这是错误的，是与评价 HDL 的标准背道而驰的。正确的编写代码的方法是，首先要做到对所需实现的硬件电路“胸有成竹”，对该部分硬件的结构与连接十分清晰，然后再用适当的 HDL 语句表达出来即可。</p>
          </div></p></li>
<li><p>Verilog 与 C 的结合</p>
<p>Verilog 毕竟是硬件描述语言，在抽象层次上比 C 语言要差一些，语法不如 C 灵活，例如文件输入和输出方面，Verilog 的功能显然不如 C。为了克服 Verilog 高级抽象的缺陷，Verilog 的设计者们发明了 PLI。PLI 可以在仿真器中将 C 语言的程序和 Verilog 的程序互相通信，或者在 Verilog 中调用 C 语言的函数库，这样就大大扩展了 Verilog 语言的灵活性和高层次抽象的能力。开发时，一方面，硬件设计者使用 Verilog 进行硬件建模；另一方面，验证工程师却常常使用 C 来编写测试向量，然后通过 Verilog 的 PLI 将 Verilog 和 C 联系起来。这样，C 语言就很好地弥补了 Verilog 高层次建模的缺陷。</p></li>
</ol>
<h1 id="hdl-的设计与验证流程">3. HDL 的设计与验证流程<a name="03"></a></h1>
<p>HDL 的基本功能就是有效地描述并仿真硬件系统。在此部分，抛开具体的 PLD 或 ASIC 设计流程，从 HDL 语言层次入手，分析典型的 HDL 设计与验证流程。基于 HDL 的设计、仿真流程如下图所示。图中，虚线框表示的步骤可以根据项目的复杂度省略，而实线框表示的步骤为必须执行的步骤。</p>
<div data-align="center">
<p><img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-27-josh-verilog-part-1/2020-11-27-josh-verilog-part-1-010-DesignSimulationFlowChartBasedonHDL.png!800px"/></p>
</div>
<p>下面对一些关键设计步骤与概念进行展开。</p>
<h2 id="系统与功能模块定义系统与功能模块级">3.1. 系统与功能模块定义（系统与功能模块级）</h2>
<p>在大型系统的设计与实现中，首先要进行详细的系统规划和描述，此时 HDL 描述 <strong><span class="label default">侧重于整体系统的划分和实现</span></strong>。对系统级的仿真侧重于对整个系统的功能和性能指标的考量。功能模块级设计时将系统整体功能划分为可实现的具体功能模块，大致确定模块间的接口，如时钟、读写信号、数据流、控制信号等。在有些情况下，还要根据系统要求，描述每个模块或进程的时序约束。另外在此层次，必须权衡整个系统多种的实现方式的优劣，选出系统性能指标优并且可以高效实现的设计方案。功能模块级仿真主要是考察每个功能的功能和基本时序情况。系统与功能模块级设计与仿真常常要借助于 C 语言和抽象程度较高的 HDL 语言描述，如 SystemC、Coware C、SystemVerilog、Superlog 等。</p>
<h2 id="行为级描述测试激励behavioral-level">3.2. 行为级描述测试激励（Behavioral Level）</h2>
<p>行为级模块描述的最大特点是 <strong><span class="label default">必须明确每个模块间的所有接口和边界</span></strong>。此时模块内部的功能已经明确，模块间的所有接口，顶层的输入、输出信号等在行为级已经被清晰地描述出来。在 PLD 和 ASIC 设计流程中，常用行为级描述方式编写测试激励。延时描述、监视描述等命令都是在编写测试激励过程中常用的行为级语法。行为级描述常用 HDL 语言如 Verilog 和 VHDL 等。</p>
<h2 id="寄存器传输级rtl">3.3. 寄存器传输级（RTL）</h2>
<p>寄存器传输级指不关注寄存器和组合逻辑的细节（如使用了多少逻辑门，逻辑门之间的连接拓扑结构等），<strong><span class="label default">通过描述寄存器到寄存器之间的逻辑功能描述电路</span></strong>的 HDL 层次。RTL 级是比门级更高的抽象层次，一般使用 RTL 级语言描述硬件电路比门级描述电路简单、高效得多。寄存器传输级描述的最大特点是可以直接用综合工具综合门级网表。RTL 设计直接决定着设计的功能和效率。好的 RTL 设计能在满足逻辑功能的前提下，使设计的速度和面积达到一种平衡的优化。RTL 级描述最常用的 HDL 语言是 Verilog 和 VHDL 语言。</p>
<h2 id="对-rtl-级描述进行功能仿真">3.4 对 RTL 级描述进行功能仿真</h2>
<p>一般来说需要对 RTL 级设计进行功能仿真，仿真的目的为 <strong><span class="label default">验证 RTL 级描述是否与设计意图一致</span></strong>。为了提高效率，一般功能仿真的测试激励使用行为级的 HDL 语言描述。</p>
<h2 id="逻辑综合使用-rtl-级-eda-工具">3.5. 逻辑综合（使用 RTL 级 EDA 工具）</h2>
<p>RTL 级综合指 <strong><span class="label default">将 RTL 级 HDL 语言翻译成由与、或、非门等基本逻辑单元组成的门级连接（网表），并根据设计目标与要求（约束条件）优化所生成的逻辑连接，输出门级网表文件</span></strong>。随着综合工具的不断智能化，使用 RTL 级语言描述硬件电路越来越方便，特别是在 PLD（主要指 FPGA 和 CPLD）设计领域，最重要的代码设计层次就是 RTL 级。</p>
<h2 id="门级gate-level">3.6. 门级（Gate Level）</h2>
<p>由于目前 FPGA 设计大多数依靠专业综合工具完成从 RTL 级代码向门级代码的转换，所有设计者直接用 HDL 语言描述门级模型的情况越来越少，高效的综合工具将设计者从复杂繁琐的门级描述中彻底解脱出来。目前直接使用门级描述的场合一般是 ASIC 和 FPGA 设计中 <strong><span class="label default">某些面积或时序要求较高的模块</span></strong>。门级描述的特点是整个设计用逻辑门实现，通过逻辑门的组合显化描述了设计的引脚、功能、时钟周期等所有信息。</p>
<h2 id="综合后门级仿真">3.7. 综合后门级仿真</h2>
<p>综合完成后，如果需要检查综合结果是否与原设计一致，就需要做综合后仿真。在仿真时，把综合生成的标准延时文件反标注到综合仿真模型中去，可估计门延时带来的影响。综合后仿真虽然比功能仿真精确一些，但是<strong>只能估计门延时，不能估计线延时</strong>，仿真结果<strong>与布线后的实际情况还有一定的差距</strong>，并不十分准确。这种仿真的主要目的在于 <strong><span class="label default">检查综合器的综合结果是否与设计输入一致</span></strong>。目前主流综合工具日益成熟，对于一般性设计，如果设计者确信自己表述明确，没有综合歧义发生，则可以省略综合后仿真步骤。<strong>一般情况下，综合后仿真与功能仿真的仿真激励相同</strong>。</p>
<h2 id="布局规划与布局布线">3.8. 布局规划与布局布线</h2>
<p>综合的门级结果最终要映射到目标库（如 ASIC 设计）或目标器件（如 PLD 设计）。ASIC 与 PLD 设计的相关流程在此不深究 。</p>
<h2 id="布局布线后时序仿真与验证">3.9. 布局布线后时序仿真与验证</h2>
<p>将最终布局规划或布局布线的时延信息反标注到设计网表中，所进行的仿真就叫时序仿真或布局规划与布局布线后仿真，简称后仿真。布局规划与布局布线之后生成的仿真时延文件包含的时延信息最全，不仅包含门延时，还包含实际布线延时，所以时序仿真最准确，能较好地反映芯片的实际工作情况。一般来说，建议进行时序仿真步骤，通过时序仿真能检查设计时序与芯片实际运行情况是否一致，确保设计的可靠性和稳定性。时序仿真的主要目的在于发现时序违规（Timing Violation），即不满足时序约束条件或者器件固有时序规则（建立时间、保持时间等）的情况。</p>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>最新的 Verilog HDL标准为 1364-2005。<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
]]></content>
      <categories>
        <category>Verilog</category>
        <category>Verilog 简介</category>
        <category>Josh 的学习笔记</category>
        <category>Verilog</category>
      </categories>
      <tags>
        <tag>Verilog</tag>
        <tag>HDL</tag>
        <tag>硬件描述语言</tag>
        <tag>行为级</tag>
        <tag>RTL</tag>
        <tag>寄存器传输级</tag>
      </tags>
  </entry>
  <entry>
    <title>MATLAB 函数 —— awgn</title>
    <url>/posts/2f6db45b.html</url>
    <content><![CDATA[<p><code>awgn</code>：在信号中添加高斯白斯噪声</p>
<h1 id="语法">语法</h1>
<p><code>out = awgn(in,snr)</code> <code>out = awgn(in,snr,signalpower)</code></p>
<p><code>out = awgn(in,snr,signalpower,randobject)</code> <code>out = awgn(in,snr,signalpower,seed)</code> <code>out = awgn(___,powertype)</code></p>
<a id="more"></a>
<h1 id="说明">说明</h1>
<p><code>out = awgn(in,snr)</code> 将高斯白噪声添加到矢量信号 <code>in</code> 中。此条语句假定 <code>in</code> 的功率为 0 dBW。</p>
<p><code>out = awgn(in,snr,signalpower)</code> 接受以 dBW 为单位的输入信号功率值。要使该函数在添加噪声之前测量 <code>in</code> 的功率，请将 <code>signalpower</code> 指定为 <code>measured</code>。<a href="#Examples-01">举例</a></p>
<p><code>out = awgn(in,snr,signalpower,randobject)</code> 接受满足前述两条语法，外加随机数流对象的输入组合以生成满足正态分布的随机噪声样本。有关产生可重复噪声样本的信息，请参见<a href="#tips">提示</a>。<a href="#Examples-03">举例</a></p>
<p><code>out = awgn(in,snr,signalpower,seed)</code> 指定用于初始化正态随机数生成器的种子值，该种子在添加高斯白噪声到输入信号时使用。有关产生可重复噪声样本的信息，请参见<a href="#tips">提示</a>。</p>
<p><code>out = awgn(___,powertype)</code> 除了前面任何语法中的输入自变量之外，还将可信号和噪声功率类型指定为 <code>dB</code> 或 <code>linear</code>。</p>
<p>有关 SNR 与噪声相对功率的其他度量（例如 <span class="math inline">\(E_\mathrm{S}/N_0\)</span> 和 <span class="math inline">\(E_\mathrm{b}/N_0\)</span>）之间的关系，请参阅 <a href="https://ww2.mathworks.cn/help/comm/ug/awgn-channel.html#a1071501088">AWGN 信道噪声级别</a>。</p>
<h1 id="示例">示例</h1>
<h2 id="将-awgn-添加到锯齿波">将 AWGN 添加到锯齿波<span id="Examples-01"></span></h2>
<p>创建一个锯齿波。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">t <span class="built_in">=</span> (<span class="number">0</span>:<span class="number">0.1</span>:<span class="number">10</span>)<span class="string">&#x27;;</span></span><br><span class="line"><span class="string">x = sawtooth(t);</span></span><br></pre></td></tr></table></figure>
<p>添加高斯白噪声并绘制结果。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">y <span class="built_in">=</span> awgn(x,<span class="number">10</span>,<span class="string">&#x27;measured&#x27;</span>);</span><br><span class="line">plot(t,[x y])</span><br><span class="line">legend(<span class="string">&#x27;Original Signal&#x27;</span>,<span class="string">&#x27;Signal with AWGN&#x27;</span>)</span><br></pre></td></tr></table></figure>
<div data-align="center">
<p><img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-27-matlab-awgn/2020-11-27-matlab-awgn-010-AddAWGNToSawtoothSignalExample-01.png?imageMogr2/thumbnail/!100p|watermark/2/text/QEpvc2ggR2Fv/fontsize/15/dissolve/60/gravity/southeast/dx/5/dy/5"/></p>
</div>
<h2 id="awgn-信道中的常规-qam-调制">AWGN 信道中的常规 QAM 调制<span id="Examples-02"></span></h2>
<p>在存在高斯噪声的情况下，使用非矩形 16 元星座发送和接收数据。绘制噪声星座图，并针对两种不同的信噪比估算误符号率（SER）。</p>
<p>根据电话线调制解调器的 V.29 标准创建一个 16-QAM 星座。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">c <span class="built_in">=</span> [-<span class="number">5</span> -<span class="number">5</span>i <span class="number">5</span> <span class="number">5</span>i -<span class="number">3</span> -<span class="number">3</span>-<span class="number">3</span>i -<span class="number">3</span>i <span class="number">3</span>-<span class="number">3</span>i <span class="number">3</span> <span class="number">3</span>+<span class="number">3</span>i <span class="number">3</span>i -<span class="number">3</span>+<span class="number">3</span>i -<span class="number">1</span> -<span class="number">1</span>i <span class="number">1</span> <span class="number">1</span>i];</span><br><span class="line">M <span class="built_in">=</span> length(c);</span><br></pre></td></tr></table></figure>
<p>生成随机符号。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">data <span class="built_in">=</span> randi([<span class="number">0</span> M-<span class="number">1</span>],<span class="number">2000</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>使用 <code>genqammod</code> 函数调制数据。由于星座图不是矩形，因此必须进行常规 QAM 调制。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">modData <span class="built_in">=</span> genqammod(data,c);</span><br></pre></td></tr></table></figure>
<p>使信号通过具有 20 dB 信噪比（SNR）的 AWGN 信道。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">rxSig <span class="built_in">=</span> awgn(modData,<span class="number">20</span>,<span class="string">&#x27;measured&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>显示接收信号的星座图和参考星座图。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">h <span class="built_in">=</span> scatterplot(rxSig);</span><br><span class="line">hold on</span><br><span class="line">scatterplot(c,[],[],<span class="string">&#x27;r*&#x27;</span>,h)</span><br><span class="line">grid</span><br><span class="line">hold off</span><br></pre></td></tr></table></figure>
<div data-align="center">
<p><img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-27-matlab-awgn/2020-11-27-matlab-awgn-020-GeneralQAMModulationInAnAWGNChannelExample-01.png?imageMogr2/thumbnail/!100p|watermark/2/text/QEpvc2ggR2Fv/fontsize/15/dissolve/60/gravity/southeast/dx/5/dy/5"/></p>
</div>
<p>使用 <code>genqamdemod</code> 函数解调接收到的信号。计算误符号数和误符号率。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">demodData <span class="built_in">=</span> genqamdemod(rxSig,c);</span><br><span class="line">[numErrors,ser] <span class="built_in">=</span> symerr(data,demodData)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">numErrors &#x3D; 1</span><br><span class="line">ser &#x3D; 5.0000e-04</span><br></pre></td></tr></table></figure>
<p>使用具有 10 dB SNR 的 AWGN 信道重复传输和解调过程。计算降低 SNR 后的误符号率。不出所料，当 SNR 降低时，性能会下降。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">rxSig <span class="built_in">=</span> awgn(modData,<span class="number">10</span>,<span class="string">&#x27;measured&#x27;</span>);</span><br><span class="line">demodData <span class="built_in">=</span> genqamdemod(rxSig,c);</span><br><span class="line">[numErrors,ser] <span class="built_in">=</span> symerr(data,demodData)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">numErrors &#x3D; 462</span><br><span class="line">ser &#x3D; 0.2310</span><br></pre></td></tr></table></figure>
<h2 id="用-randstream-产生可重复的-awgn">用 RandStream 产生可重复的 AWGN<span id="Examples-03"></span></h2>
<p>使用 <a href="https://ww2.mathworks.cn/help/matlab/ref/randstream.html"><code>RandStream</code></a> 和 <a href="https://ww2.mathworks.cn/help/matlab/ref/randstream.reset.html"><code>reset</code></a> 对象函数生成高斯白噪声相加的结果。</p>
<p>将 X 的功率指定为 0 dBW，添加噪声以产生 10 dB 的 SNR，并利用本地随机流。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">S <span class="built_in">=</span> RandStream(<span class="string">&#x27;mt19937ar&#x27;</span>,<span class="string">&#x27;Seed&#x27;</span>,<span class="number">5489</span>);</span><br><span class="line">sigin <span class="built_in">=</span> sqrt(<span class="number">2</span>)*sin(<span class="number">0</span>:pi/<span class="number">8</span>:<span class="number">6</span>*pi);</span><br><span class="line">sigout1 <span class="built_in">=</span> awgn(sigin,<span class="number">10</span>,<span class="number">0</span>,S);</span><br></pre></td></tr></table></figure>
<p>将 AWGN 添加到 <code>sigin</code>。 使用 <a href="https://ww2.mathworks.cn/help/matlab/ref/isequal.html"><code>isequal</code></a> 比较 <code>sigout1</code> 和 <code>sigout2</code>。 当不重置随机流时，输出不相等。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">sigout2 <span class="built_in">=</span> awgn(sigin,<span class="number">10</span>,<span class="number">0</span>,S);</span><br><span class="line">isequal(sigout1,sigout2)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ans &#x3D; logical</span><br><span class="line">   0</span><br></pre></td></tr></table></figure>
<p>重置随机流对象，将对象置为初始状态，然后再将 AWGN 添加到 <code>sigout1</code>。将 AWGN 添加到 <code>sigin</code> 并将 <code>sigout1</code> 与 <code>sigout3</code> 比较。 重置随机流后，输出相等。</p>
<figure class="highlight m"><table><tr><td class="code"><pre><span class="line">reset(S);</span><br><span class="line">sigout3 <span class="built_in">=</span> awgn(sigin,<span class="number">10</span>,<span class="number">0</span>,S);</span><br><span class="line">isequal(sigout1,sigout3)</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ans &#x3D; logical</span><br><span class="line">   1</span><br></pre></td></tr></table></figure>
<h1 id="输入参数">输入参数</h1>
<h2 id="in---输入信号"><code>in</code> - 输入信号</h2>
<p>输入信号，指定为<strong>标量</strong>，<strong>向量</strong>或<strong>数组</strong>。假定输入信号的功率为0 dBW。</p>
<p><strong>数据类型</strong>：<code>double</code> <strong>复数支持</strong>：是</p>
<h2 id="snr---信噪比snr"><code>snr</code> - 信噪比（SNR）</h2>
<p>信噪比（以 dB 为单位），指定为<strong>标量</strong>。</p>
<div class="note info">
            <p>注意：</p><p>加上噪声后，此函数会将相同的 <code>snr</code> 应用于完整输入信号的所有元素。阵列输入信号没有独立通道的概念。 要独立考虑多个频道，请参阅 <a href="https://ww2.mathworks.cn/help/comm/ref/comm.awgnchannel-system-object.html"><code>comm.AWGNChannel</code></a>。</p>
          </div>
<p><strong>数据类型</strong>：<code>double</code></p>
<h2 id="signalpower---信号功率"><code>signalpower</code> - 信号功率</h2>
<p>信号功率，指定为<strong>标量</strong>或 <code>measured</code>。</p>
<ul>
<li><p>当 <code>signalpower</code> 为标量时，该值用作 <code>in</code> 的信号电平，以便根据 <code>snr</code> 的值确定适当的噪声电平。</p></li>
<li><p>当 <code>signalpower</code> 为 <code>measured</code> 时，将计算 <code>in</code> 的信号电平，以根据 <code>snr</code> 的值确定适当的噪声电平。</p></li>
</ul>
<div class="note info">
            <p>注意：</p><p>当指定 <code>measured</code> 时，此函数将使用完整输入信号的所有元素来计算信号功率。在计算功率时，阵列输入信号没有独立通道的概念。</p>
          </div>
<p><strong>数据类型</strong>：<code>double</code></p>
<h2 id="randobject---随机数流对象"><code>randobject</code> - 随机数流对象</h2>
<p>随机数流对象，指定为 <a href="https://ww2.mathworks.cn/help/matlab/ref/randstream.html"><code>RandStream</code></a> 对象。 随机流对象的状态确定 <a href="https://ww2.mathworks.cn/help/matlab/ref/randn.html"><code>randn</code></a> 函数产生的数字序列。使用 <a href="https://ww2.mathworks.cn/help/matlab/ref/randstream.reset.html"><code>reset (RandStream)</code></a> 函数及其属性来配置随机流对象。</p>
<p><code>wgn</code> 使用 <a href="https://ww2.mathworks.cn/help/matlab/ref/randn.html"><code>randn</code></a> 生成正常的随机噪声样本。<a href="https://ww2.mathworks.cn/help/matlab/ref/randn.html"><code>randn</code></a> 函数使用 <a href="https://ww2.mathworks.cn/help/matlab/ref/randstream.html"><code>RandStream</code></a> 对象中的一个或多个统一值来生成每个正态值。</p>
<p>有关产生可重复噪声样本的信息，请参见<a href="#tips">提示</a>。</p>
<h2 id="seed---随机数生成器种子"><code>seed</code> - 随机数生成器种子</h2>
<p>随机数生成器种子，指定为<strong>标量</strong>。</p>
<h2 id="powertype---信号功率单元"><code>powertype</code> - 信号功率单元</h2>
<p>信号功率单元，指定为 <code>dB</code> 或 <code>linear</code>。默认为 <code>dB</code>。</p>
<ul>
<li><p>当功率类型为 <code>dB</code> 时，以 dB 为单位测量 snr，以 dBW 为单位测量信号功率。</p></li>
<li><p>当功率类型为 <code>linear</code> 时，<code>snr</code> 以比率进行测量，<code>signalpower</code> 以瓦特为单位。</p></li>
</ul>
<p>有关 SNR 与噪声相对功率的其他度量（例如 <span class="math inline">\(E_\mathrm{S}/N_0\)</span> 和 <span class="math inline">\(E_\mathrm{b}/N_0\)</span>）之间的关系，请参阅 <a href="https://ww2.mathworks.cn/help/comm/ug/awgn-channel.html#a1071501088">AWGN 信道噪声级别</a>。</p>
<h1 id="输出参数">输出参数</h1>
<h2 id="out---输出信号"><code>out</code> - 输出信号</h2>
<p>输出信号，以<strong>标量</strong>，<strong>向量</strong>或<strong>数组</strong>形式返回。 返回的输出信号是添加了高斯白噪声的输入信号。</p>
<h1 id="提示">提示<span id="tips"></span></h1>
<ul>
<li><p>要生成可重复的高斯白噪声样本，请使用以下技巧之一：</p>
<ul>
<li><p>提供静态 <code>seed</code> 值作为 <code>awgn</code> 的输入。</p></li>
<li><p>在将 <code>randobject</code> 传递为 <code>awgn</code> 的输入之前，请对 <code>randobject</code> 使用 <a href="https://ww2.mathworks.cn/help/matlab/ref/randstream.reset.html"><code>reset (RandSteam)</code></a> 函数。</p></li>
<li><p>将处于已知状态的 <code>randobject</code> 提供给 <code>awgn</code>。有关更多信息，请参见 <a href="https://ww2.mathworks.cn/help/matlab/ref/randstream.html"><code>RandStream</code></a>。</p></li>
</ul></li>
</ul>
<h1 id="扩展功能">扩展功能</h1>
<h2 id="cc-代码生成">C/C++ 代码生成</h2>
<blockquote>
<p>使用 MATLAB® Coder™ 生成 C 代码和 C++ 代码。</p>
<blockquote>
<p>用法说明和限制：</p>
<p>支持代码生成，但包括 <a href="https://ww2.mathworks.cn/help/matlab/ref/randstream.html"><code>RandStream</code></a> 对象的语法除外。</p>
</blockquote>
</blockquote>
<h1 id="另请参阅">另请参阅</h1>
<h2 id="函数">函数</h2>
<p><a href="https://ww2.mathworks.cn/help/matlab/ref/randstream.html"><code>RandStream</code></a> | <a href="%5BRandStream%5D(https://ww2.mathworks.cn/help/matlab/ref/randstream.html)"><code>bsc</code></a> | <a href="https://ww2.mathworks.cn/help/matlab/ref/randn.html"><code>randn</code></a> | <a href="https://ww2.mathworks.cn/help/comm/ref/wgn.html"><code>wgn</code></a></p>
<h2 id="对象">对象</h2>
<p><a href="https://ww2.mathworks.cn/help/comm/ref/comm.awgnchannel-system-object.html"><code>comm.AWGNChannel</code></a></p>
<h2 id="话题">话题</h2>
<p><a href="https://ww2.mathworks.cn/help/comm/ug/awgn-channel.html#a1071501088">AWGN Channel Noise Level</a></p>
<table>
<colgroup>
<col style="width: 100%" />
</colgroup>
<tbody>
<tr class="odd">
<td style="text-align: left;">在 R2006a 之前推出</td>
</tr>
</tbody>
</table>
<p>原文参考：<a href="https://ww2.mathworks.cn/help/comm/ref/awgn.html">https://ww2.mathworks.cn/help/comm/ref/awgn.html</a></p>
]]></content>
      <categories>
        <category>MATLAB</category>
        <category>翻译</category>
        <category>帮助文档</category>
        <category>信号处理</category>
        <category>噪声</category>
      </categories>
      <tags>
        <tag>MATLAB</tag>
        <tag>翻译</tag>
        <tag>高斯白噪声</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo-NexT 折腾就完事儿了</title>
    <url>/posts/b158f1b4.html</url>
    <content><![CDATA[<h1 id="瞎折腾美化侧边栏">瞎折腾/<del>美化</del>侧边栏</h1>
<p>在博客根目录下的 <code>source/_data</code> 文件夹中新建 <code>sidebar.swig</code> 文件。</p>
<h2 id="添加-tag-cloud">添加 Tag Cloud</h2>
<p>安装 <code>hexo-tag-cloud</code> 插件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-tag-cloud --save</span><br></pre></td></tr></table></figure>
<p>添加相关代码写入 <code>sidebar.swig</code>。不喜欢标题的把 <code>&lt;h3 class="widget-title"&gt;Tag Cloud&lt;/h3&gt;</code> 去掉即可。</p>
<figure class="highlight html"><figcaption><span>source/_data/sidebar.swig</span></figcaption><table><tr><td class="code"><pre><span class="line">&#123;% if site.tags.length &gt; 1 %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/js/tagcloud.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/js/tagcanvas.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;widget-wrap&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span> <span class="attr">class</span>=<span class="string">&quot;widget-title&quot;</span>&gt;</span>Tag Cloud<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;myCanvasContainer&quot;</span> <span class="attr">class</span>=<span class="string">&quot;widget tagcloud&quot;</span> <span class="attr">style</span>=<span class="string">&quot;font-size:20px;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">canvas</span> <span class="attr">width</span>=<span class="string">&quot;220&quot;</span> <span class="attr">height</span>=<span class="string">&quot;200&quot;</span> <span class="attr">id</span>=<span class="string">&quot;resCanvas&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width=100%&quot;</span>&gt;</span></span><br><span class="line">            &#123;&#123; list_tags() &#125;&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h1 id="瞎折腾美化页面">瞎折腾/<del>美化</del>页面</h1>
<p>在博客根目录下的 <code>source/_data</code> 文件夹中新建 <code>variables.styl</code> 文件。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd hexo</span><br><span class="line">vi source/_data/variables.styl</span><br></pre></td></tr></table></figure>
<h2 id="页面圆角">页面圆角</h2>
<p>在 <code>variables.styl</code> 文件里添加圆角半径值</p>
<figure class="highlight"><figcaption><span>source/_data/variables.styl</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// 圆角设置</span></span><br><span class="line">$border-radius-inner     = 0px;     // 内部圆角半径</span><br><span class="line">$border-radius           = 8px;     // 外部圆角半径</span><br></pre></td></tr></table></figure>
<h1 id="需要修改源代码的操作">需要修改源代码的操作</h1>
<h2 id="修改侧边栏最大高度">修改侧边栏最大高度</h2>
<p>Sidebar 的高度在 <code>themes/next/source/js/util.js</code> 文件中计算出，修改计算公式可调整 Sidebar 的最大高度。</p>
<figure class="highlight javascript"><figcaption><span>themes/next/source/js/util.js - 原 Sidebar 最大高度</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Init Sidebar &amp; TOC inner dimensions on all pages and for all schemes.</span></span><br><span class="line"><span class="comment"> * Need for Sidebar/TOC inner scrolling if content taller then viewport.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">initSidebarDimension: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// Initialize Sidebar &amp; TOC Height.</span></span><br><span class="line">  <span class="keyword">var</span> sidebarWrapperHeight = <span class="built_in">document</span>.body.offsetHeight - sidebarSchemePadding + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><figcaption><span>themes/next/source/js/util.js - 修改后的 Sidebar 最大高度</span></figcaption><table><tr><td class="code"><pre><span class="line">initSidebarDimension: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// Initialize Sidebar &amp; TOC Height.</span></span><br><span class="line">  <span class="keyword">var</span> sidebarWrapperHeight = <span class="built_in">document</span>.body.offsetHeight - sidebarSchemePadding -<span class="number">100</span> + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<ul>
<li>参考文档：<a href="https://yi-yun.github.io/Hexo-Next-Custom/#更改-sidebar-大小https://yi-yun.github.io/Hexo-Next-Custom/#更改-sidebar-大小">Hexo Next 博客自定义配置 -&gt; 更改-sidebar-大小</a></li>
</ul>
]]></content>
      <categories>
        <category>Blog</category>
        <category>Hexo</category>
        <category>Next</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title>Lost - Cher Lloyd</title>
    <url>/posts/8cb867fe.html</url>
    <content><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="420" height="86" src="//music.163.com/outchain/player?type=2&amp;id=1443007197&amp;auto=0&amp;height=66">
</iframe>
<table>
<colgroup>
<col style="width: 22%" />
<col style="width: 77%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;"></th>
<th style="text-align: center;">"Lost"</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Cover</td>
<td style="text-align: center;"><img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/Album%20Cover/Cher%20Lloyd/Cher%20Lloyd-Lost-Cover.jpg" width=300px/></td>
</tr>
<tr class="even">
<td style="text-align: center;">Singer</td>
<td style="text-align: center;">Cher Lloyd</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Album Type</td>
<td style="text-align: center;">Single</td>
</tr>
<tr class="even">
<td style="text-align: center;">Released</td>
<td style="text-align: center;">24 April 2020</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Length</td>
<td style="text-align: center;">2:55</td>
</tr>
<tr class="even">
<td style="text-align: center;">Label</td>
<td style="text-align: center;">Universal, Polydor</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Songwriter(s)</td>
<td style="text-align: center;">Raphaella, Casey Smith, Patrick Jordan-Patrikios, Boy Matthews, Youthonix, Cher Lloyd</td>
</tr>
<tr class="even">
<td style="text-align: center;">Producer(s)</td>
<td style="text-align: center;">Hitimpulse</td>
</tr>
</tbody>
</table>
<a id="more"></a>
<p>"Lost" is a song by English singer Cher Lloyd from her upcoming third studio album. Released on April 24, 2020,<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> under Universal Music Group, the song is the second single released off of Lloyd's upcoming album, following "M.I.A" in 2019.<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> An accompanying video directed by Raja Virdi was released on April 24.<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> Writing for The Guardian, Leonie Cooper said: "There is something heartening about this largely harmless return."<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a></p>
<h1 id="background-and-production">Background and production</h1>
<p>After releasing her album Sorry I'm Late in 2014, Lloyd went on a musical hiatus before releasing several songs between 2016 and 2019. After signing a new record deal with Polydor Records &amp; Universal Music Germany, she released "None of My Business" in 2018 and "M.I.A" in 2019. 2020 brought "Lost" which was teased for a week before being released in April.<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a></p>
<p>The song was written by Raphaella, Casey Smith, Patrick Jordan-Patrikios, Boy Matthews, Youthonix &amp; Cher Lloyd while it was mixed and mastered by Lex Barkey. Hitimpulse produced the song and have been consistent collaborators with Cher doing production on 2018's "None Of My Business" and additional production on 2019's "M.I.A".<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a></p>
<h1 id="critical-reception">Critical Reception</h1>
<p>Mike Wass of Idolator called the song a "cute bop" stating "Cher Lloyd returns with a fiery kiss-off anthem called 'Lost', which is the musical equivalent of posturing on social media so your ex can see how amazing your life is."<a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a> While Pip Williams writing for The Line Of Best Fit stated "Lost" is far and away the strongest release of Lloyd's career to date, blowing those who still reference "Swagger Jagger" as a career high out of the water. The new cut sees Lloyd embrace languid balladry as a vehicle for a surprisingly hard-hitting lyric. It's still slickly produced and radio-friendly, but there's a heart and soul to it that many mainstream stars would struggle to match."<a href="#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a></p>
<h1 id="music-video">Music video</h1>
<p>The official video to the single premiered on YouTube the day of release. The video was shot in a single take with no cuts or edits made, depicting Lloyd on a bed with neon and pastel lights changing behind her as she sings. Lloyd commented in an Instagram Livestream that the lighting was the most difficult aspect of filming the video. The video was produced by Phase Films and directed by frequent collaborator Raja Virdi who worked on her previous single "M.I.A".<a href="#fn9" class="footnote-ref" id="fnref9" role="doc-noteref"><sup>9</sup></a></p>
<div data-align="center">
<p><iframe width="560" height="315" src="https://www.youtube.com/embed/DDw1aCfaUxI" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></p>
</div>
<h1 id="lyrics">Lyrics</h1>
<p><font size="3" face="Comic Sans MS, Comic Sans, cursive"> [Verse 1]<br> I heard from a friend of a friend<br> That you've been checking back in, Mhm-mhm<br> 'Cause I said goodbye, moved overnight<br> And you haven't heard much since then<br> Wondering how I'm doing now<br> <br> [Pre-Chorus]<br> It's none of your business, first of all<br> Wondering how I'm doing now<br> But if you've got to know, well sure<br> Well sure<br> <br> [Chorus]<br> You think I'd be lost<br> Think I'd be lost without you, lost<br> Is it hard knowing you're wrong?<br> See I got lots without you, lots without you<br> <br> [Post-Chorus]<br> Great sex in the morning, sex in the morning, someone to hold me<br> I got lo-oh-oh-oh-oh, lots<br> Stay out in the nighttime, out in the nighttime, have me a wild time<br> I got lo-oh-oh-oh-oh, lots<br> <br> [Verse 2]<br> You heard from a friend of a friend<br> That I've been doing just fine, I-I<br> You don't want me, you just want me<br> To keep wanting you all of the time<br> But if you were wondering<br> <br> <br> [Pre-Chorus]<br> It's none of your business first of all<br> Wondering how I'm doing now<br> But if you've got to know, well sure<br> Well sure<br> <br> [Chorus]<br> You think I'd be lost<br> Think I'd be lost without you, lost<br> Is it hard knowing you're wrong?<br> See I got lots without you, lots without you<br> <br> [Post-Chorus]<br> Great sex in the morning, sex in the morning, someone to hold me<br> I got lo-oh-oh-oh-oh, lots (Yeah)<br> Stay out in the nighttime, out in the nighttime, have me a wild time<br> I got lo-oh-oh-oh-oh, lots<br> <br> [Bridge]<br> To be honest, I think I dodged a bullet with you<br> And I don't know how I didn't see it coming, but ooh<br> <br> [Verse 3]<br> Yeah, you got a God complex<br> Now I'm thanking God you're my ex<br> I hope you don't trip up on yourself<br> If you think you're so hot, go back to hell (Go back to hell)<br> 'Cause you think that I'd...<br> <br> <br> [Chorus]<br> You think I'd be lost (Be lost, be lost)<br> Think I'd be lost without you, lost<br> Is it hard knowing you're wrong? (Knowing you're wrong)<br> See I got lots without you, lots without you<br> <br> [Post-Chorus]<br> Great sex in the morning, sex in the morning, someone to hold me<br> I got lo-oh-oh-oh-oh, lots (Yeah)<br> Stay out in the nighttime, out in the nighttime, have me a wild time<br> I got lo-oh-oh-oh-oh, lots<br> <br> [Outro]<br> La-la-la-la-la-la-la-la-la<br> La-la-la-la-la-la-la-la-la </font></p>
<h1 id="reference">Reference</h1>
<ul>
<li><p><a href="https://en.wikipedia.org/wiki/Lost_(Cher_Lloyd_song)">"Lost (Cher Lloyd song)"</a>. Retrieved November 15, 2020.</p></li>
<li><p><a href="https://genius.com/Cher-lloyd-lost-lyrics">Cher Lloyd Lost Lyrics</a>. Retrieved November 15, 2020.</p></li>
</ul>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p><a href="https://www.instagram.com/p/B_WvduVnFKg/">"Cher Lloyd on Instagram: "My new single LOST is OUT NOW!!!! Head to the link in my bio to listen / download / share!! The official video will be premiered at 5pm uk…""</a>. Instagram. Retrieved August 27, 2020.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p><a href="https://www.billboard.com/articles/columns/pop/8532778/cher-lloyd-mia">"Cher Lloyd Returns With 'M.I.A.,' an Anthem For Your Post-Party Plans - Billboard"</a>. Retrieved September 25, 2020.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p><a href="https://www.youtube.com/watch?v=DDw1aCfaUxI">"Cher Lloyd - Lost (Official Music Video) - YouTube"</a>. <em>www.youtube.com</em>. Retrieved September 24, 2020.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4" role="doc-endnote"><p><a href="https://www.theguardian.com/music/2020/may/08/katy-j-pearson-track-of-week">"Tracks of the week reviewed: Katy J Pearson, Cher Lloyd, the 1975 - The Guardian"</a>. Retrieved September 25, 2020.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5" role="doc-endnote"><p><a href="https://www.instagram.com/p/B-95yOQnXXR/?utm_source=ig_web_copy_link">"Cher Lloyd teases 'Lost'"</a>. Retrieved September 25, 2020.<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6" role="doc-endnote"><p><a href="https://open.spotify.com/playlist/5lhDKO2VX6QzjO1RFoHKZT?si=LfBWWAIWTUm5Vc2igV5yWg">"Hitimpulse Official Spotify Playlist of songs produced/written by them"</a>. Retrieved September 25, 2020.<a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7" role="doc-endnote"><p><a href="https://www.idolator.com/7909784/cher-lloyd-sizzles-in-one-take-lost-video?view-all">"Cher Lloyd Sizzles in one take 'Lost' video"</a>. Retrieved September 25, 2020.<a href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn8" role="doc-endnote"><p><a href="https://www.thelineofbestfit.com/features/interviews/cher-lloyd-is-bigger-than-the-bullshit">"Cher Lloyd is bigger than the bullshit - The Line Of Best Fit"</a>. Retrieved September 25, 2020.<a href="#fnref8" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn9" role="doc-endnote"><p><a href="https://rajavirdi.com/promos">"Raja Virdi Music Videos"</a>. Retrieved September 25, 2020.<a href="#fnref9" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
]]></content>
      <categories>
        <category>Music</category>
        <category>Cher Lloyd</category>
      </categories>
      <tags>
        <tag>Cher Lloyd</tag>
        <tag>Music</tag>
        <tag>2020</tag>
        <tag>Pop</tag>
      </tags>
  </entry>
  <entry>
    <title>Josh 的学习笔记之 Verilog（Part 2 —— Verilog 语言基础）</title>
    <url>/posts/fd2ca242.html</url>
    <content><![CDATA[<p>本文从一个 Verilog 用例出发，对 Verilog 语言的语法进行了阐释。包括的内容主要有 Verilog 语言的基本词法，常用的编译指令，逻辑值、常量、变量的含义，操作符的概念和分类等，还对 Verilog 中的参数、并发以及系统任务和系统函数进行了简要说明。</p>
<h1 id="两种设计方法top-down-和-bottom-up">1. 两种设计方法（Top-Down 和 Bottom-Up）</h1>
<p>在传统意义上，设计硬件电路主要是使用自底向上（Bottom-Up）的设计方法。工程师们总是从最底层的逻辑门开始，逐渐搭建成较大的模块，然后再将这些模块组成更大的模块，最后形成整个设计。</p>
<p>在 <a href="https://josh-gao.top/posts/460433dd.html">Part 1——初识 HDL 设计方法</a>中已经提到，随着 HDL 和逻辑综合技术的进步，工程师们逐渐可以使用自顶向下（Top-Down）的方法来设计硬件。这样，工程师们<strong>首先关注于设计的规格（Specification），然后将规格分解为一个个模块，再分解为更小的模块</strong>。然后采用 HDL 的可综合子集直接描述硬件的行为，由逻辑综合工具自动完成由 HDL 到门级电路的转换。</p>
<a id="more"></a>
<p>最近几年，随着 IP核 市场的逐渐兴起，许多设计者逐渐意识到<strong>利用现有的 IP核 可以帮助节约设计成本、减少设计周期</strong>，有许多设计工程师，甚至希望所有的设计模块都使用现成的模块，自己仅仅开发一些简单的粘合逻辑。这就有点像电路板设计的过程，工程师将各种芯片集成到一块电路板上，自己完成这些芯片间的互连和一些简单的 CPLD 逻辑设计，以及对微处理器的编程。使用现有的 IP 来搭建系统实际上也是一种自底向上（Bottom-Up）的设计方法。</p>
<p>从以上描述可以看出，设计硬件电路时，这两种设计方法都有可能采用。Verilog HDL 可以完全支持这两种设计方法。</p>
<ul>
<li>在门级的设计中，用户可以直接实例化 Verilog 语言中的门级原语构建系统；</li>
<li>如果需要描述硬件的行为，可以使用 Verilog 的行为级描述功能；</li>
<li>如果要使用 IP核 ，只要在设计中直接实例化 IP核 即可。</li>
</ul>
<p>EDA 行业的先行者们发明了 Verilog 硬件描述语言，其最根本的目的就是用 Verilog 来描述硬件的行为，但是有的描述是不需要实现为硬件电路的。</p>
<p>如果用户的 Verilog 描述的最终目的是要实现为硬件电路，那么要<strong>时刻提醒自己是在设计电路</strong>，这与用 C 语言对处理器编程有很大的区别。</p>
<p>硬件电路最大的特点是由一个个模块组成，模块之间使用互连线，各个模块<strong>独立并行</strong>工作。同时，它们通过输入和输出端口与相邻的模块互相沟通。每个硬件单元都有相应的<strong>延时特性</strong>，硬件的延时也是设计的目标之一。</p>
<h1 id="从-verilog-实例出发">2. 从 Verilog 实例出发</h1>
<h2 id="verilog-实例">2.1. Verilog 实例</h2>
<p><a name="JoshVerilog模块"></a>首先看一个简单的如下图所示的电路（模块）：JoshVerilog。它可以是一个独立的设计，也可以是更大的系统的一个组成部分。</p>
<div data-align="center">
<p><img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-28-josh-verilog-part-2/2020-11-28-josh-verilog-part-2-010-JoshVerilog.png!700px"/></p>
</div>
<p>该电路首先在两个 2 位的输入数据 <code>A_in[1:0]</code> 的和 <code>B_in[1:0]</code> 之间，由 <code>sel</code> 信号做二选一。后面是一个 2-4 译码电路，将输入的信号 <code>result[1:0]</code>解析成 <code>eq0</code>、<code>eql</code>、<code>eq2</code> 和 <code>eq3</code> 这4个信号，它们同时只有一个为 1。</p>
<p>将 <code>eq0</code> 和 <code>eql</code> 相异或（xor），<code>eq2</code> 和 <code>eq3</code> 相异或。然后，将两个异或的结果 <code>A_xor_wire</code> 和 <code>XOR_B</code> 分别寄存输出给 <code>A_xor_out</code> 和 <code>B_xor_out</code> 两个输出寄存器带有低有效（active low）的异步复位端。</p>
<p><strong>这些电路单元都是同时并行工作的，相互之间并没有先后顺序关系，这一点与软件设计程序很不一样。</strong></p>
<p>下面具体分析 <a href="#JoshVerilog模块">JoshVerilog 模块</a>的电路功能。源代码如下。</p>
<p><a name="JoshVerilog代码"></a></p>
<figure class="highlight verilog"><figcaption><span>Josh.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编译指令, 定义时间单位和时间精度</span></span><br><span class="line"><span class="meta">`<span class="meta-keyword">timescale</span> 1ns/100p             // 每个时间单位是1ns, 仿真精度是100ps</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// module名 + 端口列表</span></span><br><span class="line"><span class="keyword">module</span> Josh( clk, rst_n, A_in, B_in, sel, A_xor_out, B_xor_out );</span><br><span class="line"></span><br><span class="line"><span class="comment">// IO端口声明</span></span><br><span class="line"><span class="keyword">input</span>       clk;</span><br><span class="line"><span class="keyword">input</span>       rst_n;</span><br><span class="line"><span class="keyword">input</span> [<span class="number">1</span>:<span class="number">0</span>] A_in;               <span class="comment">// 该信号的输入位宽为2</span></span><br><span class="line"><span class="keyword">input</span> [<span class="number">1</span>:<span class="number">0</span>] B_in;</span><br><span class="line"><span class="keyword">input</span>       sel;</span><br><span class="line"><span class="keyword">output</span>      A_xor_out;</span><br><span class="line"><span class="keyword">output</span>      B_xor_out;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内部线网和寄存器声明</span></span><br><span class="line"><span class="keyword">wire</span>        A_xor_wire;         <span class="comment">// 模块内wire型变量</span></span><br><span class="line"><span class="keyword">wire</span>        B_xor_wire;</span><br><span class="line"><span class="keyword">wire</span>  [<span class="number">1</span>:<span class="number">0</span>] result;</span><br><span class="line"><span class="keyword">reg</span>         eq0, eq1, eq2, eq3; <span class="comment">// 模块内reg型变量</span></span><br><span class="line"><span class="keyword">reg</span>         A_xor_out;</span><br><span class="line"><span class="keyword">reg</span>         B_xor_out;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 行为描述, DFF_A</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">    <span class="keyword">if</span> (~rst_n)</span><br><span class="line">        A_xor_out &lt;= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        A_xor_out &lt;= A_xor_wire;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 行为描述, DFF_B</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">    <span class="keyword">if</span> (~rst_n)</span><br><span class="line">        B_xor_out &lt;= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        B_xor_out &lt;= B_xor_wire;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据流描述, A_xor_wire</span></span><br><span class="line"><span class="keyword">assign</span> #<span class="number">1</span> A_xor_wire = eq0 ^ eq1;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构化描述, XOR_B, 直接使用 Verilog 自带的 xor 门原句</span></span><br><span class="line"><span class="keyword">xor</span> #<span class="number">1</span> XOR_B(B_xor_wire, eq2, eq3);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据流描述, MUX21</span></span><br><span class="line"><span class="keyword">assign</span> #<span class="number">3</span> result = sel ? B_in : A_in;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 行为描述, DECODER, 一个2-4译码器</span></span><br><span class="line"><span class="keyword">always</span> @(result) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">case</span>(result)</span><br><span class="line">        <span class="number">2&#x27;b00</span>: <span class="keyword">begin</span></span><br><span class="line">            &#123;eq3, eq2, eq1, eq0&#125; = #<span class="number">2</span> <span class="number">4&#x27;b0001</span>;</span><br><span class="line">            <span class="built_in">$display</span> (<span class="string">&quot;At time %t-&quot;</span>, <span class="built_in">$time</span>, <span class="string">&quot;eq0 = 1&quot;</span>);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="number">2&#x27;b01</span>: <span class="keyword">begin</span></span><br><span class="line">            &#123;eq3, eq2, eq1, eq0&#125; = #<span class="number">2</span> <span class="number">4&#x27;b0010</span>;</span><br><span class="line">            <span class="built_in">$display</span> (<span class="string">&quot;At time %t-&quot;</span>, <span class="built_in">$time</span>, <span class="string">&quot;eq1 = 1&quot;</span>);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="number">2&#x27;b10</span>: <span class="keyword">begin</span></span><br><span class="line">            &#123;eq3, eq2, eq1, eq0&#125; = #<span class="number">2</span> <span class="number">4&#x27;b0100</span>;</span><br><span class="line">            <span class="built_in">$display</span> (<span class="string">&quot;At time %t-&quot;</span>, <span class="built_in">$time</span>, <span class="string">&quot;eq2 = 1&quot;</span>);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="number">2&#x27;b11</span>: <span class="keyword">begin</span></span><br><span class="line">            &#123;eq3, eq2, eq1, eq0&#125; = #<span class="number">2</span> <span class="number">4&#x27;b1000</span>;</span><br><span class="line">            <span class="built_in">$display</span> (<span class="string">&quot;At time %t-&quot;</span>, <span class="built_in">$time</span>, <span class="string">&quot;eq3 = 1&quot;</span>);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">default</span>: ;</span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">// module结束</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>代码分析如下。</p>
<ol type="1">
<li><p>二选一多路选择器</p>
<p>对于 <code>MUX21</code> 这样二选一的电路，将采用如下的数据流描述（assign语句）：</p>
<p><figure class="highlight verilog"><figcaption><span>Josh.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> #<span class="number">3</span> result = sel ? B_in : A_in;</span><br></pre></td></tr></table></figure></p>
<p><code>assign</code> 是 Verilog 中的关键词，用它赋值的语言称为<strong>连续赋值语句</strong>。</p>
<p>如果 <code>sel</code>为真（1），则选择 <code>B_in</code>，否则将选择 <code>A_in</code>，而 <code>#3</code> 表示经过 3 个延时单位，再将选择结果赋值给 <code>result</code>，这也模拟了组合逻辑的延时。由于在<a href="#JoshVerilog代码">代码</a>最开头已经使用 Verilog 的编译指令将延时单位定义为 1ns（<code>timescale 1ns/100ps</code>），因此这里的 <code>#3</code> 代表 3ns 的延时。</p></li>
<li><p>2 - 4 译码器</p>
<p>关于实现 2 - 4 译码器，则采用了如下的描述：</p>
<p><figure class="highlight verilog"><figcaption><span>Josh.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @(result) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">case</span>(result)</span><br><span class="line">        <span class="number">2&#x27;b00</span>: <span class="keyword">begin</span></span><br><span class="line">            &#123;eq3, eq2, eq1, eq0&#125; = #<span class="number">2</span> <span class="number">4&#x27;b0001</span>;</span><br><span class="line">            <span class="built_in">$display</span> (<span class="string">&quot;At time %t-&quot;</span>, <span class="built_in">$time</span>, <span class="string">&quot;eq0 = 1&quot;</span>);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">default</span>: ;</span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p>
<p>这里采用了另一种描述方式：用 <code>always</code> 语句来描述电路的行为。通过 <code>case</code> 判断 <code>result</code> 的值来决定 <code>eq0</code>、<code>eq3</code> 的值。同样，也采用 <code>#2</code> 来模拟组合逻辑的延时。<code>always</code> 和 <code>case</code> 也是 Verilog 中的关键词。这样的描述方法称之为<strong>行为描述</strong>，它侧重于描述电路的行为。</p>
<p><figure class="highlight verilog"><figcaption><span>Josh.v</span></figcaption><table><tr><td class="code"><pre><span class="line">&#123;eq3, eq2, eq1, eq0&#125; = #<span class="number">2</span> <span class="number">4&#x27;b0001</span>;</span><br></pre></td></tr></table></figure></p>
<p>该语句表示将 <code>4'b0001</code> 赋值给 <code>eq3~eq0</code> 合并成的 4 位变量。<code>&#123;&#125;</code> 是 Verilog 的合并符号。</p></li>
<li><p>异或门</p>
<p>对于 <code>A_xor_wire</code> 和 <code>XOR_B</code> 的两个完全一样的异或门，也采用了两种不同的描述方式：</p>
<p><figure class="highlight verilog"><figcaption><span>Josh.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> #<span class="number">1</span> A_xor_wire = eq0 ^ eq1;</span><br></pre></td></tr></table></figure></p>
<p>和</p>
<p><figure class="highlight verilog"><figcaption><span>Josh.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">xor</span> #<span class="number">1</span> XOR_B(B_xor_wire, eq2, eq3);</span><br></pre></td></tr></table></figure></p>
<p><code>xor</code> 是 Verilog 中自带的基本逻辑门原语。这里相当于调用了该 <code>xor</code> 门。而 <code>B_xor_wire</code>、<code>eq2</code> 和 <code>eq3</code> 是代入到 <code>xor</code> 门中的参数。<code>eq2</code> 和 <code>eq3</code> 是输入，<code>B_xor_wire</code> 是输出。这里 <code>B_xor_wire</code> 是 <code>eq2</code> 和 <code>eq3</code> 相异或的结果。</p>
<p>在 Verilog 中，<strong>将调用其他功能模块（包括 Verilog 的内嵌基本逻辑门）称为“实例化（lnstantiate）”</strong>。实例化<strong>类似</strong>于软件设计中的调用，但不能简单理解为软件中的调用。软件调用过程是顺序执行的，而实例化的硬件电路在设计中是独立于其他功能块，并行运行的。</p>
<p>这种<strong>在模块中实例化其他功能模块</strong>的描述方式被称之为<strong>结构化描述</strong>。</p></li>
</ol>
<h2 id="种描述方法">2.2. 3 种描述方法</h2>
<p>从以上的描述可以看出 Verilog 语言的 3 种基本的描述方法（基本上所有的 Verilog 功能模块都是由这 3 种方式来描述）：</p>
<ul>
<li><p><strong>数据流描述</strong>：采用 <code>assign</code> 语句，该语句被称为连续赋值语句；</p></li>
<li><p><strong>行为描述</strong>：使用 <code>always</code> 或 <code>initial</code> 语句块，其中出现的语句被称为过程赋值语句；</p></li>
<li><p><strong>结构化描述</strong>：实例化已有的功能模块。结构化描述主要有以下3种：</p>
<ul>
<li>Module实例化：实例化已有的 module；</li>
<li>门实例化：实例化基本的门电路原语；</li>
<li>用户定义原语（UDP）实例化：实例化用户定义的原语。</li>
</ul></li>
</ul>
<p>在<a href="https://josh-gao.blog.csdn.net/article/details/105262549">《Part 3——描述方式和设计层次》</a>中会将详细介绍 Verilog 语言中的这 3 种描述方式。</p>
<h1 id="verilog-的基本词法">3. Verilog 的基本词法</h1>
<p>Verilog HDL 是一种<strong>大小写敏感</strong>的语言，这一点与 VHDL 不同，因此在书写的时候要格外注意。在 Verilog 语言中，<strong>所有的关键字（又叫保留字）都为小写</strong>。Verilog 的内部信号名（或称为标识符）使用大写和小写都可以。标识符可以是字母、数字、<code>$</code>（美元符号）和 <code>_</code>（下划线）任意组合，只要<strong>第一个字符是字母或者下划线</strong>即可。</p>
<blockquote>
<p>因为 Verilog HDL 对大小写敏感，因此养成良好的信号定义习惯非常重要，否则容易因为大小写不同造成信号的歧义。推荐的信号定义习惯为：<strong>所有信号和网线名均小写，用下划线分割单词，而宏变量全部用大写字母。</strong></p>
</blockquote>
<p>在上述<a href="#JoshVerilog代码">代码</a>中，用双反斜线 <code>//</code> 表示注释。另外，还有一种注释方式，用 <code>/* ...... */</code> 来表示。所不同的是前者为单行注释，而后者将 <code>/*</code> 和 <code>*/</code> 之间的内容全部看作注释内容。</p>
<blockquote>
<p>通常，注释的内容只是作者为了增强代码的可读性而增加的内容，对整个代码的功能没有任何影响。不过，在一些工具中，尤其是逻辑综合工具，定义了一些特殊的指令，用于控制工具编译过程。这些指令也是以注释的方式出现的。例如：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">moduleblbox(out, data, clk) <span class="comment">/* synthesis syn_black_box */</span>;</span><br></pre></td></tr></table></figure>
<p>在 <code>modulebl_box</code> 的声明处有一行注释，用 <code>/* ...... */</code> 表示。它看起来是一个注释，实际上，是综合工具Synplify中的一个指令，指示 Synplify 将该模块看作一个黑盒（black_box），不处理模块内部的描述。</p>
</blockquote>
<p>在 Verilog 中，通常使用空格符、跳格符和换行符作为间隔。在书写代码的时候，适当运用间隔符可以提高代码的可读性。比如在声明 4 个 <code>reg</code> 型数据 <code>eq0~eq3</code> 时，可以采用上述<a href="#JoshVerilog代码">例子</a>中的方法：</p>
<figure class="highlight verilog"><figcaption><span>Josh.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">reg</span> eq0, eq1, eq2, eq3;</span><br></pre></td></tr></table></figure>
<p>也可以用换行符将其分开：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">reg</span> eq0;</span><br><span class="line"><span class="keyword">reg</span> eq1;</span><br><span class="line"><span class="keyword">reg</span> eq2;</span><br><span class="line"><span class="keyword">reg</span> eq3;</span><br></pre></td></tr></table></figure>
<p>在verilog中，还有一些转义字符。比如 <code>\n</code> 表示换行符；<code>\t</code> 表示 Tab 键；防止引起歧义，就用 <code>\</code> 表示 <code>\</code> 符号本身等等。这里不再对 Verilog 的词法做过多的描述，更多可以参考 Verilog IEEE 国际标准（<a href="https://standards.ieee.org/standard/1364-2005.html">IEEE Std. 1364-2005</a>）。</p>
<h1 id="模块和端口">4. 模块和端口</h1>
<p>大型设计往往是由一个个模块构成的。实际上，模块可大可小，大到一个复杂的微处理器系统，小到一个基本的晶体管，都可以作为一个模块来设计。例如，在上述代码中描述的 <a href="#JoshVerilog代码">JoshVerilog</a> 就是一个模块。</p>
<p>在 Verilog 中，模块（module）是基本的组成单位。</p>
<blockquote>
<p>通常，建议在一个 Verilog 文件中，只放一个 <code>module</code> 定义，而且使文件名称和 <code>module</code> 名称一致。这是一个良好的设计习惯。</p>
</blockquote>
<p>以下是 Verilog 中 <code>module</code> 的基本语法：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> 模块名称( 端口列表 );</span><br><span class="line"><span class="comment">// 声明：</span></span><br><span class="line">    <span class="keyword">reg</span>, <span class="keyword">parameter</span>,</span><br><span class="line">    <span class="keyword">input</span>, <span class="keyword">output</span>, </span><br><span class="line">    <span class="keyword">function</span>, <span class="keyword">task</span>, ...</span><br><span class="line"><span class="comment">// 语句：</span></span><br><span class="line">    <span class="keyword">initial</span> 语句</span><br><span class="line">    <span class="keyword">always</span> 语句</span><br><span class="line">    <span class="keyword">module</span> 实例化</span><br><span class="line">    门实例化</span><br><span class="line">    用户定义原语 (UDP) 实例化</span><br><span class="line">    连续赋值 (Continous assignment)</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>首先，需要有一个名称来标识这个 <code>module</code>。</p>
<p>通常 <code>module</code> 具有输入和输出端口，在 <code>module</code> 名称后面的括号中列出所有的输入、输出和双向的端口名称。</p>
<p>有些 <code>module</code> 也不包含端口。例如，在仿真平台的顶层模块中，其内部已经实例化了所有的设计模块和激励模块，是一个封闭的系统，没有输入和输出。一般这种没有端口的模块都是用于仿真的，不用作实际电路。</p>
<p>在 <code>module</code> 内部的声明部分，需要声明端口的方向，（<code>input</code>, <code>output</code> 和 <code>inout</code>）和位宽。按照 Verilog 的习惯，<strong>高位写在左边，低位写在右边</strong>。比如</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">input</span> [<span class="number">1</span>:<span class="number">0</span>] A_in；</span><br></pre></td></tr></table></figure>
<p>就表示两位的总线。</p>
<p>模块内部使用的 <code>reg</code>（寄存器类型的一种）、<code>wire</code>（线网类型的一种）、参数、函数以及任务等，都将在 <code>module</code> 中声明。</p>
<p>一般来说，<code>module</code> 的</p>
<ul>
<li><code>input</code> 默认定义为 <code>wire</code> 类型；</li>
<li><code>output</code> 信号可以是 <code>wire</code>，也可以是 <code>reg</code> 类型（如果在 <code>always</code> 或 <code>initial</code> 语句块中被赋值）；</li>
<li><code>inout</code> 是双向信号，一般将其设为 <code>tri</code> 类型，表示其有多个驱动源，如无驱动时为三态。</li>
</ul>
<p>虽然变量声明只要出现在使用的相应语句之间即可，但还是建议将所有的声明放在所有的语句之前，这样具有较好的可读性。在声明之后，就应该是语句了。语句有如下几种：</p>
<ul>
<li><code>initial</code> 语句；</li>
<li><code>always</code> 语句；</li>
<li>其他子 <code>module</code> 实例化；</li>
<li>门实例化；</li>
<li>用户定义原语（UDP）实例化；</li>
<li>连续赋值（Continous assignment）。</li>
</ul>
<p>Verilog 中所有的功能描述都是通过以上几种描述方式进行的。</p>
<blockquote>
<p>需要格外注意的是，以上几种语句如果出现在同一个 <code>module</code> 内，其<strong>相互之间是没有任何顺序关系的</strong>，它们在 <code>module</code> 中出现顺序的改变不会改变 <code>module</code> 的功能，这正是硬件的一大特点。有硬件电路原理图设计经验的读者们可以想象一下画原理图的过程，先画哪个，后画哪个器件根本没有任何关系。在 Verilog 中也是类似的道理。</p>
</blockquote>
<h1 id="编译指令">5. 编译指令</h1>
<p>在 Verilog 语言中，提供了一些编译指令，用于指导编译器的工作。例如，定义宏、文件包含、条件编译、时间单位和精度定义等。</p>
<p>Verilog 中的编译指令是从 C 语言中的“预处理指令”演变得来的。这里列出了一些常用的编译指令如下：</p>
<ul>
<li><code>`timescale</code>；</li>
<li><code>`define, `undef</code>；</li>
<li><code>`ifdef, `else, `endif</code>；</li>
<li><code>`include</code>；</li>
<li><code>`resetall</code>。</li>
</ul>
<p>与 C 语言中使用的 <code>#</code> 不同，Verilog 中使用反引号一来标识编译指令。编译器一旦遇到某个编译指令，则其在整个编译过程中有效，可以包含多个文件，直到编译器遇到另一个相同的编译指令。</p>
<h2 id="timescale">5.1. <code>`timescale</code></h2>
<p>在每一个 <code>module</code> 文件前面加上<code>`</code>的编译指令，就可以保证该文件中的延时信息受其自身文件中的 <code>`timescale</code> 编译指令指导。<strong>否则在编译过程中，该模块将沿用上一个</strong> <code>`timescale</code> <strong>的值，或者使用缺省值</strong>。</p>
<p>在上述实例代码中描述的 <a href="#JoshVerilog代码">JoshVerilog</a> 模块中使用了一个<code>`timescale 1ns/100ps</code> 编译指令。其中 <code>1ns</code> 表示延时单位，<code>100ps</code> 表示时间精度，也就是编译器所能接收的最小仿真时间粒度。<code>`timescale</code> 编译指令在模块外部出现，并且影响后面模块中所有的时延值，直到遇到下一个 <code>`timescale</code> 或 <code>`resetall</code>指令。</p>
<p>比如语句：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> #<span class="number">1</span><span class="variable">.16</span> A_xor_wire = eq0 ^ eq1;</span><br></pre></td></tr></table></figure>
<p>如果采用 <code>`timescale 1ns/100ps</code> 编译指令由于延时单位是 <code>1ns</code>，同时最小时间粒度是 <code>100ps</code>，即 <code>0.1ns</code> ，那么根据四舍五入的规则，<code>1.16ns</code> 则实际上对应 <code>1.2ns</code> 延时。如果采用 <code>`timescale 1ns/10ps</code> 编译指令，由于延时单位是 <code>1ns</code>，同时最小时间粒度是 <code>10ps</code>，即 <code>0.01ns</code>，那么 <code>1.16ns</code> 则实际上对应 <code>1.16ns</code> 延时。</p>
<h2 id="define-和-undef">5.2. <code>`define</code> 和 <code>`undef</code></h2>
<p><code>`define</code> 用于定义宏。例如，首先定义一个总线宽度的宏为 16，然后利用这个宏定义一个宽度为 16 的 <code>reg</code>类型数据 <code>Data</code>，方法如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="meta-keyword">define</span> BUS_WIDTH 16</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="meta">`BUS_WIDTH - 1 : 0] Data</span></span><br></pre></td></tr></table></figure>
<p>在一个文件中出现的 <code>`define</code>，可以被多个文件使用。也就是说 <code>`define</code> 是一种<strong>全局的定义</strong>。这是 <code>`define</code> 与 <code>parameter</code> 定义的最大区别，在后面也会提到。</p>
<p><code>`define</code> 指令被编译以后，则在整个编译过程中都有效，直到遇到 <code>`undef</code> 指令，该宏就不再有效。如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="meta-keyword">undef</span> BUS_WIDTH</span></span><br></pre></td></tr></table></figure>
<p>遇到该编译指令后，先前的 <code>`define</code> 指令失效。</p>
<h2 id="ifdefelse-和endif">5.3. <code>`ifdef</code>、<code>`else</code> 和<code>`endif</code></h2>
<p>再来看看如下的条件编译指令：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="meta-keyword">ifdef</span> NARROW</span></span><br><span class="line">    <span class="keyword">parameter</span> BUS_WIDTH = <span class="number">16</span>；</span><br><span class="line"><span class="meta">`<span class="meta-keyword">else</span></span></span><br><span class="line">    paramete rBUS_WIDTH = <span class="number">32</span>；</span><br><span class="line"><span class="meta">`<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>在这个条件编译指令中，如果先前已经定义了 <code>NARROW</code> 宏，那么参数 <code>BUS_WIDTH</code> 被设置为 16，否则其被设置为 32。<code>`else</code> 指令对于 <code>`ifdef</code> 来说是可选的，也就是说可以单独使用。</p>
<h2 id="include">5.4. <code>`include</code></h2>
<p>在 Verilog 中，可以使用 <code>`include</code> 指令来嵌入某个文件的内容。例如：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="meta-keyword">include</span> &quot;HEADFILE.h&quot;</span></span><br></pre></td></tr></table></figure>
<p>那么，在编译的时候，就将使用 <code>HEADFILE.h</code> 文件中的内容完全替换这一行语句。而双引号中的文件可以使用相对路径，或绝对路径，或者默认在当前路径以下。</p>
<h2 id="resetall">5.5. <code>`resetall</code></h2>
<p><code>`resetall</code> 编译指令会将所有其他编译指令重新设置为缺省值，要谨慎使用。</p>
<blockquote>
<p>Verilog 语言中的编译指令不止这几条，其他不常用的指令这里不一一介绍，有兴趣可以参考其他文献。</p>
</blockquote>
<h1 id="逻辑值与常量">6. 逻辑值与常量</h1>
<h2 id="逻辑值">6.1. 逻辑值</h2>
<p>在二进制计数中，单位逻辑值只有 <code>1</code> 和 <code>0</code> 两种状态。而在 Verilog 语言中，为了对电路进行精确建模，于是增加了两种逻辑状态 <code>X</code> 和 <code>Z</code>。</p>
<ul>
<li><code>X</code> 表示未知值（unknown），或者不关心（don't care），<code>X</code> 用作信号状态时表示未知，用在条件判断时（在 <code>casex</code> 或 <code>casez</code>中）表示不关心；</li>
<li><code>Z</code> 表示高阻状态，也就是<strong>没有任何驱动</strong>，通常用来对<strong>三态总线</strong>进行建模。</li>
</ul>
<p>在后面将提到 Verilog 语言中的变量类型。通常 <code>net</code> 型变量如果没有初始化，其值为 <code>Z</code>，<code>register</code> 型变量如果没有初始化，其值为 <code>X</code> 。这一点在仿真时显得比较有意义。</p>
<blockquote>
<p>但是，对综合工具而言（或者说在实际电路中），并没有什么 <code>X</code> 值，只存在 <code>0</code>、<code>1</code> 和 <code>Z</code> 这 3 种状态。在实际电路中还可能出现亚稳态，它既不是 <code>0</code>，也不是 <code>1</code>，是一种暂时的不稳定状态。</p>
</blockquote>
<p>Verilog 语言中所有数据都是由以上描述的 4 种基本的逻辑值 <code>0</code>、<code>1</code>、<code>X</code> 和 <code>Z</code> 构成。同时，<code>X</code> 和 <code>Z</code> 是不区分大小写的。例如：<code>0z1x</code> 和 <code>0Z1X</code> 表示同一个数据。</p>
<h2 id="常量">6.2. 常量</h2>
<p>常量是 Verilog 中不变的数值。在上述<a href="#JoshVerilog代码">实例代码</a>中，<code>4'b0001</code> 就表示一个 4 位的二进制整型常量：0001。</p>
<p>Verilog中的常量有3种：</p>
<ul>
<li>整数型；</li>
<li>实数型；</li>
<li>字符串型。</li>
</ul>
<h3 id="整型常量">6.2.1. 整型常量</h3>
<p>可以使用简单的十进制表示一个整型常量，例如：</p>
<ul>
<li><code>16</code> 表示十进制的 16；</li>
<li><code>-15</code> 表示十进制的 -15，用二进制补码表示，至少需要 5 位，即 10001，最高一位为符号位；如果用 6 位表示，则是 110001，同样最高一位为符号位。</li>
</ul>
<p>整数型常量也可以采用基数表示法，例如：</p>
<ul>
<li><code>8'haa</code>：表示 8 位的<strong>十六进制数</strong>，换算成二进制是 1010_1010。</li>
<li><code>6'o33</code>：表示 6 位的<strong>八进制数</strong>，换算成二进制是 011_011。</li>
<li><code>4'b1011</code>：表示 4 位的<strong>二进制数</strong> 1011。</li>
<li><code>3'd7</code>：表示 3 位<strong>十进制</strong>的 7。</li>
</ul>
<p>在基数表示法中，都是以如下格式写的：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">[长度]&#x27;数值符号 数字</span><br></pre></td></tr></table></figure>
<p>其中长度可有可无，数值符号中，<code>h</code> 表示十六进制，<code>o</code> 表示八进制，<code>b</code> 表示二进制，<code>d</code> 表示十进制数据。如果长度比后面数字的实际位数多，则<strong>自动在数字的左边补足 0</strong>；如果位数少，则<strong>自动截断数字左边超出的位数</strong>。</p>
<p>如果将数字写成 <code>'haa</code>，那么这个十六进制数的长度就决定于数字本身的长度。</p>
<p>在基数表示法中，如果遇到 <code>X</code>，十六进制数中表示 4 个 <code>X</code>，八进制数中表示 3 个 <code>X</code>。</p>
<p>另外，数字中的下划线没有任何意义，只是增强可读性。例如：<code>4'b1011</code> 和 <code>4'b10_11</code> 一样。</p>
<h3 id="实数型常量">6.2.2. 实数型常量</h3>
<p>Verilog 语言中的实数型变量可以采用十进制，也可以采用科学计数法，例如：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span><span class="variable">.512</span></span><br><span class="line"><span class="number">13_2</span><span class="variable">.18e2</span>       <span class="comment">// 表示13218</span></span><br></pre></td></tr></table></figure>
<h3 id="字符串型常量">6.2.3. 字符串型常量</h3>
<p>字符串是双引号中的字符序列，例如：<code>"HeIIo World"</code>。字符串是 8 位 ASCII 码值的序列，<code>"HeIIo World"</code> 就需要 11 字节存储，方法如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">reg</span>[<span class="number">1</span>:<span class="number">8</span> * <span class="number">11</span>] Message;</span><br><span class="line">Message = <span class="string">&quot;HeIIo World&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>这样就将字符串常量存入到 Message 变量中。</p>
<h1 id="变量类型">7. 变量类型</h1>
<p>在 Verilog 语言中，有两大变量类型：</p>
<ul>
<li>线网型：表示电路间的物理连线。</li>
<li>寄存器型：Verilog 中的一个抽象的存储数据单元。</li>
</ul>
<p>对于初学者而言，则需要首先遵守如下的简单规则：</p>
<ul>
<li><strong>凡是在</strong> <code>always</code> <strong>或</strong> <code>initial</code> <strong>语句中赋值的变量，一定是寄存器变量</strong>；</li>
<li><strong>在</strong> <code>assign</code> <strong>中赋值的一定是线网变量</strong>。</li>
</ul>
<h2 id="线网类型">7.1. 线网类型</h2>
<p>在线网类型下，分为几种子类，它们具有线网的共性：</p>
<ul>
<li><code>wire</code>、<code>tri</code>：表示电路间连线，<code>tri</code> 主要用于多驱动源建模；</li>
<li><code>wor</code>、<code>trior</code>：表示该连线具有“线或”功能；</li>
<li><code>wand</code>、<code>triand</code>：表示该连线具有“线与”功能；</li>
<li><code>trireg</code>：表示该连线具有总线保持功能；</li>
<li><code>tri1</code>、<code>tri0</code>：表示当无驱动时，连线状态为1（<code>tri1</code>）和0（<code>tri0</code>）；</li>
<li><code>supply1</code>、<code>supply0</code>：分别表示电源和地信号。</li>
</ul>
<p>在以上描述的线网类型中，除了 <code>trireg</code> 未初始化时为 <code>X</code> 以外，其余的未初始化时的值为 <code>Z</code>。</p>
<p>线网类型主要用在连续赋值语句中，以及作为模块之间的互连信号。</p>
<p>在后面的内容中会详细阐述常用线网类型的使用方法。</p>
<h2 id="寄存器类型">7.2. 寄存器类型</h2>
<p>寄存器类型变量在 Verilog 语言中通常表示一个存储数据的空间。尤其是在 Verilog 仿真器中，寄存器类型变量通常占据一个仿真内存空间。</p>
<ul>
<li><code>reg</code>：是最常用的寄存器类型数，可以是 1 位或者多位，或者是二维数组（存储器）；</li>
<li><code>integer</code>：整型数据，存储一个至少 32 位</li>
<li><code>time</code>：时间类型，存储一个至少 64 位的时间值；</li>
<li><code>real</code>，<code>realtime</code>：实数和实数时间寄存器。</li>
</ul>
<h3 id="reg-类型">7.2.1 <code>reg</code> 类型</h3>
<ol type="1">
<li><p>寄存器类型数</p>
<p><code>reg</code> 类型可以定位为一个寄存器，可以定义一位或者多位，例如：</p>
<p><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">reg</span>         AB;             <span class="comment">// 定义一个名为 AB 的 1 位寄存器</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>]   ABC;            <span class="comment">// 定义一个名为 ABC 的 4 位寄存器</span></span><br></pre></td></tr></table></figure></p>
<p>在多位寄存器中，可以作“位选择”或“部分选择”，例如：</p>
<p><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">ABC [<span class="number">3</span>] = <span class="number">1</span>;                <span class="comment">// 将 ABC 的第 3 位赋值为 1</span></span><br><span class="line">ABC [<span class="number">0</span>] = <span class="number">0</span>;                <span class="comment">// 将 ABC 的第 0 位赋为 0</span></span><br><span class="line">ABC [<span class="number">2</span>:<span class="number">1</span>] = <span class="number">2&#x27;b01</span>;          <span class="comment">// 将 ABC 的第 1、2 位赋值为 1 和 0</span></span><br></pre></td></tr></table></figure></p>
<p>这样，整个 <code>ABC</code> 变量的值为 <code>4'b1010</code>。</p></li>
<li><p>寄存器类型数组</p>
<p><code>reg</code> 类型可以作为二维数组，也就是存储器，例如：</p>
<p><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] MEMABC [<span class="number">0</span>:<span class="number">7</span>];     <span class="comment">// 定义一个存储器，地址为 0~7，每个存储单元是 4 位</span></span><br></pre></td></tr></table></figure></p>
<p>与一维的 <code>reg</code> 变量不同的是，存储器中的存储单元不能再做位选择或部分选择，而每个单元可以单独赋值。比如：</p>
<p><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">MEMABC[<span class="number">1</span>] = <span class="number">4&#x27;b0101</span>;        <span class="comment">// 为 MEMABC 中的第 1 个存储单元赋值 4&#x27;b0101</span></span><br></pre></td></tr></table></figure></p>
<p>同时，在 Verilog 中，不存可以对整个存储器赋值的语句，必须对每个单元独立赋值。除非使用 <code>$readmemb</code> 或 <code>$readmemh</code> 系统任务从文件中读入整个或者部分存储器的数据。</p></li>
</ol>
<h3 id="integer-类型">7.2.2. <code>integer</code> 类型</h3>
<p><code>integer</code> 变量通常用于高层次建模，也常用在 <code>for</code> 语句的索引中，例如：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">initial</span></span><br><span class="line"><span class="keyword">begin</span>: ACCESS</span><br><span class="line">    <span class="keyword">integer</span> i;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">7</span>; i = i + <span class="number">1</span> )        <span class="comment">// 定义一个整数变量 i</span></span><br><span class="line">        MEMABC[i] = i                       <span class="comment">// 遍历 0～7 地址</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3 id="其他寄存器类型">7.2.3. 其他寄存器类型</h3>
<p>另外，<code>time</code> 变量用于存储和处理系统时间，<code>real</code> 和 <code>realtime</code> 用来存储实数和实数时间。</p>
<h2 id="变量的物理含义">7.3. 变量的物理含义</h2>
<p>这里需要引起重视，<strong>“线网"变量可以理解为电路模块中的连线，但“寄存器"并不严格对应于电路上的存储单元</strong>，包括触发器（flip-flop）或锁存器（latch）。从纯粹语言表达的语义角度来说，寄存器类型变量的值，从一个赋值到下一个赋值被保存下来，并且在仿真过程中会保持而不会丢失。</p>
<p>实际上，从语义上来讲，在 Verilog 仿真工具对语言进行仿真的时候，<strong>寄存器类型的变量是占用仿真环境的物理内存的</strong>，这与 C 语言中的变量类似。寄存器在被赋值后，便一直保存在内存中，保持该值不变，直到再次对该寄存器变量进行赋值。而<strong>线网类型是不占用仿内存的</strong>，它的值是由当前所有驱动该线网的其他变量（可以是寄存器或线网）决定的。这是寄存器和线网最大的区别，也是当初 Verilog 的发明者定义“线网”和“寄存器”变量的根本动机。</p>
<p>在下一小节中，将引入“驱动”和“赋值”两个概念，深入探讨两种变量的含义。</p>
<h2 id="驱动和赋值">7.4. 驱动和赋值</h2>
<p>为了更清楚地描述寄存器和线网变量的概念，将以上述<a href="#JoshVerilog代码">实例代码</a>中的语句来说明。首先，引入Verilog 语言中两个重要的概念：驱动（Driving）和赋值（Assigning)。</p>
<ul>
<li><strong>线网是被驱动的，该值不被保持，在任意一个仿真步进上都需要重新计算</strong>；</li>
<li><strong>寄存器是被赋值的，且该值在仿真过程中被保持，直到下一个赋值的出现</strong>。</li>
</ul>
<p>在上述<a href="#JoshVerilog代码">实例代码</a>中，定义了一个 <code>A_xor_wire</code> 的 <code>wire</code>，它是 <code>eq0</code> 和 <code>eq1</code> 相异或的结果。采用如下描述方式：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> #<span class="number">1</span> A_xor_wire = eq0 ^ eq1;</span><br></pre></td></tr></table></figure>
<p>实际上，也可以采用如下的另一种描述方式：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @(eq0 <span class="keyword">or</span> eq1)</span><br><span class="line">    A_xor_wire = #<span class="number">1</span> eq0 ^ eq1;</span><br></pre></td></tr></table></figure>
<p>当然需要在 <code>module</code> 的声明处，将 <code>A_xor_wire</code> 首先定义成 <code>reg</code> 变量，而不是 <code>wire</code> 变量，即需要做如下定义：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">reg</span> A_xor_wire</span><br></pre></td></tr></table></figure>
<p>这两者描述的目的一样，都是一个异或门，如下图所示。</p>
<div data-align="center">
<p><img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-28-josh-verilog-part-2/2020-11-28-josh-verilog-part-2-020-XORGate.png!700px"/></p>
</div>
<p>下面从语义上的角度探讨两种描述方式的不同。</p>
<p>第一种描述方式使用 <code>assign</code> 语句，Verilog 中将其称为连续赋值语句（Continously Assignment）实际上是<strong>连续驱动</strong>的过程。也就是说，在任意一个仿真时刻，当前时刻 <code>eq0</code> 和 <code>eq1</code> 相异或的结果决定了 <code>1ns</code> 以后（语句 <code>#1</code> 的延时控制）的线网变量 <code>A_xor_wire</code> 的值，<strong>不管 <code>eq0</code> 和 <code>eq1</code> 变化与否，这个驱动过程一直存在</strong>，因此称为连续驱动。（在仿真器中，线网变量是不占用仿真内存空间的。）如上<a href="#异或门">异或门图</a>中的时序所示，这个驱动过程在任意时刻都存在。</p>
<p>在第二种描述方式中使用了 <code>always</code> 语句，后面紧跟着一个敏感列表：<code>@(eq0 or eq1)</code> 因此，这个语句只有在 <code>eq0</code> 或 <code>eq1</code> 发生变化时才会执行。如上<a href="#异或门">异或门图</a>中，在时刻 2、3 和 6，该语句都将执行，将 <code>eq0</code> 和 <code>eq1</code> 赋值的结果延时 1ns 以后赋值给 <code>A_xor_wire</code> 变量。<strong>在其他时刻，<code>A_xor_wire</code> 变量必须保持</strong>。因此，<strong>从仿真语义上讲，需要一个存储单元，也可以说是寄存器，来保存 <code>A_xor_wire</code> 变量的中间值</strong>。这就是Verilog 语言的“寄存器类型”变量的来历，而这个 <code>A_xor_wire</code> 变量首先需要定义为 <code>reg</code> 类型。</p>
<p>不管采用哪种方式，所描述的是一样的组合逻辑电路。尤其是第二种描述，虽然其在语言中被定义为 reg 型，但并不是对应硬件上的触发器（flip-flop），而是 Verilog 语言仿真语义上的寄存器概念。</p>
<p>但是，在对实际电路中D触发器建模的时候，必须采用 <code>reg</code> 型的变量。下图是 D 触发器的模型。</p>
<div data-align="center">
<p><img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-28-josh-verilog-part-2/2020-11-28-josh-verilog-part-2-030-DFlipFlop.png!300px"/></p>
</div>
<p>在上述<a href="#JoshVerilog代码">实例代码</a>中相应的描述如下：</p>
<figure class="highlight verilog"><figcaption><span>Josh.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n)</span><br><span class="line">    <span class="keyword">if</span> (~rst_n)</span><br><span class="line">        A_xor_out &lt;= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        A_xor_out &lt;= A_xor_wire;</span><br></pre></td></tr></table></figure>
<p>D 触发器只对时钟和复位（置位）敏感，因此在敏感列表中，列出了 <code>clk</code> 的上升沿和 <code>rst_n</code> 的下降沿。如果 <code>rst_n</code> 为 0，就对触发器的输出复位，否则在 <code>clk</code> 的时钟上升沿发生的时候，将输入的 <code>A_xor_wire</code> 寄存到触发器的输出端 <code>A_xor_out</code>。</p>
<p>这样的代码精确地描述了一个 D 触发器的行为。这里的 <code>reg</code> 变量就对应了硬件中的 D 触发器。</p>
<p>在叙述时，为了简单起见，常常将“驱动”和“赋值"都统一说成是赋值，但是一定要清楚其中的本质。</p>
<h1 id="参数">8. 参数</h1>
<p>参数是一种常量，通常出现在 <code>module</code> 内部。它常常被用作定义状态机的状态、数据位宽和延时大小等等。例如：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">parameter</span> and_delay = <span class="number">2</span>；</span><br><span class="line"><span class="keyword">parameter</span> xor_delay = <span class="number">4</span>；</span><br></pre></td></tr></table></figure>
<p><strong>参数的值可以在编译时被改变</strong>，因此它又<strong>经常被用于一些参数可调的模块中</strong>，让用户在实例化模块时，根据需要配置参数。</p>
<p>前面介绍的 <code>`define</code> 是一种全局的定义，而 <code>parameter</code> 是出现在模块内部的<strong>局部定义</strong>，而且可以被<strong>灵活改变</strong>，这是 <code>parameter</code> 的一个重要特征。</p>
<p>在<a href="https://josh-gao.blog.csdn.net/article/details/105262549#42__865">《Part 3——描述方式和设计层次》的 4.2 小节</a>中会详细探讨改变模块参数的方法。</p>
<h1 id="verilog-中的并发与顺序">9. Verilog 中的并发与顺序</h1>
<p>并行概念是硬件中的一个非常重要的概念，特别是初学者或软件工程师们需要重点理解。</p>
<p>与在处理器上运行的软件不同的是，<strong>硬件电路之间的工作是并行的</strong>。</p>
<p>为了描述硬件的并行性，Verilog 语言本身就具有并发的特性。在 Verilog 语言的 <code>module</code> 中，所有的描述语句（包括连续赋值语句，行为语句块：<code>always</code> 和 <code>initial</code>，模块实例化等）之间都是并行发生的。任何功能描述语句，在 Verilog 的 module 中的顺序都不重要。</p>
<p>但是，在语句块（<code>always</code> 和 <code>initial</code>）内部，则可以存在两种语句组：</p>
<ul>
<li><code>begin ... end</code>：顺序语句组；</li>
<li><code>fork ... join</code>：并行语句组。</li>
</ul>
<p>在 <code>begin ... end</code> 中存在的语句，按照 Veilog 的语义，应该是顺序执行的。而在 <code>fork ... join</code> 中的语句，则是并行执行的。</p>
<p>相比较顺序运行的事物，并行的事物比较难以理解和建模。同时，用于仿真的计算机是串行执行的，而 Verilog 语言本身的语义是用计算机进行模拟的语义，是用一种串行的语义来模拟并行的硬件。</p>
<p>Verilog 仿真器用来模拟硬件的并行行为的方式类似于软件中的多任务操作系统，在某个时刻只能执行一个任务，这样，不同的任务之间看起来是并行执行的。</p>
<p>后续将会重点介绍 Verilog 语言中的这一并行特性，同时阐述 Verilog 的高级仿真原理，希望能帮助大家领会 Verilog 的语义精髓。</p>
<h1 id="操作数操作符和表达式">10. 操作数、操作符和表达式</h1>
<h2 id="操作符">10.1. 操作符</h2>
<p>操作符是操作数之间的运算符号。在介绍操作数之前，先来看看 Verilog 中的各种操作符。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">操作符</th>
<th style="text-align: left;">含义</th>
<th style="text-align: left;">操作符</th>
<th style="text-align: left;">含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code>+</code></td>
<td style="text-align: left;">一元加</td>
<td style="text-align: left;"><code>&gt;&gt;</code></td>
<td style="text-align: left;">右移</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>-</code></td>
<td style="text-align: left;">一元减</td>
<td style="text-align: left;"><code>&lt;</code></td>
<td style="text-align: left;">小于</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>!</code></td>
<td style="text-align: left;">一元逻辑非</td>
<td style="text-align: left;"><code>&lt;=</code></td>
<td style="text-align: left;">小于等于</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>~</code></td>
<td style="text-align: left;">一元按位求反</td>
<td style="text-align: left;"><code>&gt;</code></td>
<td style="text-align: left;">大于</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>&amp;</code></td>
<td style="text-align: left;">归约与</td>
<td style="text-align: left;"><code>&gt;=</code></td>
<td style="text-align: left;">大于等于</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>~&amp;</code></td>
<td style="text-align: left;">归约与非</td>
<td style="text-align: left;"><code>==</code></td>
<td style="text-align: left;">逻辑相等</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>^</code></td>
<td style="text-align: left;">归约异或</td>
<td style="text-align: left;"><code>!=</code></td>
<td style="text-align: left;">逻辑不等</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>^~</code> 或 <code>~^</code></td>
<td style="text-align: left;">归约异或非</td>
<td style="text-align: left;"><code>===</code></td>
<td style="text-align: left;">全等</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>|</code></td>
<td style="text-align: left;">归约或</td>
<td style="text-align: left;"><code>!==</code></td>
<td style="text-align: left;">非全等</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>~|</code></td>
<td style="text-align: left;">归约或非</td>
<td style="text-align: left;"><code>&amp;</code></td>
<td style="text-align: left;">按位与</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>*</code></td>
<td style="text-align: left;">乘</td>
<td style="text-align: left;"><code>^</code></td>
<td style="text-align: left;">按位异或</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>/</code></td>
<td style="text-align: left;">除以</td>
<td style="text-align: left;"><code>^~</code> 或 <code>~^</code></td>
<td style="text-align: left;">按位异或非</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>%</code></td>
<td style="text-align: left;">取模</td>
<td style="text-align: left;"><code>|</code></td>
<td style="text-align: left;">按位或</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>+</code></td>
<td style="text-align: left;">二元加</td>
<td style="text-align: left;"><code>&amp;&amp;</code></td>
<td style="text-align: left;">逻辑与</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code>-</code></td>
<td style="text-align: left;">二元减</td>
<td style="text-align: left;"><code>|&gt;|</code></td>
<td style="text-align: left;">逻辑或</td>
</tr>
<tr class="even">
<td style="text-align: left;"><code>&lt;&lt;</code></td>
<td style="text-align: left;">左移</td>
<td style="text-align: left;"><code>? :</code></td>
<td style="text-align: left;">条件操作符</td>
</tr>
</tbody>
</table>
<p>其中，一元操作表示仅有一个操作数，二元操作表示有两个操作数。归约操作也是只有一个操作数，它是该操作数中的所有位之间的计算。</p>
<h3 id="算术操作符">10.1.1. 算术操作符</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">操作符</th>
<th style="text-align: center;">表达式</th>
<th style="text-align: center;">说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>+</code></td>
<td style="text-align: center;"><code>m + n</code></td>
<td style="text-align: center;">将 <code>n</code> 与 <code>m</code> 相加</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>-</code></td>
<td style="text-align: center;"><code>m - n</code></td>
<td style="text-align: center;">将 <code>m</code> 减去 <code>n</code></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>-</code></td>
<td style="text-align: center;"><code>-m</code></td>
<td style="text-align: center;">将 <code>m</code> 取反（二进制补码）</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>*</code></td>
<td style="text-align: center;"><code>m * n</code></td>
<td style="text-align: center;">将 <code>m</code> 与 <code>n</code> 相乘</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>/</code></td>
<td style="text-align: center;"><code>m / n</code></td>
<td style="text-align: center;">将 <code>m</code> 除以 <code>n</code></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>%</code></td>
<td style="text-align: center;"><code>m % n</code></td>
<td style="text-align: center;">对 <code>m / n</code> 求模</td>
</tr>
</tbody>
</table>
<h3 id="按位操作符">10.1.2. 按位操作符</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">操作符</th>
<th style="text-align: center;">表达式</th>
<th style="text-align: center;">说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>~</code></td>
<td style="text-align: center;"><code>~m</code></td>
<td style="text-align: center;">将 <code>m</code> 的每个位取反</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>&amp;</code></td>
<td style="text-align: center;"><code>m &amp; n</code></td>
<td style="text-align: center;">将 <code>m</code> 的每个位与 <code>n</code> 的相应位相与</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>|</code></td>
<td style="text-align: center;"><code>m | n</code></td>
<td style="text-align: center;">将 <code>m</code> 的每个位与 <code>n</code> 的相应位相或</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>^</code></td>
<td style="text-align: center;"><code>m ^ n</code></td>
<td style="text-align: center;">将 <code>m</code> 的每个位与 <code>n</code> 的相应位相异或</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>~^</code><br><code>^~</code></td>
<td style="text-align: center;"><code>m ~^ n</code><br><code>m ^~ n</code></td>
<td style="text-align: center;">将 <code>m</code> 的每个位与 <code>n</code> 的相应位相异或非</td>
</tr>
</tbody>
</table>
<h3 id="归约操作符">10.1.3. 归约操作符</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">操作符</th>
<th style="text-align: center;">表达式</th>
<th style="text-align: center;">说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>&amp;</code></td>
<td style="text-align: center;"><code>&amp;m</code></td>
<td style="text-align: center;">将 <code>m</code> 中的所有位相与（1位结果）</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>~&amp;</code></td>
<td style="text-align: center;"><code>~&amp;m</code></td>
<td style="text-align: center;">将 <code>m</code> 中的所有位相与非（1位结果）</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>|</code></td>
<td style="text-align: center;"><code>|m</code></td>
<td style="text-align: center;">将 <code>m</code> 中的所有位相或（1位结果）</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>~|</code></td>
<td style="text-align: center;"><code>~|m</code></td>
<td style="text-align: center;">将 <code>m</code> 中的所有位或非（1位结果）</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>^</code></td>
<td style="text-align: center;"><code>^m</code></td>
<td style="text-align: center;">将 <code>m</code> 中的所有位异或（1位结果）</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>~^</code><br><code>^~</code></td>
<td style="text-align: center;"><code>~^m</code><br><code>^~m</code></td>
<td style="text-align: center;">将 <code>m</code> 中的所有位相异或非（1位结果）</td>
</tr>
</tbody>
</table>
<h3 id="逻辑操作符">10.1.4. 逻辑操作符</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">操作符</th>
<th style="text-align: center;">表达式</th>
<th style="text-align: center;">说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>!</code></td>
<td style="text-align: center;"><code>!m</code></td>
<td style="text-align: center;"><code>m</code> 是否不为真？（1 位 真/假结果）</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>&amp;&amp;</code></td>
<td style="text-align: center;"><code>m &amp;&amp; n</code></td>
<td style="text-align: center;"><code>m</code> 和 <code>n</code> 是否都为真？（1位 真/假结果）</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>||</code></td>
<td style="text-align: center;"><code>m || n</code></td>
<td style="text-align: center;"><code>m</code> 或 <code>n</code> 是否为真？（1位 真/假结果）</td>
</tr>
</tbody>
</table>
<h3 id="相等操作符">10.1.5. 相等操作符</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">操作符</th>
<th style="text-align: center;">表达式</th>
<th style="text-align: center;">说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>==</code></td>
<td style="text-align: center;"><code>m == n</code></td>
<td style="text-align: center;"><code>m</code> 和 <code>n</code> 相等吗？（1 位 正确/错误结果）</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>!=</code></td>
<td style="text-align: center;"><code>m != n</code></td>
<td style="text-align: center;"><code>m</code> 和 <code>n</code> 不等吗？（1 位 正确/错误结果）</td>
</tr>
</tbody>
</table>
<blockquote>
<p>相等操作符仅比较逻辑 1 和 0。</p>
</blockquote>
<h3 id="全等操作符">10.1.6. 全等操作符</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">操作符</th>
<th style="text-align: center;">表达式</th>
<th style="text-align: center;">说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>===</code></td>
<td style="text-align: center;"><code>m === n</code></td>
<td style="text-align: center;"><code>m</code> 和 <code>n</code> 全等吗？（1 位 正确/错误结果）</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>!==</code></td>
<td style="text-align: center;"><code>m !== n</code></td>
<td style="text-align: center;"><code>m</code> 和 <code>n</code> 不全等吗？（1 位 正确/错误结果）</td>
</tr>
</tbody>
</table>
<h3 id="关系操作符">10.1.7. 关系操作符</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">操作符</th>
<th style="text-align: center;">表达式</th>
<th style="text-align: center;">说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>&lt;</code></td>
<td style="text-align: center;"><code>m &lt; n</code></td>
<td style="text-align: center;"><code>m</code> 小于 <code>n</code> ？（1 位 正确/错误结果）</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>&gt;</code></td>
<td style="text-align: center;"><code>m &gt; n</code></td>
<td style="text-align: center;"><code>m</code> 大于 <code>n</code> ？（1 位 正确/错误结果）</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>&lt;=</code></td>
<td style="text-align: center;"><code>m &lt;= n</code></td>
<td style="text-align: center;"><code>m</code> 小于等于 <code>n</code> ？（1 位 正确/错误结果）</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>&gt;=</code></td>
<td style="text-align: center;"><code>m &gt;= n</code></td>
<td style="text-align: center;"><code>m</code> 大于等于 <code>n</code> ？（1 位 正确/错误结果）</td>
</tr>
</tbody>
</table>
<h3 id="逻辑移位操作符">10.1.8. 逻辑移位操作符</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">操作符</th>
<th style="text-align: center;">表达式</th>
<th style="text-align: center;">说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>&lt;&lt;</code></td>
<td style="text-align: center;"><code>m &lt;&lt; n</code></td>
<td style="text-align: center;">将 <code>m</code> 左移 <code>n</code> 位</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>&gt;&gt;</code></td>
<td style="text-align: center;"><code>m &gt;&gt; n</code></td>
<td style="text-align: center;">将 <code>m</code> 右移 <code>n</code> 位</td>
</tr>
</tbody>
</table>
<h3 id="条件操作符">10.1.9. 条件操作符</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">操作符</th>
<th style="text-align: center;">表达式</th>
<th style="text-align: center;">说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>? :</code></td>
<td style="text-align: center;"><code>sel ? m : n</code></td>
<td style="text-align: center;">如果 <code>sel</code> 为真，选择 <code>m</code>，否则选择 <code>n</code></td>
</tr>
</tbody>
</table>
<h3 id="连接复制操作符">10.1.10. 连接复制操作符</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">操作符</th>
<th style="text-align: center;">表达式</th>
<th style="text-align: center;">说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>&#123; &#125;</code></td>
<td style="text-align: center;"><code>&#123;m,n&#125;</code></td>
<td style="text-align: center;">将 <code>m</code> 和 <code>n</code> 连接起来，产生更大的向量</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>&#123;&#123; &#125;&#125;</code></td>
<td style="text-align: center;"><code>&#123;n&#123;m&#125;&#125;</code></td>
<td style="text-align: center;">将 <code>m</code> 重复 <code>n</code> 次</td>
</tr>
</tbody>
</table>
<p>在以上描述的操作符之间有优先级之分，下表体现了不同的操作数优先级由高到低排列。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">操作符</th>
<th style="text-align: center;">优先级</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>!</code>、<code>~</code>、<code>+</code>、<code>-</code>（一元）</td>
<td style="text-align: center;">最高优先级</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>*</code>、<code>/</code>、<code>%</code></td>
<td style="text-align: center;"><span class="math inline">\(\vdots\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>+</code>、<code>-</code>（二元）</td>
<td style="text-align: center;"><span class="math inline">\(\vdots\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>&lt;&lt;</code>、<code>&gt;&gt;</code></td>
<td style="text-align: center;"><span class="math inline">\(\vdots\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>&lt;</code>、<code>&lt;=</code>、<code>&gt;</code>、<code>&gt;=</code></td>
<td style="text-align: center;"><span class="math inline">\(\vdots\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>==</code>、<code>!=</code>、<code>===</code>、<code>!==</code></td>
<td style="text-align: center;"><span class="math inline">\(\vdots\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>&amp;</code>、<code>~&amp;</code></td>
<td style="text-align: center;"><span class="math inline">\(\vdots\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>^</code>、<code>~^</code></td>
<td style="text-align: center;"><span class="math inline">\(\vdots\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>|</code>、<code>~|</code></td>
<td style="text-align: center;"><span class="math inline">\(\vdots\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>&amp;&amp;</code></td>
<td style="text-align: center;"><span class="math inline">\(\vdots\)</span></td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>||</code></td>
<td style="text-align: center;"><span class="math inline">\(\vdots\)</span></td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>? :</code></td>
<td style="text-align: center;">最低优先级</td>
</tr>
</tbody>
</table>
<blockquote>
<p>例如：<code>A + B &amp; C + D</code> 就表示 <code>(A + B) &amp; (C + D)</code>，而不是 <code>A + (B &amp; C) + D</code>。</p>
</blockquote>
<h2 id="二进制数值">10.2. 二进制数值</h2>
<p>在讨论操作数之前，先来看看二进制数中如何表示有符号数和无符号数。</p>
<p>例如，在一个 6 位二进制整形变量中，</p>
<ul>
<li>无符号数能表示的范围是：<code>0~63</code>；</li>
<li>有符号数采用二进制补码（Two's complement）方式，能表示的范围是：<code>-32～31</code>。其中二进制的最高位表示符号，最高位为 1 表示该数是负数，为 0 表示该数是正数。</li>
</ul>
<p>这里对具体的编码方式不过多介绍，但学过数字电路的同学必须掌握二进制中无符号数和有符号数的表示方法，以及计算的机制。</p>
<h2 id="操作数">10.3. 操作数</h2>
<p>在 Verilog 语言中，操作数可以是如下几种：</p>
<ul>
<li>常数；</li>
<li>参数；</li>
<li>线网；</li>
<li>寄存器；</li>
<li>向量的位选择;</li>
<li>向量的部分选择；</li>
<li>存储器单元；</li>
<li>系统函数或用户自定义函数调用的返回值。</li>
</ul>
<p>在选择操作数时，需要用户尤其注意的是操作数的极性。通常在 Verilog 中，无符号数用以下3种形式存在：</p>
<ul>
<li>线网变量；</li>
<li>一般寄存器变量；</li>
<li>基数格式表示形式的整数常数。</li>
</ul>
<p>而有符号数有：</p>
<ul>
<li>整型寄存器变量；</li>
<li>十进制形式的整型常量。</li>
</ul>
<p>首先讨论常量，如果采用基数格式表示一个数，例如：<code>-4'd12</code>，其二进制表示方式是：<code>1111_1111_1111_1111_1111_1111_1111_0100</code>（<code>1100</code> 的补码），由于基数格式的整数为无符号数，因此<code>-4'd12</code> 的值就是十进制的 <code>429496728</code>。</p>
<p>当采用普通十进制数来表示 <code>-12</code> 的时候，虽然它的二进制表示方式与上面的数相同，但 <code>-12</code> 是一个有符号数，它在运算时就表示十进制的 <code>-12</code>。</p>
<p>这里定义两个变量，一个是无符号的 <code>reg</code> 型，另一个是有符号的整型：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">reg</span> [<span class="number">4</span>:<span class="number">0</span>] Opreg;            <span class="comment">// 一个 5 位的 reg 型，存储无符号数</span></span><br><span class="line"><span class="keyword">integer</span> Opint;              <span class="comment">// 一个 32 位的 integer 型，存储有符号数</span></span><br></pre></td></tr></table></figure>
<p>做如下运算：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">Opreg = -<span class="number">4</span>d&#x27;<span class="number">12</span>/<span class="number">4</span>;           <span class="comment">// Opreg 被赋值 29，(-4d&#x27;12/4)的最低5位</span></span><br><span class="line">Opint = -<span class="number">4</span>d&#x27;<span class="number">12</span>/<span class="number">4</span>;           <span class="comment">// Opint 被赋值为 1073741821，共 32 位</span></span><br><span class="line">Opreg = -<span class="number">12</span>/<span class="number">4</span>;              <span class="comment">// Opreg 被赋值29，(-12/4)的最低5位</span></span><br><span class="line">Opint = -<span class="number">12</span>/<span class="number">4</span>;              <span class="comment">// Opint 被赋值为 -3，采用 32 位的二进制补码表示方式</span></span><br></pre></td></tr></table></figure>
<p>通过以上的计算结果可以看出，无符号数和有符号数的算术运算非常不同，用户在设计常量和变量并用它们计算的时候，一定要搞清楚它们中哪些表示有符号数，哪些表示无符号数，这很重要。</p>
<h1 id="系统任务和系统函数">11. 系统任务和系统函数</h1>
<p>在 Verilog 语中，预先定义了一些任务和函数，用于完成一些特殊的功能，它们被称为系统任务和系统函数。Verilog 能提供的系统任务和系统函数类型如下：</p>
<ul>
<li>显示任务（display task）；</li>
<li>文件输入/输出任务（file I/O task）；</li>
<li>时间标度任务（timescale task）；</li>
<li>拟控制任务（simulation control task）；</li>
<li>时序验证任务（timing check task）；</li>
<li>PLA建模任务（PLA modeling task）；</li>
<li>机建模任务（stochastic modeling task）；</li>
<li>实数变换函数（conversion functions for real）；</li>
<li>概率分布数（probabilistic distribution function)。</li>
</ul>
<p>由于 Verilog 的系统任务和函数种类很多，在这里，只重点介绍一些常用的内容，希望通过介绍可以能让大家迅速掌握，灵活使用。相信通过以下的介绍，大家可以举一反三，通过参考 Verilog 的语法文献，迅速查找到需要的系统任务和函数，完成需要的功能。</p>
<h2 id="显示任务">11.1. 显示任务</h2>
<p><code>$display</code> 是显示任务，通常用来显示变量值、字符串，以及仿真时间等信息。</p>
<p>在 <a href="#JoshVerilog代码">JoshVerilog 模块</a>中使用了这样的系统任务。</p>
<figure class="highlight verilog"><figcaption><span>Josh.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="built_in">$display</span> (<span class="string">&quot;At time %t-&quot;</span>, <span class="built_in">$time</span>, <span class="string">&quot;eq0 = 1&quot;</span>);     <span class="comment">// 显示时间</span></span><br></pre></td></tr></table></figure>
<p>其中，双引号中的是字符串，<code>％t</code> 是时间格式。<code>$time</code> 是产生模拟时间的系统函数，它的返回值显示在字符串中的 <code>％t</code> 位置。</p>
<p>再如：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="built_in">$display</span>(<span class="string">&quot;The value of ABC is %d&quot;</span>, ABC);        <span class="comment">// 显示当前 ABC 变量的值</span></span><br></pre></td></tr></table></figure>
<p>其中，<code>%d</code> 表示十进制数。<code>ABC</code> 的值显示在字符串中的 <code>%d</code> 位置。</p>
<h2 id="文件输入出任务">11.2. 文件输入出任务</h2>
<p>系统函数 <code>$fopen</code> 用于打开一个文件，并返回一个整数的文件指针。然后，<code>$fdisplay</code> 就可以使用这个文件指针向文件中写入信息。写完后，则可以使用 <code>$fclose</code> 这个系统关闭这个文件。例如：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span> Write_Out_File;                     <span class="comment">// 定义一个文件指针</span></span><br><span class="line">Write_Out_File = <span class="built_in">$fopen</span>(<span class="string">&quot;Write_Out_File.txt&quot;</span>);</span><br><span class="line"><span class="built_in">$fdisplay</span>(Write_Out_File, <span class="string">&quot;@ %h\n%h&quot;</span>, Mpi_addr, Data_in);</span><br><span class="line"><span class="built_in">$fclose</span>(Write_Out_File);</span><br></pre></td></tr></table></figure>
<p>以上的语法，将 <code>Mpi_addr</code> 和 <code>Data_in</code> 分别显示在 <code>@ %h\n%h</code> 中两个 <code>%h</code> 的位置，写入 <code>Write_Out_File</code> 指针所指的文件 <code>Write_Out_File.txt</code> 中。</p>
<p>用户可以通过 <code>$readmemb</code> 或者 <code>$readmemh</code> 来从文件中读入数据，但是这个文件中的数据格式是一定的。例如：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] DataSource [<span class="number">0</span>:<span class="number">47</span>];</span><br><span class="line"><span class="built_in">$readmemh</span> (<span class="string">&quot;Read_In_File.txt, DataSource);</span></span><br></pre></td></tr></table></figure>
<p>就是将 <code>Read_In_FiIe</code> 文件中数据读入到 <code>DataSource</code> 数组中，然后就可以直接使用。</p>
<p><code>Read_In_File</code> 数据文件的格式，可以参考如下写法：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">@<span class="number">2</span>f</span><br><span class="line"><span class="number">24</span></span><br><span class="line">@<span class="number">2</span>e</span><br><span class="line"><span class="number">81</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>其中，<code>@2f</code> 表示地址，是十六进制；<code>24</code> 表示该地址的数据，以此类推。</p>
<h2 id="其他系统任务和数">11.3. 其他系统任务和数</h2>
<ol type="1">
<li><p>仿真控制任务</p>
<p>Verilog 中有一些仿真控制任务，例如： <code>$finish</code> 表示使仿真器退出。 <code>$stop</code> 使仿真挂起。</p></li>
<li><p>时序验证任务和仿真时间函数</p>
<p>Verilog 仿真器也可以检查设计时序，以及返回当前仿真时间，例如： <code>$setup</code> 系统任务用来检查建立时间。 <code>$hold</code> 系统任务用来检查保持时间。 <code>$time</code> 系统函数用来返回一个64位的模拟时间。</p></li>
<li><p>概率分布函数</p>
<p><code>$random</code> 系统函数可以用来返回一个32位的有符号整型随机数。</p></li>
</ol>
<p>需要注意的是，<strong>系统任务/函数只可以在 Verilog 仿真器中运行，仅仅对代码仿真有意义</strong>，综合和布线工具将忽略所有的系统任务和函数。</p>
<p>除了系统任务和系统函数之外，VeriIog还允许用户自己定义任务和函数。关于自定义的任务和函数的特点及使用方法，请参考后续的相关内容。</p>
<hr />
<p>在本篇笔记中，以一个实例为出发点，系统介绍了 Verilog 的基本语法，相信能为大家深入学习 Verilog 语言打下坚实的基础。</p>
]]></content>
      <categories>
        <category>Verilog</category>
        <category>Josh 的学习笔记</category>
        <category>Verilog</category>
        <category>Verilog 语法</category>
      </categories>
      <tags>
        <tag>Verilog</tag>
        <tag>HDL</tag>
        <tag>自顶向下</tag>
        <tag>自底向上</tag>
        <tag>Verilog 语法</tag>
      </tags>
  </entry>
  <entry>
    <title>Josh 的学习笔记之 Verilog（Part 3 —— 描述方式和设计层次）</title>
    <url>/posts/fd117896.html</url>
    <content><![CDATA[<p>Verilog 语言可以用多种方式来描述硬件，同时，使用这些描述方式又可以在多个抽象层次上设计硬件。这是 Verilog 语言的重要特征。本文主要侧重于阐述 Verilog 语言的描述方法和设计层次。</p>
<h1 id="描述方式">1. 描述方式</h1>
<p>在<a href="https://josh-gao.top/posts/fd2ca242.html#3-%E7%A7%8D%E6%8F%8F%E8%BF%B0%E6%96%B9%E6%B3%95">《Part 2 —— Verilog 语言基础》</a>中己经介绍过，Verilog 语言有 3 种最基本的描述方式．</p>
<ul>
<li>数据流描述，采用 <code>assign</code> 连续赋值语句；</li>
<li>行为描述，使用 <code>always</code> 语句或 <code>initial</code> 语句块中的过程赋值语句；</li>
<li>结构化描述，实例化已有的功能模块或原语。</li>
</ul>
<p>下面分别说明这几种描述方式。</p>
<a id="more"></a>
<h1 id="数据流描述">2. 数据流描述</h1>
<h2 id="数据流">2.1. 数据流</h2>
<p>在数字电路中，信号经过组合逻辑时有点类似于数据的流动：信号从输入流向输出，而信号不会在其中存储。当输入发生变化时，总会在一定时间以后体现在输出端。</p>
<p>同样，可以模拟数字电路的这一特性，对其进行建模。通常将这种建模方式称为数据流建模。</p>
<p>数据流描述最基本的语句是 <code>assign</code> 连续赋值语句。</p>
<h2 id="连续赋值语句">2.2. 连续赋值语句</h2>
<div data-align="center">
<p><img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-30-josh-verilog-part-3/2020-11-30-josh-verilog-part-3-010-XORGate.png!sign"/></p>
</div>
<p>上图中的电路模型可以用如下的语句来描述：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> #<span class="number">1</span> A_xor_wire = eq0 ^ eq1;</span><br></pre></td></tr></table></figure>
<p>在任意一个时刻，<code>A_xor_wire</code> 线网的值是由 <code>eq0</code> 和 <code>eq1</code> 决定的，也可以说是由它们驱动的。</p>
<h3 id="连续赋值语句的特点">2.2.1. 连续赋值语句的特点</h3>
<ol type="1">
<li><p><strong>连续驱动</strong></p>
<p>在 <a href="https://josh-gao.top/posts/fd2ca242.html#%E5%AF%84%E5%AD%98%E5%99%A8%E7%B1%BB%E5%9E%8B">Part 2 的 7.2 驱动和赋值</a>部分，已经解释了驱动和赋值之间的微妙区别。</p>
<p>连续赋值语句是连续驱动的。也就是说，任何时刻输入的任何变化都将导致该语句的重新计算。</p></li>
<li><p><strong>只有线网类型能在 <code>assign</code> 中赋值</strong></p>
<p>由于仿真器中不会存储连续赋值语句中被赋值的变量值，因此该变量是线网类型（Net），不能是寄存器类型。需要记住，只有线网类型的变量才可以在 <code>assign</code> 语句中被赋值。</p>
<p>另外，线网类型的变量可以被多重驱动，也就是说，可以在多个连续赋值语句中驱动同一个线网。在<a href="#drive">2.4 驱动源线网</a>中将进一步介绍。但是，寄存器变量就不同了，它不能被不同的行为进程（例如 <code>always</code> 语句块）驱动。</p></li>
<li><p><strong>使用 <code>assign</code> 对组合逻辑建模</strong></p>
<p>通常建议使用 <code>assign</code> 对组合逻辑建模。因为 <code>assign</code> 语句的连续驱动特点与组合逻辑的行为非常相似。而且，在 <code>assign</code> 语句中加延时可以非常精确的模拟组合逻辑的惯性延时。</p></li>
<li><p><strong>并行性</strong></p>
<p><code>assign</code> 语句和行为语句块（<code>always</code> 和 <code>initial</code>)、其他连续赋值语句、门级模型之间是并行的。一个连续赋值语句是一个独立的进程，进程之间是并发，同时也是交织的。</p></li>
</ol>
<h3 id="实例">2.2.2. 实例</h3>
<div data-align="center">
<p><img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-30-josh-verilog-part-3/2020-11-30-josh-verilog-part-3-020-FullAdder.png!sign"/></p>
</div>
<p>在上中，用两个半加器和一个或门组成一个全加器，这里将使用连续赋值语句描述这个电路。代码如下。</p>
<p><a name="半加器代码"></a></p>
<figure class="highlight verilog"><figcaption><span>HalfAdd.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> HalfAdd(X, Y, sum, C_out);</span><br><span class="line"></span><br><span class="line"><span class="comment">// IO端口声明</span></span><br><span class="line"><span class="keyword">input</span> X;</span><br><span class="line"><span class="keyword">input</span> Y;</span><br><span class="line"><span class="keyword">output</span> sum;</span><br><span class="line"><span class="keyword">output</span> C_out;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> sum = X ^ Y;</span><br><span class="line"><span class="keyword">assign</span> C_out = X &amp; Y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span> </span><br></pre></td></tr></table></figure>
<figure class="highlight verilog"><figcaption><span>FullAdd.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> FullAdd(X, Y, C_in, sum, C_out);</span><br><span class="line"></span><br><span class="line"><span class="comment">// IO端口声明</span></span><br><span class="line"><span class="keyword">input</span> X;</span><br><span class="line"><span class="keyword">input</span> Y;</span><br><span class="line"><span class="keyword">input</span> C_in;</span><br><span class="line"><span class="keyword">output</span> sum;</span><br><span class="line"><span class="keyword">output</span> C_out;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线网类型用于连接</span></span><br><span class="line"><span class="keyword">wire</span> HalfAdd_A_sum;</span><br><span class="line"><span class="keyword">wire</span> HalfAdd_A_Cout;</span><br><span class="line"><span class="keyword">wire</span> HalfAdd_B_Cout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> C_out = HalfAdd_A_Cout | HalfAdd_B_Cout;</span><br><span class="line"></span><br><span class="line">HalfAdd u_HalfAdd_A(</span><br><span class="line">    <span class="variable">.X</span>      (C_in),</span><br><span class="line">    <span class="variable">.Y</span>      (Y),</span><br><span class="line">    <span class="variable">.s</span>      (HalfAdd_A_sum),</span><br><span class="line">    <span class="variable">.C_out</span>  (HalfAdd_A_Cout)</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">HalfAdd u_HalfAdd_B(</span><br><span class="line">    <span class="variable">.X</span>      (C_in),</span><br><span class="line">    <span class="variable">.Y</span>      (HalfAdd_A_sum),</span><br><span class="line">    <span class="variable">.s</span>      (sum),</span><br><span class="line">    <span class="variable">.C_out</span>  (HalfAdd_B_Cout)</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line"><span class="keyword">endmodule</span> </span><br></pre></td></tr></table></figure>
<p>在 <code>HalfAdd</code> 模块中，两个 <code>assign</code> 语句之间是<strong>完全并行独立执行</strong>的，它们的顺序与逻辑功能无关。同样，<code>FullAdd</code> 模块中，两个 <code>HalfAdd</code> 的实例和或门的 <code>assign</code> 语句之间的关系也是独立的。</p>
<h2 id="延时">2.3. 延时</h2>
<p>在连续赋值语句中，可以对电路的延时进行建模。当然，也可以没有延时。比如：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> #<span class="number">1</span> A_xor_wire = eq0 ^ eq1;           <span class="comment">// `timescale 1ns/1ns</span></span><br></pre></td></tr></table></figure>
<p>这个语句就表示该异或门的延时为 <code>1ns</code>，也就是说，输入端信号变化到输出端体现出来需要 <code>1ns</code> 的时间。</p>
<p>这里是比较笼统的延时模型。实际上，电路对不同的信号跳变表现出的延时往往并不一致。这些延时模型包括：</p>
<ul>
<li>上升沿延时（输出变为 1）；</li>
<li>下降沿延时（输出变为 0）；</li>
<li>关闭延时（输出变成 <code>Z</code>，高阻态）；</li>
<li>输出变成 <code>X</code> 的延时。</li>
</ul>
<p>用户可以分别描述这几种延时，比如：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> <span class="variable">#(1,2)</span> A_xor_wire = eq0 ^ eq1;</span><br><span class="line"><span class="keyword">assign</span> <span class="variable">#(1,2,3)</span> A_xor <span class="keyword">wire</span> = eq0 ^ eq1;</span><br></pre></td></tr></table></figure>
<p>第一句表示，上升延时 <code>1ns</code>，下降延时 <code>2ns</code>，关闭延时和传递到 <code>X</code> 的延时为两者中最小的，即 <code>1ns</code>。</p>
<p>第二句表示，上升延时 <code>1ns</code>，下降延时 <code>2ns</code>，关闭延时为 <code>3ns</code>，传递到 <code>X</code> 的延时取1、2、3中最小的 <code>1ns</code>。</p>
<p>在一些电路模型中，延时分为最大、典型和最小3种情况。连续赋值语句中的延时也可以采用 <code>min:typ:max</code> 的格式来表示。例如：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> <span class="variable">#(4:5:6, 3:4:5)</span> A_xor_wire = eq0 ^ eq1;</span><br></pre></td></tr></table></figure>
<p>表示上升延时的 <code>min:typ:max</code> 为 <code>4:5:6</code>，下降延时的 <code>min:typ:max</code> 为 <code>3:4:5</code>。</p>
<p>需要注意的是，在连续赋值语句中的延时具有硬件电路中惯性延时的特性。也就是说，<strong>任何小于其延时的信号变化脉冲将被滤除掉，不会体现在输出端口上</strong>。关于这部分内容会在后续详细描述。</p>
<p>另外，<code>assign</code> 语句中的延时特性通常是被逻辑综合工具忽略的。因为综合工具要将 Verilog 语言模型综合成逻辑电路，而逻辑电路的延时是由基本的单元库和走线延时决定的。用户无法对逻辑单元指定延时，但是，用户可以在综合和实现工具中加时序约束，让工具尽量满足设计的时序要求。</p>
<h2 id="驱动源线网">2.4. 驱动源线网<a name="drive"></a></h2>
<p>下面分为几种线网类型来描述当线网具有多重驱动源时的情况。</p>
<h3 id="多重驱动-wire错误">2.4.1. 多重驱动 <code>wire</code>（错误）</h3>
<figure class="highlight verilog"><figcaption><span>WS.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> WS (A, B, C, D, WireShort)；</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span> A, B, C, D;</span><br><span class="line"><span class="keyword">output</span> WireShort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">wire</span> WireShort;         <span class="comment">//显式定义为wire类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> WireShort = A ^ B；</span><br><span class="line"><span class="keyword">assign</span> WireShort = C &amp; D；</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>在以上代码中，由于 <code>WireShort</code> 为 <code>wire</code> 类型，同时它有多重驱动源，因此仿真时 <code>WireShort</code> 的值将是 <code>X</code>，也就是不定态。</p>
<h3 id="线或线与功能">2.4.2. 线或、线与功能</h3>
<p>可以使用 <code>wor</code> 线网类型来将不同的输出“线或”在一起，如下：</p>
<figure class="highlight verilog"><figcaption><span>// WO.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> WO (A, B, C, D, WireOr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span> A, B, C, D;</span><br><span class="line"><span class="keyword">output</span> WireOr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">wor</span> WireOr;             <span class="comment">// 显式定义为 wor 类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> WireOr = A ^ B;</span><br><span class="line"><span class="keyword">assign</span> WireOr = C &amp; D;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>逻辑综合以后，它具体对应的逻辑电路如下图所示。</p>
<div data-align="center">
<p><img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-30-josh-verilog-part-3/2020-11-30-josh-verilog-part-3-030-WireOr.png!700px"/></p>
</div>
<p>同样，可以使用 <code>wand</code> 线网类型来将不同的输出“线与”在一起，如下：</p>
<figure class="highlight verilog"><figcaption><span>WA.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> WA (A, B, C, D, WireAnd);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span> A, B, C, D;</span><br><span class="line"><span class="keyword">output</span> WireAnd;</span><br><span class="line"></span><br><span class="line"><span class="keyword">wand</span> WireAnd;           <span class="comment">// 显式定义为 wand 类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> WireAnd = A ^ B;</span><br><span class="line"><span class="keyword">assign</span> WireAnd = C &amp; D;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>它对应的逻辑电路如下图所示。</p>
<div data-align="center">
<p><img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-30-josh-verilog-part-3/2020-11-30-josh-verilog-part-3-040-WireAnd.png!700px"/></p>
</div>
<h3 id="三态总线功能">2.4.3. 三态总线功能</h3>
<p>如果要实现多个三态总线相连，可以采用 <code>tri</code> 型线网：</p>
<figure class="highlight verilog"><figcaption><span>WT.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> WT (A, B, C, D, WireTri, en1_n, en2_n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span> A, B, C, D, en1_n, en2_n;</span><br><span class="line"><span class="keyword">output</span> WireTri;</span><br><span class="line"></span><br><span class="line"><span class="keyword">tri</span> WireTri;            <span class="comment">// 显式定义为 tri 类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> WireTri = (en1_n) ? <span class="number">1&#x27;bz</span> : (A ^ B);</span><br><span class="line"><span class="keyword">assign</span> WireTri = (en2_n) ? <span class="number">1&#x27;bz</span> : (C &amp; D);</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>其实现的电路如下图所示。</p>
<div data-align="center">
<p><img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-30-josh-verilog-part-3/2020-11-30-josh-verilog-part-3-050-WireTri.png!700px"/></p>
</div>
<h1 id="行为描述">3. 行为描述<a name="03"><a></h1>
<p>在 <a href="https://josh-gao.top/posts/fd2ca242.html#3-%E7%A7%8D%E6%8F%8F%E8%BF%B0%E6%96%B9%E6%B3%95">Part 2</a> 中介绍过行为描述的概念。所谓行为描述，是指用语言描述电路的行为。行为描述的语句有两种：<code>initial</code> 和 <code>always</code> 语句。</p>
<h2 id="行为描述的语句格式">3.1. 行为描述的语句格式</h2>
<p><code>initial</code> 和 <code>always</code> 的后面一般跟语句或语句组（statement group)。语句可以是：非阻塞过程赋值、阻塞过程赋值、连续过程赋值或高级编程语句。在以后会一一介绍。</p>
<h3 id="initial-或-always-过程块procedual-block">3.1.1. <code>initial</code> 或 <code>always</code> 过程块（procedual block）</h3>
<p><code>initial</code> 语句在 0 仿真时间执行，而且只执行一次；<code>always</code> 语句同样在 0 仿真时间开始执行，但是它将一直循环执行。这样的特点单单从它们的命名上就能看得出来：一个是 <code>initial</code>，就是初始化一次的意思；另一个是 <code>always</code>，就是总在运行的意思。</p>
<p>下面利用 <code>initial</code> 和 <code>always</code> 语句各自的特点，产生一个时钟发生器的模型。</p>
<figure class="highlight verilog"><figcaption><span>ClkGen.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">`<span class="meta-keyword">timescale</span> 1ns/1ns</span></span><br><span class="line"><span class="keyword">module</span> ClkGen (clk);</span><br><span class="line"></span><br><span class="line"><span class="keyword">output</span> clk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span> clk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span>             <span class="comment">// 将 clk 初始化为 0</span></span><br><span class="line">    clk = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span>              <span class="comment">// 每 5ns 将 clk 翻转一次</span></span><br><span class="line">    #<span class="number">5</span> clk = ~clk;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>在 0 时刻，<code>initial</code> 和 <code>always</code> 语句同时执行，顺序随机。假设先运行 <code>initial</code> 语句，那么 <code>clk</code> 变量被赋值为 0，这时 <code>initial</code> 语句进程将永远被挂起，再也不会执行。</p>
<p>然后，开始运行 <code>always</code> 语句。该 <code>always</code> 语句每隔 <code>5ns</code> 将 <code>clk</code> 信号翻转一次，一直不停地运行，这样就产生了一个周期是 <code>10ns</code> 的时钟信号。</p>
<blockquote>
<p>在以上代码中，0 时刻，<code>initial</code> 和 <code>always</code> 语句同时执行，顺序随机，这样就存在一个冲突的问题。假设先执行的是 <code>always</code> 语句， <code>clk</code> 就不会被初始化为 0。</p>
</blockquote>
<h3 id="过程块中的语句种类">3.1.2. 过程块中的语句种类</h3>
<p>在 <code>initial</code> 和 <code>always</code> 过程块中可以直接跟语句或者语句组。直接跟的语句可以是非阻塞过程赋值、阻塞过程赋值、连续过程赋值或高级编程语句。语句组可以是：<code>begin ... end</code> 和 <code>fork ... join</code> 两种。</p>
<p>语句组中可以有其他几种语句类型，而高级编程语句中也可以有语句组，它们可以互相嵌套，完成非常复杂的逻辑功能描述。</p>
<p>下面是 <code>always</code> 过程块中直接跟阻塞赋值语句：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span>              <span class="comment">// 每 5ns 将 clk 翻转一次</span></span><br><span class="line">    #<span class="number">5</span> clk = ~clk;</span><br></pre></td></tr></table></figure>
<p>下面的代码描述了语句组和高级编程语句的互相嵌套：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) </span><br><span class="line"><span class="keyword">begin</span>                               <span class="comment">// 语句组</span></span><br><span class="line">    <span class="keyword">if</span> (~rst_n)                     <span class="comment">// 高级编程语句</span></span><br><span class="line">    <span class="keyword">begin</span>                           <span class="comment">// 语句组</span></span><br><span class="line">        reg_A &lt;= <span class="number">0</span>;                 <span class="comment">// 非阻塞赋值语句</span></span><br><span class="line">        reg_B &lt;= <span class="number">0</span>;                 <span class="comment">// 非阻塞赋值语句</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span>                            <span class="comment">// 高级编程语句</span></span><br><span class="line">    <span class="keyword">begin</span>                           <span class="comment">// 语句组</span></span><br><span class="line">        reg_A &lt;= input_A;           <span class="comment">// 非阻塞赋值语句</span></span><br><span class="line">        reg_B &lt;= input_B;           <span class="comment">// 非阻塞赋值语句</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>从上例中可以看出，高级编程语句里面可以嵌套过程赋值语句，或者其他高级编程语句。</p>
<h3 id="时序控制timing-control">3.1.3. 时序控制（Timing Control）</h3>
<p>在行为描述中，有几种方式对设计模型进行时序控制，它们是：</p>
<ul>
<li>事件语句（<code>@</code>）；</li>
<li>延时语句（<code>#</code>）；</li>
<li>等待语句。</li>
</ul>
<p>当执行 <code>initial</code> 或 <code>always</code> 语句块时遇到一个事件语句（<code>@</code>）、延时语句（<code>#</code>），或其表达式值为假（false）的等待语句时，语句块（或称为进程）的执行将被挂起（suspended)。直到发生该事件，或者已经过了指定延迟的时间单位数，或者等待语句表达式变为真（ture）时，才重新执行 <code>initial</code> 或 <code>always</code> 语句块。这个过程就是时序控制。Verilog 的行为描述中，正是利用这几种时序控制语句来实现各种各样的逻辑功能。</p>
<h4 id="事件语句的用法">3.1.3.1. 事件语句（<code>@</code>）的用法</h4>
<div data-align="center">
<p><img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-30-josh-verilog-part-3/2020-11-30-josh-verilog-part-3-060-DFlipFlop.png!600px"/></p>
</div>
<p>要实现上图中这样一个 D 触发器，通常用以下代码：</p>
<figure class="highlight verilog"><figcaption><span>TYP_DFF.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> TYP_DFF (clk, D, Q);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span> clk, D;</span><br><span class="line"><span class="keyword">output</span> Q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span> Q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">    Q &lt;= D;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>在 0 仿真时刻，<code>always</code> 语句块开始执行。当遇到 <code>@ (posedge clk)</code> 语句时，该进程被挂起。等待 <code>clk</code> 的上升沿到来，才重新激活该进程。当 <code>clk</code> 的上升沿出现后，将 <code>D</code> 的值赋给 <code>Q</code>，<code>always</code> 语句块执行完成。</p>
<p>由于 <code>always</code> 语句的特点，<code>always</code> 语句马上开始重新执行，当遇到 <code>@ (posedge clk)</code> 语句时，进程再一次挂起，等待 <code>clk</code> 的上升沿到来，才继续往下执行。</p>
<p>这样，在 <code>always</code> 语句中使用 <code>@</code> 事件语句很好地模拟了触发器的行为。综合工具会马上将上述代码映射成上图中的 D 触发器。</p>
<p>同样的道理，采用如下的代码也可以得到一样的 D 触发器功能：</p>
<figure class="highlight verilog"><figcaption><span>TYP_DFF.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> TYP_DFF (clk, D, Q);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span> clk, D;</span><br><span class="line"><span class="keyword">output</span> Q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span> Q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> <span class="keyword">begin</span></span><br><span class="line">    @(<span class="keyword">posedge</span> clk)</span><br><span class="line">    Q &lt;= D;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>当有多个条件语句时，一般将它们用 <code>or</code> 分隔开。例如，要实现一个带异步复位端的 D 触发器可以采用如下代码：</p>
<figure class="highlight verilog"><figcaption><span>TYP_DFF.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> TYP_DFF (clk, D, Q, rst);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span> clk, D, rst;</span><br><span class="line"><span class="keyword">output</span> Q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span> Q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">posedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (rst)</span><br><span class="line">        Q &lt;= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        Q &lt;= D;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>当出现 <code>clk</code> 或 <code>rst</code> 的下降沿时，才会触发 <code>always</code> 语句。</p>
<h4 id="延时语句的用法">3.1.3.2. 延时语句（<code>#</code>）的用法</h4>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span>              <span class="comment">// 每 5ns 将 clk 翻转一次</span></span><br><span class="line">    #<span class="number">5</span> clk = ~clk;</span><br></pre></td></tr></table></figure>
<p>这里 <code>always</code> 的语句开始执行时，马上遇到 <code>#5</code>，<code>always</code> 语句块挂起。直到 <code>5ns</code> 以后才恢复执行，这时将 <code>clk</code> 取反。当再次执行 <code>always</code> 时，动作与上一次完全一致。这里，模拟了一个周期为 <code>10ns</code> 的时钟。</p>
<p>当然，这种写法一般用于仿真激励的产生，仅仅用于仿真。由于综合工具会将延时语句 <code>#5</code> 忽略，所以如上的代码无法综合成一个 <code>10ns</code> 周期的时钟发生器电路。</p>
<p>以下代码利用延时语句产生一个复位信号：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    rst_n =<span class="number">1</span>;</span><br><span class="line">    #<span class="number">5</span> rst_n = <span class="number">0</span>;</span><br><span class="line">    #<span class="number">100</span> rst_n=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>当以上 <code>initial</code> 语句开始运行时，首先将 <code>rst_n</code> 赋值为 <code>1</code>。当遇到 <code>#5</code> 时，该 <code>initial</code> 的执行过程被暂时挂起，等待 <code>5ns</code> 后恢复执行，<code>rst_n</code> 被置 <code>0</code>，处于复位状态。然后，遇到 <code>#100</code>，等待 <code>100ns</code> 以后再恢复执行，<code>rst_n</code> 被置为 <code>1</code>。这时，<code>initial</code> 语句块被永远挂起，再也不会执行。于是，就产生了一个 <code>100ns</code> 的复位信号。</p>
<h4 id="等待语句的用法">3.1.3.3. 等待语句的用法</h4>
<p>下面分析一下等待语句如何做时序控制：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> MY_LATCH (Strobe, D, Q);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span> Strobe, D;</span><br><span class="line"><span class="keyword">output</span> Q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span> Q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">wait</span> (Strobe == <span class="number">1</span>);</span><br><span class="line">    Q = D;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>该语句表示，当 <code>always</code> 语句开始执行后，遇到 <code>wait()</code> 语句，如果括号内的变量不为真，则该进程被挂起，直到 <code>(Strobe == 1)</code> 为真，<code>always</code> 才继续往下执行，将 <code>D</code> 的值赋值给 <code>Q</code>，这样就模拟了一个电平敏感的锁存器。</p>
<p>要注意的是，目前多数综合工具还不支持 <code>wait</code> 语句，因此这个锁存器的功能只能在仿真时用，不能实现为具体的电路。</p>
<h2 id="过程赋值语句">3.2. 过程赋值语句</h2>
<p>所谓过程赋值语句就是在 <code>initial</code> 和 <code>always</code> 语句块中的赋值语句。赋值对象只能是寄存器变量类型。右边的表达式可以是任意操作符的表达式。</p>
<h3 id="阻塞赋值">3.2.1. 阻塞赋值</h3>
<p>阻塞赋值的语法如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">寄存器变量 = 表达式;</span><br></pre></td></tr></table></figure>
<p>所谓“阻塞赋值”，实际上有两层含义：</p>
<ol type="1">
<li><p>右边表达式的计算和对左边寄存器变量的赋值是一个统一的原子操作中的两个动作。<strong>这两个动作之间不能插入任何其他的动作</strong>。</p></li>
<li><p>如果多个阻塞赋值语句顺序出现在 <code>begin. .. end</code> 语句中，<strong>前面的语句在执行时，将完全阻塞后面的语句，直到前面语句的赋值完成以后，才会执行下一句的右边表达式计算</strong>。例如 <code>begin m = n; n = m; end</code> 语句中，当 <code>m</code> 被完全赋值以后，再开始执行 <code>n=m</code>，将 <code>m</code> 的新值赋给 <code>n</code>。这样执行的结果就是的初始值不变，而且与 <code>n</code> 相等。</p></li>
</ol>
<p>由于阻塞賦值的这一特点，通常会建议在对组合逻辑建模的时候，采用阻塞賦值，先看一段代码：</p>
<p><a name="一个组合逻辑"></a></p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">wire</span> A_in, B_in, C_in;</span><br><span class="line"><span class="keyword">reg</span> Temp, D_out;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">always</span> @(A_in <span class="keyword">or</span> B_in <span class="keyword">or</span> C_in) <span class="keyword">begin</span></span><br><span class="line">    Temp = A_in &amp; B_in;             <span class="comment">// 阻塞赋值</span></span><br><span class="line">    D_out = Temp | C_in;            <span class="comment">// 阻塞赋值</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>设计者的根本目的是得到如下图所示的电路。</p>
<div data-align="center">
<p><img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-30-josh-verilog-part-3/2020-11-30-josh-verilog-part-3-070-ACombinationalLogic.png!700px"/></p>
</div>
<p>在以上代码仿真时，正是利用了阻塞赋值的这一特点才模拟了该组合逻辑的行为。</p>
<p>首先，任何一个输入发生变化，<code>D_out</code> 必然发生变化。因此，在 <code>always</code> 的敏感列表中，包括 <code>A_in</code>，<code>B_in</code> 和 <code>C_in</code>。在内部计算时，首先将 <code>A_in</code> 和 <code>B_in</code> 相与，得到一个中间结果 <code>Temp</code>。等 <code>Temp</code> 被完全赋值后，才开始执行下一个语句：将 <code>Temp</code> 的新值与 <code>C_in</code> 相或，得到 <code>D_out</code> 的值。我们也许可以感受到，这个 <code>always</code> 语句非常精确地模拟了上图中电路的行为。</p>
<p>另外，有一点会使得初学者产生较大的疑问。为什么 Verilog 规定只有寄存器（register）类型的变量才能够在过程赋值语句中被赋值呢？有时候在Verilog中定义的寄存器变量，在综合时并不一定映射成一个实在的触发器硬件。比如在以上的例子中，<code>Temp</code> 和 <code>D_out</code> 被定义成 <code>reg</code> 变量，而综合结果它们却还是组合逻辑，并不是存储单元。</p>
<p>在 Verilog 语言中，寄存器变量的特点是需要在仿真运行器件上保持它的值，也就是说，这个变量在仿真时需要占据内存空间。</p>
<p>在以上的 <code>always</code> 实例中，<code>always</code> 语句块只对 <code>A_in</code> 等 3 个输入变化敏感。如果没有这 3 个变量的变化事件，<code>Temp</code> 和 <code>D_out</code> 变量将需要保存其值，因此它们必须被定义为寄存器类型变量。但是，它们在综合之后，并不对应硬件锁存器或者触发器。</p>
<h3 id="非阻塞赋值">3.2.2. 非阻塞赋值</h3>
<p>非阻寒赋值的语法如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">寄存器变量 &lt;= 表达式;</span><br></pre></td></tr></table></figure>
<p>它的特点是在执行该语句时，首先计算右边的表达式，然后并不立刻对左边的变量赋值。由于这个赋值操作在当前仿真时间事件队列中的优先级比较低，因此<strong>将赋值推迟到当前仿真时刻的后期运行</strong>。关于具体非阻塞赋值的右式计算和左式更新是何时完成的，请参考后续内容。</p>
<p>与阻塞赋值不同的是，如果多个非阻塞赋值语句顺序出现在 <code>begin ... end</code> 语句中，前面语句的执行，并不会阻塞后面语句的执行。前面语句的计算完成，还没有赋值时，就会执行下一句的右边表达式计算。例如 <code>begin m &lt;= n; n &lt;= m; end</code> 语句中，最后的结果是将m与n值互换了。</p>
<p>如果想要采用如下代码来描述<a href="#一个组合逻辑">前述组合逻辑电路</a>的功能：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">wire</span> A_in, B_in, C_in;</span><br><span class="line"><span class="keyword">reg</span> Temp, D_out;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">always</span> @(A_in <span class="keyword">or</span> B_in <span class="keyword">or</span> C_in) <span class="keyword">begin</span></span><br><span class="line">    Temp &lt;= A_in &amp; B_in;            <span class="comment">// 非阻塞赋值</span></span><br><span class="line">    D_out &lt;= Temp | C_in;           <span class="comment">// 非阻塞赋值</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>如果使用仿真工具去仿真这段代码，就会发现它的功能并不是所想要的功能。比如当 <code>A_in</code> 发生变化，执行 <code>always</code> 语句，其中 <code>Temp &lt;= A_in &amp; B_in;</code> 这句话并没有立刻对 <code>Temp</code> 赋值，而是放在当前仿真时刻的后期才开始执行 <code>Temp</code> 的更新。这样，当执行 <code>D_out &lt;=Temp | C_in;</code> 表达式的右式计算事件时，<code>Temp</code> 的值还是 旧的值，因此这时 <code>D_out</code> 并不会发生变化。</p>
<p>大家也许可以尝试将如上的代码用综合工具综合一下，可能同样会得到<a href="#一个组合逻辑">前述组合逻辑电路</a>的情况。这是由于一些综合工具可以容忍用户的这些代码缺陷。这就造成了 RTL 仿真和综合的结果不一致的现象。</p>
<p>为什么会造成这个现象呢？因为 RTL 的仿真器严格按照 Verilog 的仿真语义执行 RTL 的仿真过程，而综合工具通常只是根据用户的代码推断设计者的意图，然后生成相应的电路结构。因此，综合的过程有一定的主观推断性，并不严格遵守 Verilog 的语义，不同的综合工具判决标准也不一样。</p>
<p>这种情况是每一个设计都应该尽量避免的，因为仿真和综合结果不一致说明源代码中很可能有隐患，不符合 Verilog 的语义，会错过许多 bug，增加设计的不稳定性。</p>
<p>所以保证仿真器和综合器都能正确理解设计的代码，是非常关键的。</p>
<p><strong>通常利用非阻塞赋值的特点来对时序逻辑进行建模。</strong></p>
<p>代码如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">    q1 &lt;= d;</span><br><span class="line">    q2 &lt;= q1;</span><br><span class="line">    q3 &lt;= q2;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>其实现结果如下图：</p>
<div data-align="center">
<p><img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-30-josh-verilog-part-3/2020-11-30-josh-verilog-part-3-080-ThreeFlowStateRegister.png!sign"/></p>
</div>
<p>正是利用了语句之间的非阻塞性，才实现了这个 3 级流水线的逻辑功能。</p>
<h3 id="过程连续赋值">3.2.3. 过程连续赋值</h3>
<p>在 Verilog 语言中，还有一种过程赋值语句叫做“过程连续赋值”，它们也是出现在 <code>always</code> 和 <code>initial</code> 语句块中的。</p>
<p>过程连续赋值主要有两种：</p>
<ul>
<li><code>assign</code> 与 <code>deassign</code>：在过程语句块中对寄存器变量强制赋值和放开；</li>
<li><code>force</code> 与 <code>release</code>：在过程语句块中对寄存器和线网进行强制赋值和放开。</li>
</ul>
<p>例如，在下面的代码实例中用 <code>assign</code> 和 <code>deassign</code> 描述了一个带异步清零端的 D 触发器。</p>
<figure class="highlight verilog"><figcaption><span>DEF.V</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> DEF(D, clr, clk, Q);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span> D, clr, clk;</span><br><span class="line"><span class="keyword">output</span> Q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span> Q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(clr) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!clr)</span><br><span class="line">        <span class="keyword">assign</span> Q = <span class="number">0</span>;       <span class="comment">// D 的值对 Q 无效, 将 Q 强制为 0</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">deassign</span> Q;         <span class="comment">// 将强制的 Q 值放开</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">negedge</span> clk)</span><br><span class="line">    Q = D;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>这里不再对过程连续赋值进行过多阐述，有兴趣可以参考其他文献。</p>
<h2 id="语句组">3.3. 语句组</h2>
<p>语句组是两条以上语句的组合，它们看起来像一个独立的语句。语句组也是出现在 <code>initial</code> 和 <code>always</code> 的过程块中的。</p>
<p>根据其中语句的执行顺序，语句组可以分为“顺序语句组"和“并行语句组”两种。</p>
<h3 id="顺序语句组-begin-...-end">3.3.1. 顺序语句组 <code>begin ... end</code></h3>
<p>在顺序语句组中，其中的语句是一条一条顺序执行的。比如下面的语句：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @(A_in <span class="keyword">or</span> B_in <span class="keyword">or</span> C_in) <span class="keyword">begin</span></span><br><span class="line">    Temp = A_in &amp; B_in;                 <span class="comment">// 阻塞赋值</span></span><br><span class="line">    D_out = Temp | C_in;                <span class="comment">// 阻塞赋值</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>首先执行第一句，将 <code>A_in</code> 和 <code>B_in</code> 相与，然后将结果赋给 <code>Temp</code> 变量；再执行第一句，将新的 <code>Temp</code> 值 <code>C_in</code> 相或，结果立刻赋给 <code>D_out</code>。</p>
<p>当然，这里是同时利用了 <code>begin ... end</code> 语句组和阻塞赋值的特点，才实现了用户想要的逻辑功能。</p>
<p>再比如要产生一个值序列：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">initial</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    DataBin = <span class="number">0</span>;</span><br><span class="line">    #<span class="number">6</span> DataBin = <span class="number">0</span>;</span><br><span class="line">    #<span class="number">4</span> DataBin = <span class="number">1</span>;</span><br><span class="line">    #<span class="number">2</span> DataBin = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>由于语句是顺序执行的，产生的波形如下图所示。</p>
<div data-align="center">
<p><img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-30-josh-verilog-part-3/2020-11-30-josh-verilog-part-3-090-SequentialWave.png!500px"/></p>
</div>
<h3 id="并行语句组-fork-...-join">3.3.2. 并行语句组 <code>fork ... join</code></h3>
<p>在<code>fork ... join</code> 语句组中，语句是并行执行的。将上一小节的代码改写如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">initial</span></span><br><span class="line"><span class="keyword">fork</span></span><br><span class="line">    DataBin = <span class="number">0</span>;</span><br><span class="line">    #<span class="number">6</span> DataBin = <span class="number">0</span>;</span><br><span class="line">    #<span class="number">4</span> DataBin = <span class="number">1</span>;</span><br><span class="line">    #<span class="number">2</span> DataBin = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">join</span></span><br></pre></td></tr></table></figure>
<p>由于其中的所有语句并行执行，也就是以上 4 条语句都是从 0 时刻开始同时执行的，产生的波形如下图。</p>
<div data-align="center">
<p><img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-30-josh-verilog-part-3/2020-11-30-josh-verilog-part-3-100-ParallelWave.png!500px"/></p>
</div>
<h3 id="语句组的标识符">3.3.3. 语句组的标识符</h3>
<p>语句组可以有标识符，也可以没有。</p>
<p>当一个语句组有标识符时，在语句组内部可以定义局部变量，而不会传递到语句组的外部。然而，在仿真语义上，这个变量是静态变量，它的值在整个仿真运行周期中是不变的，但是不会与其他语句组中同一个名称的变量发生冲突。例如：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span> i;              <span class="comment">// always 语句以外的 i 变量</span></span><br><span class="line"><span class="keyword">always</span> @(...)</span><br><span class="line"><span class="keyword">begin</span>: SORT</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">integer</span> i;          <span class="comment">// 语句组内部的土变量</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>;i &lt;= <span class="number">7</span>; i = i + <span class="number">1</span>)</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>在 <code>always</code> 以外的i变量和 <code>always</code> 里面定义的i变量属于<strong>两个不同的变量，并不冲突</strong>。它们在仿真的时候将占用两块不同的内存，类似于 C 语言中的静态局部变量。</p>
<h2 id="高级编程语旬">3.4. 高级编程语旬</h2>
<h3 id="为什么需要编程语句">3.4.1. 为什么需要编程语句</h3>
<p>Verilog 作为硬件描述语言，最重要的特性就是其设计层次比较高，不仅停留在晶体管级和门级，而是可以在更高的层次如 RTL 级甚至是行为级描述硬件系统的行为，或者编写测试激励。</p>
<p>为了达到提高描述能力、提高抽象层次，Verilog 语言从 C 语言等编程语言中借鉴了一语句，同时也创造了一些语句，例如 <code>if</code>、<code>case</code>、<code>while</code>、<code>for</code>、<code>repeat</code> 和 <code>forever</code> 等。这些语句被称为高级编程语句。有了这些语句 Verilog 才可以描述比较复杂的电路行为。</p>
<p>编程语句只能出现在 <code>initial</code> 和 <code>always</code> 的过程块中。编程语句中可以嵌套其他的语句，比如过程赋值语句或者其他编程语句。</p>
<p>高级编程语分为3大类：</p>
<ul>
<li><code>if ... else</code> 语句；</li>
<li>case语句；</li>
<li>循环语句：<code>forever</code>、<code>repeat</code>、<code>while</code>、<code>for</code>。</li>
</ul>
<p>下面将逐一介绍。</p>
<h3 id="if-...-else-语句">3.4.2. <code>if ... else</code> 语句</h3>
<p><code>if</code> 语句后面跟语句或语句组（<code>begin ... end</code> 或 <code>fork ... join</code>)。常和 <code>else</code> 搭配来实现不同条件的各种情况。<code>if</code> 也可以单独使用，没有 <code>else</code> 配合。</p>
<p>现考虑以下代码：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @(sel_a <span class="keyword">or</span> sel_b <span class="keyword">or</span> a <span class="keyword">or</span> b <span class="keyword">or</span> c) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (sel_a)</span><br><span class="line">        q = a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (sel_b)</span><br><span class="line">        q = b;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        q = c;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>它要实现的逻辑如下图。</p>
<div data-align="center">
<p><img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-30-josh-verilog-part-3/2020-11-30-josh-verilog-part-3-110-IfElseStatement.png!600px"/></p>
</div>
<p>在 <code>if ... else</code> 语句中，条件是从上到下逐条检查的。因此，当满足一个条件时，就执行其后的语句，跳过 <code>else</code> 后面的语句、当所有条件都不满足，便执行最后一条 <code>else</code> 后面的语句。因此 <code>if ... else</code> 语句实际上是有优先级顺序的。</p>
<p>实际在上例中使用了 <code>if ... else</code> 优先级编码的特点，<code>sel_a</code> 的判断优先级最高，因此在逻辑中的级数要明显少一些，参考上图。如果 <code>sel_a</code> 为关键路径的话，就可以利用这样的优先级编码提高设计的性能。</p>
<p>在使用 <code>if ... else</code> 语句时，<strong>尤其是用在组合逻辑中，需要注意不要引入 Latch 电路</strong>。先来看如下的代码：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @(sel <span class="keyword">or</span> a <span class="keyword">or</span> b <span class="keyword">or</span> c) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (sel == <span class="number">2&#x27;b00</span>)</span><br><span class="line">        q = a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (sel == <span class="number">2&#x27;b01</span>)</span><br><span class="line">        q = b;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (sel == <span class="number">2&#x27;b10</span>)</span><br><span class="line">        q = c;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>由于，最后一个条件 <code>sel == 2'b11</code> 的语句没有被显式地写出，言下之意是，当 <code>sel</code> 为 <code>2'b11</code> 时，<code>q</code> 值需要保持不变。这个代码在综合时自然就会产生锁存器，如下图。</p>
<div data-align="center">
<p><img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-30-josh-verilog-part-3/2020-11-30-josh-verilog-part-3-120-CombinationalLogicwithLatch.png!800px"/></p>
</div>
<p><strong>锁存器在数字同步逻辑设计中应该尽量避免。因为锁存器容易引起竞争冒险，同时静态时序分析工具也不好分析穿过锁存器的路径。</strong></p>
<p>在下面的代码中，己经明确写出：当 <code>se</code> 为 <code>2'b11</code> 时，<code>q</code> 值不关心，赋值为 <code>x</code>。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @(sel <span class="keyword">or</span> a <span class="keyword">or</span> b <span class="keyword">or</span> c) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (sel == <span class="number">2&#x27;b00</span>)</span><br><span class="line">        q = a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (sel == <span class="number">2&#x27;b01</span>)</span><br><span class="line">        q = b;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (sel == <span class="number">2&#x27;b10</span>)</span><br><span class="line">        q = c;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        q = <span class="number">1&#x27;bx</span>;       <span class="comment">// 当 sel 为 2&#x27;b11 时, q 值不关心</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>既然不关心 <code>sel</code> 为 <code>2'b11</code> 时 <code>q</code> 的值，那么有的综合工具就顺手将 <code>sel</code> 等于 <code>2'b11</code> 时 <code>q</code> 的值也赋值为 <code>c</code>，这样就避免了锁存器的产生。实现电路如下图。</p>
<div data-align="center">
<p><img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-30-josh-verilog-part-3/2020-11-30-josh-verilog-part-3-130-CombinationalLogicwithoutLatch.png!sign"/></p>
</div>
<p><span id="无锁存器的组合逻辑电路"></span></p>
<p>然而，在描述时序逻辑时，通常将利用 <code>if</code> 语句的隐式条件对带时钟使能的 D 触发器建模。代码如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_n) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (~rst_n)</span><br><span class="line">        sum &lt;= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (en)</span><br><span class="line">        sum &lt;= a + b;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>以上语句表示在时钟正沿来临时，如果 <code>en</code> 为 1，则将 <code>a + b</code> 的值付给 <code>sum</code>。言下之意：如果 <code>en</code> 为 0，那么 <code>sum</code> 保持原值不变。因此，这里综合工具会把代码综合成一个时钟使能的寄存器，如图3一14所示。</p>
<div data-align="center">
<p><img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-30-josh-verilog-part-3/2020-11-30-josh-verilog-part-3-140-DFlipFlopClock.png!800px"/></p>
</div>
<p>其中，<code>en</code> 信号时 D 触发器的时钟使能端，<code>rst_n</code> 是 D 触发器的异步清零信号。</p>
<h3 id="case-语句">3.4.3. <code>case</code> 语句</h3>
<p><code>case</code> 语句的功能同正一类似，但是又有很大的不同。它后面也可以跟语句或语句组（<code>begin ... end</code> 或 <code>fork ... join</code>）。</p>
<p>如下例：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @(sel <span class="keyword">or</span> a <span class="keyword">or</span> b <span class="keyword">or</span> c) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">case</span>(sel)</span><br><span class="line">        <span class="number">2&#x27;b00</span>: q = a;</span><br><span class="line">        <span class="number">2&#x27;b01</span>: q = b;</span><br><span class="line">        <span class="number">2&#x27;b10</span>: q = c;</span><br><span class="line">        <span class="keyword">default</span>: q = <span class="number">1&#x27;bx</span>；</span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>在 <code>case</code> 语句中，<code>default:</code> 一条描述了所有没有明确说明的其他可能情况。比如，这里的 <code>default</code> 就包含了 <code>sel</code> 为 <code>2'b11</code>、<code>2'bzz</code> 和 <code>2'bxx</code> 等情况。</p>
<p>以上的代码将实现如上的<a href="#无锁存器的组合逻辑电路">无锁存器的组合逻辑电路</a>。</p>
<p>与 <code>if ... else</code> 语句不同的是，在 <code>case</code> 语句中，所有被判断的分支条件都具有一样的优先级。</p>
<p>与 <code>if ... else</code> 类似的是，语句同样需要考虑所有可能的情况，否则将会产生不想要的锁存器。如果将代码改为：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always</span> @(sel <span class="keyword">or</span> a <span class="keyword">or</span> b <span class="keyword">or</span> c) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">case</span>(sel)</span><br><span class="line">        <span class="number">2&#x27;b00</span>: q = a;</span><br><span class="line">        <span class="number">2&#x27;b01</span>: q = b;</span><br><span class="line">        <span class="number">2&#x27;b10</span>: q = c;</span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>这样，将会产生与如上的<a href="#带锁存器的组合逻辑电路">带锁存器的组合逻辑电路</a>。这是设计者不愿意看到的。</p>
<p>对于 <code>case</code> 语句，有两个派生语句，即 <code>casez</code> 及 <code>casex</code>。</p>
<p><code>casez</code> 语句将分支条件中所有的 <code>z</code> 看作“不关心"的值，而不看作任何逻辑值。条件中的 <code>z</code> 可以改写为 <code>?</code>，如下例：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">casez</span> (encoder)</span><br><span class="line">    <span class="number">4&#x27;b1</span>???: hign_lvl = <span class="number">3</span>;</span><br><span class="line">    <span class="number">4&#x27;b01</span>??: hign_lvl = <span class="number">2</span>;</span><br><span class="line">    <span class="number">4&#x27;b001</span>?: hign_lvl = <span class="number">1</span>;</span><br><span class="line">    <span class="number">4&#x27;b0001</span>: high_lvl = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">default</span>: high_lvl = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">endcase</span></span><br></pre></td></tr></table></figure>
<p>这里，如果 <code>encoder</code> 为 <code>4b'1zzz</code> 则 <code>high_lvl</code> 取值为 3。</p>
<p><code>casex</code> 语句将分支条件中所有的x和z看作“不关心”的值，而不看作任何逻辑值。如下例：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">casex</span> (encoder)</span><br><span class="line">    <span class="number">4&#x27;b1xxx</span>: hign_lvl = <span class="number">3</span>;</span><br><span class="line">    <span class="number">4&#x27;b01xx</span>: hign_lvl = <span class="number">2</span>;</span><br><span class="line">    <span class="number">4&#x27;b001x</span>: hign_lvl = <span class="number">1</span>;</span><br><span class="line">    <span class="number">4&#x27;b0001</span>: high_lvl = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">default</span>: high_lvl = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">endcase</span></span><br></pre></td></tr></table></figure>
<p>这里，如果 <code>encoder</code> 为 <code>4'b1xzx</code>，则 <code>high-lvl</code> 取值为 3。</p>
<h3 id="循环语句">3.4.4. 循环语句</h3>
<p>循环语句一般用于重复的操作。</p>
<p>循环语句后面可以跟语句或语句组（<code>begin ... end</code> 或 <code>fork ... join</code>)。</p>
<ol type="1">
<li><p><code>forever</code> 循环：永远执行</p>
<p><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    clk = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">forever</span> #<span class="number">25</span> clk = ~clk;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p>
<p>以上语句产生了一个周期为 50 个时间单位的时钟。</p></li>
<li><p><code>repeat</code> 循环：执行固定的次数</p>
<p><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (rotate == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">repeat</span> (<span class="number">8</span>)</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        tmp = data[<span class="number">15</span>];</span><br><span class="line">        data = &#123;data&lt;&lt;<span class="number">1</span>, temp&#125;;</span><br><span class="line">    <span class="keyword">end</span></span><br></pre></td></tr></table></figure></p>
<p>以上语句中，当为 1 时，重复对 <code>data</code> 数据做8次循环左移。</p></li>
<li><p><code>while</code> 循环：当表达式为真时执行</p>
<p><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (count &lt; <span class="number">101</span>) <span class="keyword">begin</span></span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;Count = %d&quot;</span>, count);</span><br><span class="line">        count = count + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p>
<p>在 <code>while</code> 语句中，只要后面的条件满足，就持续执行该语句，直到条件不满足，跳出循环。这里，将 <code>count</code> 从 0 递增到 101，逐步打印出来。</p></li>
<li><p><code>for</code> 循环：从初始值开始，如果表达式为真就执行</p>
<p><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">integer</span> i;          <span class="comment">// 为 for 循环声明索引</span></span><br><span class="line"><span class="keyword">always</span> @(inp <span class="keyword">or</span> cnt) <span class="keyword">begin</span></span><br><span class="line">    result[<span class="number">7</span>:<span class="number">4</span>] = <span class="number">0</span>;</span><br><span class="line">    result[<span class="number">3</span>:<span class="number">0</span>] = inp;</span><br><span class="line">    <span class="keyword">if</span> (cnt == <span class="number">1</span>) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">4</span>; i &lt;= <span class="number">7</span>; i = i + <span class="number">1</span>)</span><br><span class="line">            result[i] = result[i-<span class="number">4</span>];</span><br><span class="line">        result[<span class="number">3</span>:<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p>
<p><code>for</code> 语句开始执行直到 <code>i</code> 大于 7，跳出循环。如上代码实现了一个位的左移器。</p></li>
</ol>
<p>简单介绍了 Verilog 中的高级编程语句，只要对 C 语言有一定基础，就能迅速掌握其中的用法。</p>
<h1 id="结构化描述">4. 结构化描述</h1>
<p>结构化描述就是在设计中<strong>实例化已有的功能模块</strong>，这些功能模块包括：门原语、用户自定义原语（UDP）、其他模块（module）。以下是结构化描述的3种实例类型：实例化其他模块、实例化门及实例化UDP。</p>
<p>下例是由两个半加器组成的全加器的模型，其中所有模块都采用了结构化描述方法。</p>
<figure class="highlight verilog"><figcaption><span>HalfAdd.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> HalfAdd(X, Y, sum, C_out);                   <span class="comment">// 半加器模块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span> X;</span><br><span class="line"><span class="keyword">input</span> Y;</span><br><span class="line"><span class="keyword">output</span> sum;</span><br><span class="line"><span class="keyword">output</span> C_out;</span><br><span class="line"></span><br><span class="line"><span class="comment">// assign sum = X ^ Y;</span></span><br><span class="line"><span class="comment">// assign C_out = X &amp; Y;</span></span><br><span class="line"><span class="keyword">xor</span> u_xor(sum, X, Y);                               <span class="comment">// 门级原语实例</span></span><br><span class="line"><span class="keyword">and</span> u_and(C_out, X, Y);                             <span class="comment">// 门级原语实例</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span> </span><br></pre></td></tr></table></figure>
<figure class="highlight verilog"><figcaption><span>FullAdd.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> FullAdd(X, Y, C_in, sum, C_out);             <span class="comment">// 全加器模块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span> X;</span><br><span class="line"><span class="keyword">input</span> Y;</span><br><span class="line"><span class="keyword">input</span> C_in;</span><br><span class="line"><span class="keyword">output</span> sum;</span><br><span class="line"><span class="keyword">output</span> C_out;</span><br><span class="line"></span><br><span class="line"><span class="keyword">wire</span> HalfAdd_A_sum;</span><br><span class="line"><span class="keyword">wire</span> HalfAdd_A_Cout;</span><br><span class="line"><span class="keyword">wire</span> HalfAdd_B_Cout;</span><br><span class="line"></span><br><span class="line"><span class="comment">// assign C_out = HalfAdd_A_Cout | HalfAdd_B_Cout;</span></span><br><span class="line"><span class="keyword">or</span> u_or(C_out, HalfAdd_A_Cout, HalfAdd_B_Cout);     <span class="comment">// 门级原语实例</span></span><br><span class="line"></span><br><span class="line">HalfAdd u_HalfAdd_A(                                <span class="comment">// 半加器实例 A</span></span><br><span class="line">    <span class="variable">.X</span>      (C_in),</span><br><span class="line">    <span class="variable">.Y</span>      (Y),</span><br><span class="line">    <span class="variable">.sum</span>    (HalfAdd_A_sum),</span><br><span class="line">    <span class="variable">.C_out</span>  (HalfAdd_A_Cout)</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">HalfAdd u_HalfAdd_B(                                <span class="comment">// 半加器实例 B</span></span><br><span class="line">    <span class="variable">.X</span>      (C_in),</span><br><span class="line">    <span class="variable">.Y</span>      (HalfAdd_A_sum),</span><br><span class="line">    <span class="variable">.sum</span>    (sum),</span><br><span class="line">    <span class="variable">.C_out</span>  (HalfAdd_B_Cout)</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line"><span class="keyword">endmodule</span> </span><br></pre></td></tr></table></figure>
<p>上例已将<a href="#半加器代码">原半加器代码</a>中的语句改为门原语的实例化。在全加器的模块中，有两个半加器模块的实例和一个 <code>or</code> 门原语的实例。</p>
<p>在以上代码中，实例化的 <code>or</code> 门原语是 Verilog 语言自带的电路，实例化的半加器模块则是用户自己设计的模块。</p>
<p>实现电路如下图。</p>
<div data-align="center">
<p><img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-30-josh-verilog-part-3/2020-11-30-josh-verilog-part-3-150-FullAdder.png!sign"/></p>
</div>
<p>以上内容提到了实例化基本门和其他模块。</p>
<p>关于 UDP，它是用户自定义的原语，由于应用不广泛，其功能基本上可以由模块替代，因此不再介绍。</p>
<h2 id="实例化模块的方法">4.1. 实例化模块的方法</h2>
<p>在结构化描述中，需要将模块实例与外部信号相连接。下面谈谈模块实例的端口连接规则。</p>
<p>先看一个模块内部输入/输出/双向端口的内部属性：</p>
<ul>
<li><strong><code>input</code>：在模块内部默认是一个线网类型；</strong></li>
<li><strong><code>output</code>：在模块内部是一个寄存器（在过程赋值语句中被赋值）或者线网类型；</strong></li>
<li><strong><code>inout</code>：在模块内部默认是一个线网类型，是双向信号，一般定义为 <code>tri</code>。</strong></li>
</ul>
<p>当这个模块被实例化时，与之相连的信号类型如下：</p>
<ul>
<li><strong>与模块 <code>input</code> 端口相连：可以是一个线网或者寄存器；</strong></li>
<li><strong>与模块 <code>output</code> 端口相连：一定是驱动到一个线网；</strong></li>
<li><strong>与模块 <code>inout</code> 端口相连：输入时从一个线网驱动来，输出时驱动到一个线网。</strong></li>
</ul>
<p>初学者经常犯这样一个错误，将寄存器变量驱动 <code>inout</code> 端口，导致编译出错。因为，只有线网类型可以驱动 <code>inout</code> 端口。</p>
<p>下图清楚地了模块端口在内部和外部的类型。</p>
<div data-align="center">
<p><img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-30-josh-verilog-part-3/2020-11-30-josh-verilog-part-3-160-ModuleConnection.png!sign"/></p>
</div>
<p>下面举例说明模块内部和外部的端口：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">HalfAdd u_HalfAdd_A(                                <span class="comment">// 半加器实例 A</span></span><br><span class="line">    <span class="variable">.X</span>      (C_in),</span><br><span class="line">    <span class="variable">.Y</span>      (Y),</span><br><span class="line">    <span class="variable">.sum</span>    (HalfAdd_A_sum),</span><br><span class="line">    <span class="variable">.C_out</span>  (HalfAdd_A_Cout)</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>
<p>点 <code>.</code> 后面紧跟的信号是 <code>HalfAdd</code> 内的端口名称，而括号中的信号是上一层 <code>FullAdd</code> 模块中的驱动源或被驱动信号。</p>
<p>模块实例的端口对应方式有以下两种：名称对应及位置对应。</p>
<p>所谓名称对应是指：将模块实例外部的信号直接对应于模块的端口名称。在实例化 <code>HalfAdd</code> 时就是采用了名称对应的方法。</p>
<p>在这种端口对应方式下，端口对应的顺序可以是任意的。在没有对应外部信号的时候，可以将端口后面的括号留空。如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">模块 实例名称(</span><br><span class="line">    .模块端口名称           (实例外部信号),</span><br><span class="line">    .模块端口名称           (实例外部信号),</span><br><span class="line">    .模块端口名称           (),             <span class="comment">//无对应信号</span></span><br><span class="line">    ...);</span><br></pre></td></tr></table></figure>
<p>位置对应方式就是在模块实例化的时候外部的信号需要按照该模块端口声明的顺序一一对应。例如：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> HalfAdd(X, Y, sum, C_out);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>在实例化该模块的时候，可以使用：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">HaIfAdd u_HalfAdd(E_X, E_Y, E_sum, E_C_out);</span><br></pre></td></tr></table></figure>
<p>其中 <code>E_X</code>、<code>E_Y</code>、<code>E_sum</code> 和 <code>E_C_out</code> 分别对应 <code>HalfAdd</code> 的端口 <code>X</code>、<code>Y</code>、<code>sum</code> 和 <code>C_out</code>，严格按照<code>HalfAdd</code> 模块的端口位置顺序。如果在没有对应外部信号的时候，就需要将位置留空。例如：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">HaIfAdd u_HalfAdd(E_X, E_Y, , E_C_out);</span><br></pre></td></tr></table></figure>
<p>其中 <code>E_X</code>、<code>E_Y</code> 和 <code>E_C_out</code> 分别对应 <code>HaIfAdd</code> 的端口 <code>X</code>、<code>Y</code> 和 <code>C_out</code>，模块端口 <code>sum</code> 没有对应的外部信号。</p>
<h2 id="参数">4.2. 参数</h2>
<p>在本小节中将讨论可参数化的模块。</p>
<h3 id="参数定义">4.2.1. 参数定义</h3>
<p><code>module</code> 中的参数一般是定义其中常量的工具。</p>
<p>如下的代码中定义了半加器的“与门”和“异或门"的延时分别为 2 和 4 个时间单位：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> half_adder(co, sum, a, b)</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span> a, b;</span><br><span class="line"><span class="keyword">output</span> co, sum;</span><br><span class="line"></span><br><span class="line"><span class="keyword">parameter</span> and_delay = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">parameter</span> xor_delay = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">and</span> #and_delay u1(co, a, b);</span><br><span class="line"><span class="keyword">xor</span> #xor_delay u2(sum, a, b);</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>实际上，在 Verilog 语言中，<strong>当实例化模块时用户可以修改模块中的参数</strong>，用来实现不同的特性。这个定制过程是通过“新参数直接带入”或“参数重定义”完成的。</p>
<p>Verilog 模块参数的这一特性非常有用，用户可以定义一个通用的模块，其具有缺省的参数值，然后通过改变参数来做成不同的实例模块。</p>
<p>例如，可以设计一个通用的 RAM 模块，将其位宽和地址深度定义为参数。在具体使用时，如果需要用到不同的位宽和深度，用户则可以通过改变模块中的参数实现。</p>
<h3 id="参数的定制">4.2.2. 参数的定制</h3>
<p>参数的用户定制有两种方法：</p>
<ol type="1">
<li>通过 <code>defparam</code> 关键字对模块中的参数重新定义；</li>
<li>参数直接在实例化模块时代入。</li>
</ol>
<p>有意思的是，两家最大的 PLD 供应商 Altera 和 Xilinx 的通用模块定制恰好分别采用了这两种方法。 比如 Altera 的 Quartus II 开发环境中，用 MegaWiard 工具定制一个宽 8 深 32 位的单口 RAM 时，将产生如下的代码：</p>
<figure class="highlight verilog"><figcaption><span>ran_w8_d32.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> ran_w8_d32(address, clock, data, wren, q);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span> [<span class="number">4</span>:<span class="number">0</span>] address;</span><br><span class="line"><span class="keyword">input</span>       clock;</span><br><span class="line"><span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>] data;</span><br><span class="line"><span class="keyword">input</span>       wren;</span><br><span class="line"><span class="keyword">output</span>      q;</span><br><span class="line"></span><br><span class="line">altsyncram altsyncram_component(</span><br><span class="line">    <span class="variable">.wren_a</span>        (wren),</span><br><span class="line">    <span class="variable">.clock0</span>        (clock),</span><br><span class="line">    <span class="variable">.address_a</span>     (address),</span><br><span class="line">    <span class="variable">.data_a</span>        (data),</span><br><span class="line">    <span class="variable">.q_a</span>           (q),</span><br><span class="line">    <span class="variable">.aclr0</span>         (<span class="number">1&#x27;b0</span>),</span><br><span class="line">    <span class="variable">.aclr1</span>         (<span class="number">1&#x27;b0</span>),</span><br><span class="line">    <span class="variable">.q_b</span>           (),</span><br><span class="line">    <span class="variable">.clocken1</span>      (<span class="number">1&#x27;b1</span>),</span><br><span class="line">    <span class="variable">.clocken0</span>      (<span class="number">1&#x27;b0</span>),</span><br><span class="line">    <span class="variable">.data_b</span>        (<span class="number">1&#x27;b1</span>),</span><br><span class="line">    <span class="variable">.rden_b</span>        (<span class="number">1&#x27;b1</span>),</span><br><span class="line">    <span class="variable">.address_b</span>     (<span class="number">1&#x27;b1</span>),</span><br><span class="line">    <span class="variable">.wren_b</span>        (<span class="number">1&#x27;b0</span>),</span><br><span class="line">    <span class="variable">.byteena_b</span>     (<span class="number">1&#x27;b0</span>),</span><br><span class="line">    <span class="variable">.addressstall_a</span>(<span class="number">1&#x27;b0</span>),</span><br><span class="line">    <span class="variable">.byteena_a</span>     (<span class="number">1&#x27;b1</span>),</span><br><span class="line">    <span class="variable">.addressstall_b</span>(<span class="number">1&#x27;b0</span>),</span><br><span class="line">    <span class="variable">.clocken1</span>      (<span class="number">1&#x27;b1</span>)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line"><span class="keyword">defparam</span></span><br><span class="line">    altsyncram_component<span class="variable">.clock_enable_input_a</span> = <span class="string">&quot;BYPASS&quot;</span>,</span><br><span class="line">    altsyncram_component<span class="variable">.clock_enable_output_a</span> = <span class="string">&quot;BYPASS&quot;</span>,</span><br><span class="line">    altsyncram_component<span class="variable">.intended_device_family</span> = <span class="string">&quot;Stratix II&quot;</span>,</span><br><span class="line">    altsyncram_component<span class="variable">.lpm_hint</span> = <span class="string">&quot;ENABLE_RUNTIME_MOD = NO&quot;</span>,</span><br><span class="line">    altsyncram_component<span class="variable">.lpm_type</span> = <span class="string">&quot;altsyncram&quot;</span>,</span><br><span class="line">    altsyncram_component<span class="variable">.numwords_a</span> = <span class="number">32</span>,               <span class="comment">// 32 个字</span></span><br><span class="line">    altsyncram_component<span class="variable">.operation_mode</span> = <span class="string">&quot;SINGLE_PORT&quot;</span>,</span><br><span class="line">    altsyncram_component<span class="variable">.outdata_aclr_a</span> = <span class="string">&quot;NONE&quot;</span>,</span><br><span class="line">    altsyncram_component<span class="variable">.outdata_reg_a</span> = <span class="string">&quot;UNREGISTERED&quot;</span>,</span><br><span class="line">    altsyncram_component<span class="variable">.power_up_uninitialized</span> = <span class="string">&quot;FALSE&quot;</span>,</span><br><span class="line">    altsyncram_component<span class="variable">.ram_block_type</span> = <span class="string">&quot;M4K&quot;</span>,</span><br><span class="line">    altsyncram_component<span class="variable">.widthad_a</span> = <span class="number">5</span>,                 <span class="comment">// 5 位地址</span></span><br><span class="line">    altsyncram_component<span class="variable">.width_a</span> = <span class="number">8</span>,                   <span class="comment">// 8 位宽的数据</span></span><br><span class="line">    altsyncram_component<span class="variable">.width_byteena_a</span> = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>其中，<code>altsyncram</code> 是 Altera 的块 RAM 的通用模型。它可以在 Altera 的仿真文件“alteramf.v”中找到。</p>
<p><code>altsyncram-component</code> 是实例名称，<code>.</code> 后面是参数的名称，定义的参数值，有的是字符串，有的是整数。</p>
<p>在 <code>defparam</code> 关键字后面的是参数重定义的语句：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">altsyncram_component<span class="variable">.width_a</span> = <span class="number">8</span>,               <span class="comment">// 8 位宽的数据</span></span><br></pre></td></tr></table></figure>
<p>以上就是将 <code>altsyncram-component</code> 中的参数 <code>width_a</code> 重新定义为 8。</p>
<p>使用 <code>defparam</code> 的方法重新定义参数时，可以根据需要对部分的参数重新定义，其他的会保留模块的缺省值。</p>
<p>用 Xilinx 设计工具 ISE 中的 CORE Generator 产生一个单端口 8 位宽、32 位深的 RAM。注意观察，其中RAM的参数是如何带入的：</p>
<figure class="highlight verilog"><figcaption><span>ram_w8_d32.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> ram_w8_d32(addr, clk, din, dout, we)</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span> [<span class="number">4</span>:O] addr;</span><br><span class="line"><span class="keyword">input</span>       clk;</span><br><span class="line"><span class="keyword">input</span> [<span class="number">7</span>:O] din.</span><br><span class="line"><span class="keyword">output</span> [<span class="number">7</span>:<span class="number">0</span>] dout;</span><br><span class="line"><span class="keyword">input</span> we;</span><br><span class="line"></span><br><span class="line"><span class="comment">// synopsys translate_off</span></span><br><span class="line">BLKMEMSP_V6_1 #(</span><br><span class="line">    <span class="number">5</span>,                  <span class="comment">// c_addr_width</span></span><br><span class="line">    <span class="string">&quot;0&quot;</span>,                <span class="comment">// c_default_data</span></span><br><span class="line">    <span class="number">32</span>,                 <span class="comment">// c_depth</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">// c_enable_rlocs</span></span><br><span class="line">    <span class="number">1</span>,                  <span class="comment">// c_has_default_data</span></span><br><span class="line">    <span class="number">1</span>,                  <span class="comment">// c_has_din</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">// c_has_en</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">// c_has_limit_data_pitch</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">// c_has_nd</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">// c_has_rdy</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">// c_has_rfd</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">// c_has_sinit</span></span><br><span class="line">    <span class="number">1</span>,                  <span class="comment">// c_has_we</span></span><br><span class="line">    <span class="number">18</span>,                 <span class="comment">// c_limit_data_pitch</span></span><br><span class="line">    <span class="string">&quot;mif_file_16_1&quot;</span>,    <span class="comment">// c_em_init_file</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">// c_pipe_stages</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">// c_reg_inputs</span></span><br><span class="line">    <span class="string">&quot;0&quot;</span>,                <span class="comment">// c_sinit_value</span></span><br><span class="line">    <span class="number">8</span>,                  <span class="comment">// c_width</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">// c_write_mode</span></span><br><span class="line">    <span class="string">&quot;0&quot;</span>,                <span class="comment">// c_ybottom_addr</span></span><br><span class="line">    <span class="number">1</span>,                  <span class="comment">// c_yclk_is_rising</span></span><br><span class="line">    <span class="number">1</span>,                  <span class="comment">// c_yen_is_high</span></span><br><span class="line">    <span class="string">&quot;hierarchy1&quot;</span>,       <span class="comment">// c_hierarchy</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">// c_ymake_bmm</span></span><br><span class="line">    <span class="string">&quot;32kx1&quot;</span>,            <span class="comment">// c_yprimitive_type</span></span><br><span class="line">    <span class="number">1</span>,                  <span class="comment">// c_ysinit_is_high</span></span><br><span class="line">    <span class="string">&quot;1024&quot;</span>,             <span class="comment">// c_ytop_addr</span></span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">// c_yuse_single_primitive</span></span><br><span class="line">    <span class="number">1</span>,                  <span class="comment">// c_ywe_is_high</span></span><br><span class="line">    <span class="number">1</span>                   <span class="comment">// c_yydisable_warnings</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">inst(</span><br><span class="line">    <span class="variable">.ADDR</span> (addr),</span><br><span class="line">    <span class="variable">.CLK</span>  (clk),</span><br><span class="line">    <span class="variable">.DIN</span>  (din),</span><br><span class="line">    <span class="variable">.DOUT</span> (dout),</span><br><span class="line">    <span class="variable">.WE</span>   (we),</span><br><span class="line">    <span class="variable">.EN</span>   (),</span><br><span class="line">    <span class="variable">.ND</span>   (),</span><br><span class="line">    <span class="variable">.RFD</span>  (),</span><br><span class="line">    <span class="variable">.RDY</span>  (),</span><br><span class="line">    <span class="variable">.SINIT</span>()</span><br><span class="line">    );</span><br><span class="line"><span class="comment">// synopsys translate_on</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>其中 <code>BLKMEMSP_V6_1</code> 是 Xilinx 的块状RAM的通用模型。<code>inst</code> 是用户实例名称。用户需要在通用RAM类型的基础上，通过参数带入实现。采用 <code>#(...)</code> 方法来实现参数逐个覆盖。</p>
<p>使用上面这种参数直接带入法时，要注意一点，所有的参数都需要全部按顺序列出来，不能遗漏，也不能颠倒顺序，否则就容易对应不上。</p>
<h1 id="设计层次">5. 设计层次</h1>
<p>在前面几节中，介绍了 Verilog 的描述方式。 Verilog 语言是一种强大的硬件描述语言，可以支持多个设计层次。在这里将进行简单的介绍。</p>
<h2 id="系统级和行为级">5.1. 系统级和行为级</h2>
<p>Verilog 语言作为一种用户工具，提供给用户许多描述硬件的手段，如前面所述：数据流描述、行为描述（<code>always</code> 和 <code>initial</code> 语句）、结构化描述。同时，不同用户可以根据自己的需要，在不同抽象层次上对硬件进行描述。有如下设计层次金字塔供参考。</p>
<div data-align="center">
<p><img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-30-josh-verilog-part-3/2020-11-30-josh-verilog-part-3-170-DesignLevelPyramid.png!600px"/></p>
</div>
<p>下面简单介绍几种不同角色的工作特点，以及它们所处的设计层次：</p>
<p>系统构架师：在目前业界主流的设计方法学中，系统构架师（System Architect）通常用高级语言，如SystemC，来描述一个系统的规格，仿真整个系统的功能和性能等。这种早期的设计和探索往往不涉及到具体的实现细节，甚至于软件和硬件的划分都没有开始。系统构架师也可以采用 Verilog 来描述系统的功能，它们往往不考虑硬件实现的细节。因而称这种设计层次为系统级或算法级。</p>
<p>逻辑设计工程师：他们利用前面所讲的 Verilog 各种描述手段，设计 RTL 级的代码，精确到时钟周期。逻辑设计工程师的代码，通过综合工具的综合，可以转换为 Verilog 的门级网表，其中所有的功能块都是由基本的门单元组成的。</p>
<p>物理设计工程师：他们将这些门级网表进行布局和布线，做成实际的芯片。</p>
<p>验证工程师：他们负责对设计的电路进行验证，他们编写的代码主要是用来产生激励，这些激励大部分需要的抽象层次更高，以使仿真的效率更高。然后在工具中对电路进行仿真，检查响应结果。这些代码不会实现为具体癭件，有些并不需要精确到时钟周期，而只是在软件的仿真工具中运行，实现一定的功能即可，称这种描述层次为行为级。</p>
<p>这里的行为级描述，不同于 <a href="#03">3. 行为描述</a>中所述的“行为描述方式”。这里特指一种描述的抽象层次。</p>
<p>下面举一个实例说明 RTL 级和行为级的区别，要实现的状态机一部分如下图所示。</p>
<div data-align="center">
<p><img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-11-30-josh-verilog-part-3/2020-11-30-josh-verilog-part-3-180-ASimpleHandshakingStateMachine.png!500px"/></p>
</div>
<p>上图中只有两个状态，当在左边的状态时，<code>REQ</code> 输出 1；当在右边的状态时，<code>REQ</code> 输出 0。<code>ACK</code> 是状态机的输入信号，决定了状态的跳转。</p>
<p>如果是让一个 RTL 设计工程师来设计，他马上就会与硬件实现的细节联系起来，很可能就会用如下代码实现：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">/************************</span></span><br><span class="line"><span class="comment">RTL 描述</span></span><br><span class="line"><span class="comment">************************/</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>] curr_sm;</span><br><span class="line"><span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>] next_sm;              <span class="comment">// 定义状态寄存器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">parameter</span> ...;</span><br><span class="line">state0 = <span class="number">2&#x27;b01</span>;</span><br><span class="line">state1 = <span class="number">2&#x27;b10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// state registers</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">posedge</span> rst) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (rst)</span><br><span class="line">        curr_sm &lt;= ...;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        curr_sm &lt;= next_sm;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// next state logic</span></span><br><span class="line"><span class="keyword">always</span> @(curr_sm <span class="keyword">or</span> ACK) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">case</span>(curr_sm)</span><br><span class="line">        ...</span><br><span class="line">        state0: <span class="keyword">begin</span></span><br><span class="line">            REQ = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (ACK == <span class="number">1</span>)</span><br><span class="line">                next_sm = state1;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                next_sm = state0;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        state1: <span class="keyword">begin</span></span><br><span class="line">            REQ = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (ACK == <span class="number">0</span>)</span><br><span class="line">                next_sm = ...;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                next_sm = state1;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>然而，如果让一个逻辑验证工程师来设计这个状态机，他不考虑硬件实现的细节，只需要在语义上满足要求即可。甚至可以不出现状态寄存器。如下例：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">/************************</span></span><br><span class="line"><span class="comment">行为描述</span></span><br><span class="line"><span class="comment">************************/</span></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    ...</span><br><span class="line">    REQ = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">wait</span> (ACK == <span class="number">1</span>);</span><br><span class="line">    REQ = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">wait</span> (ACK == <span class="number">0</span>);</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>从上例中可以看出，逻辑验证工程师设计的方式十分简单，仅仅利用了 <code>begin ... end</code> 语句组的顺序执行特性，同时利用 <code>wait</code> 语句来实现状态的转移。这是典型的行为级设计风格，也是逻辑验证工程师们所追求的思维方式。</p>
<h2 id="rtl-级">5.2. RTL 级</h2>
<p>所谓寄存器传输级（RTL级），就是描述电路的时候，只需要关注寄存器本身，以及寄存器到寄存器之间的逻辑功能，而不用关心寄存器和组合逻辑的实现细节（具体用了多少逻辑门等）。</p>
<p>随着逻辑综合工具的兴起，工程师才可以从 RTL 级进行电路设计了，而不需要像传统设计方法一样从门级电路搭起。它们的 RTL 设计代码将直接通过逻辑综合工具，综合成门级的设计网表，通常是由基本的门单元组成的。逻辑综合是 EDA 流程的重要组成部分。</p>
<p>Verilog 设计电路最常用的设计层次就是 RTL 级。在 RTL 描述时，设计者需要关注寄存器的行为，其中保存着数据；同时需要关注寄存器和寄存器之间的组合逻辑功能，是否能满足功能需求和时序需求。RTL 级模型是严格精确到时钟周期的模型。</p>
<p>后续会重点介绍 RTL 设计的方法和技巧。</p>
<blockquote>
<p>RTL 级是 HDL 语言最重要的概念之一，RTL 级是综合器最常用的设计输入层次。目前使用 FPGA/CPLD 等可编程逻辑器件时，设计输入都为 RTL 级。这是因为门级输入过于繁琐；而对于行为级和系统级设计输入，很多综合器不支持，并容易产生综合歧义。</p>
</blockquote>
<h2 id="门级">5.3. 门级</h2>
<p>在 Verilog 语义中，使用一些基本的门原语可以直接描述电路的门级功能。例如：</p>
<figure class="highlight verilog"><figcaption><span>HalfAdd.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> HalfAdd(X, Y, sum, C_out);                   <span class="comment">// 半加器模块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span> X;</span><br><span class="line"><span class="keyword">input</span> Y;</span><br><span class="line"><span class="keyword">output</span> sum;</span><br><span class="line"><span class="keyword">output</span> C_out;</span><br><span class="line"></span><br><span class="line"><span class="keyword">xor</span> u_xor(sum, X, Y);                               <span class="comment">// 门级原语实例</span></span><br><span class="line"><span class="keyword">and</span> u_and(C_out, X, Y);                             <span class="comment">// 门级原语实例</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span> </span><br></pre></td></tr></table></figure>
<p>其中直接调用了 <code>xor</code> 和 <code>and</code> 的两个 Verilog 门原语。</p>
<p>门级设计就是指在逻辑门一级将电路搭出来。特别是对于大设计来说，这种设计非常耗时、效率低下，同时容易出错。但是对于一些逻辑容量较小，性能和面积要求非常高的设计，有时还采用门级设计，以满足一些特殊的需求。</p>
<p>门级设计类似于软件中的汇编语言设计，非常精确，但是耗时耗力。</p>
<h2 id="晶体管级">5.4. 晶体管级</h2>
<p>逻辑门是由一个个晶体管组成的。在 Verilog 语言中，有用于直接描述 NMOS 和 PMOS 的原语。这里不过多叙述，有兴趣可查阅相关资料。</p>
<h2 id="混合描述">5.5. 混合描述</h2>
<p>Verilog 支持不同设计层次的混描述。</p>
<p>实际上，这些描述层次之间没有严格的界限。这里只是想将概念描述清楚，这一点对初学者非常重要。</p>
<hr />
<p>在本篇笔记中，重点介绍了 Verilog 的 3 种描述方式以及 Verilog 可以应用的设计层次。至此，大家应该能感受到 Verilog 语言是一种非常灵活、强大的硬件描述语言。</p>
]]></content>
      <categories>
        <category>Verilog</category>
        <category>Josh 的学习笔记</category>
        <category>Verilog</category>
        <category>Verilog 设计</category>
      </categories>
      <tags>
        <tag>Verilog</tag>
        <tag>HDL</tag>
        <tag>Verilog 语法</tag>
        <tag>描述方式</tag>
        <tag>谁急层次</tag>
      </tags>
  </entry>
  <entry>
    <title>Josh 的学习笔记之 Verilog（Part 4 —— RTL 概念与常用 RTL 建模）</title>
    <url>/posts/ecb88422.html</url>
    <content><![CDATA[<p>Verilog HDL 的基本功能之一是描述可综合的硬件电路。如何合理使用 Verilog HDL 描述高性能的可综合电路是 Verilog 系列学习笔记的目的，也是后续要讨论的主要问题。</p>
<p>本文介绍了 RTL 和综合的基本概念，通过常用 RTL 电路模型来对可综合的 RTL 级描述方式建立整体性的认识。力图通过范例，逐步引导初学者建立可综合 RTL 子集的概念。</p>
<h1 id="rtl-和综合">1. RTL 和综合</h1>
<p>从<a href="https://josh-gao.top/posts/fd117896.html#5-%E8%AE%BE%E8%AE%A1%E5%B1%82%E6%AC%A1">《Part 3 —— 描述方式和设计层次》的第 5 小节</a>可知，HDL 语言是分层次的。</p>
<div class="note default">
            <p>最常用的层次概念有系统级（System Level）或功能模块级（Functional Model Level）、行为级（BehavioraI Level）、寄存器传输级（RTL，Register Transfer Level）和门级（Gate Level）等。</p>
          </div>
<a id="more"></a>
<p>其中寄存器传输级（RTL，Register Transfer Level）指：<strong><span class="label default"> 不关注寄存器和组合逻辑的细节（如使用了多少逻辑门，逻辑门之间的连接拓扑结构等），通过描述寄存器到寄存器之间的逻辑功能描述电路的 HDL 层次</span></strong>。RTL 级是比门级更高的抽象层次，使用 RTL 级语言描述硬件电路一般比门级描述电路简单、高效得多。</p>
<p>RTL 级语言的最重要特性就是：<span class="label primary">RTL 级描述是可综合的描述层次</span>。</p>
<p>综合（Synthesize）指：<strong>将 HDL 语言、原理图等设计输入翻译成由与、或、非门等基本逻辑单元组成的门级连接（网表），并根据设计目标与要求（约束条件）优化所生成的逻辑连接，输出门级网表文件</strong>。RTL 级综合指将 RTL 级源代码翻译并优化为门级网表。</p>
<p>随着综合工具的不断智能化，使用RTL级语言描述硬件电路越来越方便。特别是在可编程逻辑器件（PLD，主要指 FPGA 和 CPLD）设计领域，最重要的代码设计层次就是 RTL 级。</p>
<h1 id="rtl-级的基本要素和设计步骤">2. RTL 级的基本要素和设计步骤</h1>
<p>典型的 RTL 设计包含以下3个部分：</p>
<ol type="1">
<li><p>时钟域描述</p>
<p>描述设计所使用的所有时钟，时钟之间的主从与派生关系，时钟域之间的转换。</p></li>
<li><p>时序逻辑描述（寄存器描述）</p>
<p>根据时钟沿的变换，描述寄存器之间的数据传输方式。</p></li>
<li><p>组合逻辑描述</p>
<p>描述电平敏感信号的逻辑组合方式与逻辑功能。</p></li>
</ol>
<p>RTL 描述中时序逻辑和组合逻辑的连接关系和拓扑结构决定了设计的性能，如何调整时序逻辑、组合逻辑的连接关系和拓扑结构以达到最佳的性能就是后面讨论的编码风格（Coding Style）的核心。</p>
<p>工程师们设计 RTL 级代码的顺序各种各样，推荐使用如下的设计步骤：</p>
<ol type="1">
<li><p><strong>功能定义与模块划分</strong></p>
<p>根据系统功能的定义和模块划分准则（详见Part 5 第 4 节）划分各个功能模块。</p></li>
<li><p><strong>定义所有模炔的接口</strong></p>
<p>首先清晰定义每个模块的接口，完成每个模块的信号列表。这种思路也和 Modular Design（模块化设计方法）一致，利于模块重用、调试、修改。</p></li>
<li><p><strong>设计的时钟域</strong></p>
<p>根据设计的时钟复杂程度定义时钟之间的派生关系，分析设计中有哪些时钟域，是否存在异步时钟域之间的数据交换。对于 PLD 设计，还需确认全局时钟和是否使用 PLL/DLL 完成时钟的分频、倍频、移相等功能，哪些时钟使用全局资源布线，哪些时钟使用第二全局时钟资源布线。</p>
<p>全局时钟资源的特点是：几乎没有 CIock Skew（时钟偏斜），有一定的 Clock Delay（时钟延迟），驱动能力最强；第二全局时钟的特点是：有较小的 CIock Skew，较小的 CIock DeIay，时钟驱动能力较强。</p></li>
<li><p><strong>考虑设计的关键路径</strong></p>
<p>关键路径是指设计中时序要求最难以满足的路径。设计的时序要求主要体现在频率、建立时间、保持时间等时序指标上。在设计初期，设计者可以根据系统的频率要求，粗略地分析出设计的时序难点（如最高频率的路径，计数器的最低位，包含复杂组合逻辑的时序路径等），通过一些时序优化手段（如 Pipeline、Retiming、逻辑复制等，这些时序优化手段在 Part 5 第 7 节有详细介绍）<strong>从代码上缓解设计的时序压力</strong>，这种方法比单依靠综合与布局布线工具的自动优化有效得多。</p></li>
<li><p><strong>顶层设计</strong></p>
<p>常用的设计方法有两种，一种是自顶而下的设计方法，即先描述设计的顶层，然后描述设计的每个子模块；另一种是由底向上的设计方法，即首先描述设计的子模块，最后定义设计的顶层。RTL 设计推荐使用自顶而下的设计方法，因为这种设计方法与模块规划的顺序一致，而且更利于进行 Modular Design（模块化设计方法），并行开展设计工作，提高模块重用率。</p></li>
<li><p><strong>FSM 设计</strong></p>
<p>有限状态机（FSM）是逻辑设计的最重要内容之一。Part 6 主要讨论如何写好 FSM。</p></li>
<li><p><strong>时序逻辑设计</strong></p>
<p>首先根据时钟域规划好寄存器组，然后描述各个寄存器组之间的数据传输方式。</p></li>
<li><p><strong>组合逻辑设计</strong></p>
<p>一般来说，<strong>大段的组合逻辑最好与时序逻辑分开描述</strong>，这样更利于时序约束和时序分析，使综合器和布局布线器达到更好的优化效果。</p></li>
</ol>
<h1 id="常用-rtl-级建模">3. 常用 RTL 级建模</h1>
<h2 id="非阻塞赋值阻塞赋值连续赋值">3.1. 非阻塞赋值、阻塞赋值、连续赋值</h2>
<p>有很多文章论述阻塞赋值和非阻塞赋值的概念，<a href="https://josh-gao.top/posts/fd117896.html#3-2-%E8%BF%87%E7%A8%8B%E8%B5%8B%E5%80%BC%E8%AF%AD%E5%8F%A5">《Part 3 —— 描述方式和设计层次》的 3.2 小节</a>详细讨论了因不当使用阻塞赋值和非阻塞赋值引起的仿真与设计意图不一致。为了避免不当使用阻塞賦值和非阻塞赋值而造成的种种歧义和错误，这里推荐：</p>
<ol type="1">
<li><p><strong>对于时序逻辑，即 <code>always</code> 模块的敏感表为<span class="label primary">沿敏感信号</span>（多为时钟或复位的正沿或负沿），统一使用非阻塞賦值 <code>&lt;=</code></strong>。例如：</p>
<p><figure class="highlight verilog"><figcaption><span>// cnt1.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment">时序逻辑中使用非阻塞赋值。</span></span><br><span class="line"><span class="comment">******************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> cnt1 (clock, cnt_out);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span>        clock;</span><br><span class="line"><span class="keyword">output</span> [<span class="number">3</span>:<span class="number">0</span>] cnt_out;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] cnt_out;</span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clock)</span><br><span class="line">    cnt_out &lt;= cnt_out + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>对于 <code>always</code> 模块的敏感表为<span class="label primary">电平敏感</span>信号的组合逻辑，统一使用阻塞賦值</strong>。例如： <span id="cnt2.v"></span></p>
<p><figure class="highlight verilog"><figcaption><span>cnt2.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment">always 模块的敏感表为电平敏感信号的组合逻辑, 使用阻塞赋值。请注意, 此例</span></span><br><span class="line"><span class="comment">&quot;cnt_out_plus&quot;虽然被指定为 reg 型, 但是实现时是纯组合逻辑。</span></span><br><span class="line"><span class="comment">******************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> cnt2 (cnt_out, cnt_out_plus);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span>  [<span class="number">3</span>:<span class="number">0</span>] cnt_out;</span><br><span class="line"><span class="keyword">output</span> [<span class="number">3</span>:<span class="number">0</span>] cnt_out_plus;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] cnt_out_plus;</span><br><span class="line"><span class="keyword">always</span> @(cnt_out)</span><br><span class="line">    cnt_out_plus = cnt_out + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>对于 <code>assign</code> 关键字描述的<span class="label primary">组合逻辑</span>，称为连续赋值语句，统一使用 <code>=</code>，变量被定义为 <code>wire</code> 型信号</strong>。例如：</p>
<p><figure class="highlight verilog"><figcaption><span>cnt3.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment">assign 描述的组合逻辑。&quot;cnt_out_plus&quot;被定义为 wire 型信号。</span></span><br><span class="line"><span class="comment">******************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> cnt3 (cnt_out, cnt_out_plus);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span>  [<span class="number">3</span>:<span class="number">0</span>] cnt_out;</span><br><span class="line"><span class="keyword">output</span> [<span class="number">3</span>:<span class="number">0</span>] cnt_out_plus;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</span></span><br><span class="line"><span class="keyword">wire</span> [<span class="number">3</span>:<span class="number">0</span>] cnt_out_plus;</span><br><span class="line"><span class="keyword">assign</span> cnt_out_plus = cnt_out + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></p></li>
</ol>
<div class="note warning">
            <p>在 2 和 3 中，为什么不采用类似例 1 中的 <code>cnt_out &lt;= cnt_out + 1;</code> 呢？因为，<strong>这样会产生组合逻辑环</strong>。组合逻辑环是同步时序逻辑设计的大忌，它会使得时序路径无法被工具所分析，<strong>因不同的芯片的延时差异，而造成逻辑功能不稳定</strong>。有些已经完成很久的设计，在换了芯片批次后，逻辑功能不正确，大多数都是由组合逻辑环造成的。</p>
          </div>
<p>对于初学者而言，以上几点是必须遵循的法则，详细原因可以参考<a href="https://josh-gao.top/posts/fd117896.html">《Part 3 —— 描述方式和设计层次》</a>和 Part 5 的论述。</p>
<h2 id="寄存器电路建模">3.2. 寄存器电路建模</h2>
<p>寄存器和组合逻辑是数字逻辑电路的两大基本要素。寄存器一般和同步时序逻辑关联，其特点为仅当时钟的沿（上升沿或下降沿）到达时，才有可能发生输出的改变。根据实现目标不同，寄存器的建模结构略有不同，需要注意如下要点：</p>
<ol type="1">
<li><p><strong>寄存器信号声明</strong>：<strong>寄存器定义是 <code>reg</code> 型</strong>。</p>
<p><div class="note info">
            <p>请注意，这个命题的反命题不一定成立。<strong>某些信号虽然被定义为 <code>reg</code> 型，但是最终综合实现结果并不是寄存器</strong>，如上述例子 <a href="#cnt2.v">cnt2.v</a> 中 <code>cnt_out_plus</code> 虽然被指定为 <code>reg</code> 型，但是实现时是纯组合逻辑。<strong>只有定义为 <code>reg</code> 型，且 <code>always</code> 的敏感表为 <code>posedge</code> 或 <code>negedge</code> 沿敏感操作时，该信号才是寄存器</strong>。在<a href="https://josh-gao.top/posts/fd2ca242.html">《Part 2 —— Verilog 语言基础》</a>和<a href="https://josh-gao.top/posts/fd117896.html">《Part 3 —— 描述方式和设计层次》</a>也有相关内容描述这个问题。</p>
          </div></p></li>
<li><p><strong>时钟输入</strong>：在每个时钟的正沿或负沿对数据进行处理。数据的正沿或负沿起作用，是在 <code>always</code> 的敏感表中通过 <code>posedge</code> 和 <code>negedge</code> 指定的。</p>
<p><figure class="highlight verilog"><figcaption><span>cnt4.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment">指定寄存器的触发沿是时钟的下降沿。</span></span><br><span class="line"><span class="comment">******************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> cnt4 (clock, cnt_out);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span>        clock;</span><br><span class="line"><span class="keyword">output</span> [<span class="number">3</span>:<span class="number">0</span>] cnt_out;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] cnt_out;</span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">negedge</span> clock)</span><br><span class="line">    cnt_out &lt;= cnt_out + <span class="number">1</span>;</span><br><span class="line"><span class="comment">// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>异步复位/置位</strong>：绝大多数目标器件的寄存器模型都包含异步复位/置位端。异步复位／置位是指无论时钟沿是否有效，当复位/置位信号有效沿到达时，复位/置位立即发挥功能。指定异步复位/置位时，<strong>只需在 <code>always</code> 的敏感表中加入复位/置位信号的有效沿即可</strong>。下例描述的异步复位电路是最常用的寄存器复位形式之一。</p>
<p><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment">最常用的异步复位电路, 设异步复位信号&quot;reset_&quot;是低有效信号(也即下降沿开始复位)。用户可</span></span><br><span class="line"><span class="comment">以在 begin/end 结构之间填入复杂的用户逻辑。</span></span><br><span class="line"><span class="comment">******************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// reg_counter.v</span></span><br><span class="line"><span class="keyword">module</span> reg_counter (clock, reset_, cnt_reg_s, cnt_reg_a);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span>        clock;</span><br><span class="line"><span class="keyword">input</span>        reset_;</span><br><span class="line"><span class="keyword">output</span> [<span class="number">3</span>:<span class="number">0</span>] cnt_reg_s;</span><br><span class="line"><span class="keyword">output</span> [<span class="number">3</span>:<span class="number">0</span>] cnt_reg_a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] cnt_reg_s;  <span class="comment">//asynchronous reset</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clock <span class="keyword">or</span> <span class="keyword">negedge</span> reset_)</span><br><span class="line">    <span class="keyword">if</span> (!reset_)</span><br><span class="line">        cnt_reg_s &lt;= <span class="number">4&#x27;b0000</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        cnt_reg_s [<span class="number">2</span>:<span class="number">0</span>] &lt;= cnt_reg_s [<span class="number">2</span>:<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">        cnt_reg_s [<span class="number">3</span>]   &lt;= ~cnt_reg_s [<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="comment">// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] cnt_reg_a;  <span class="comment">//synchronous reset</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clock)</span><br><span class="line">    <span class="keyword">if</span> (!reset_)</span><br><span class="line">        cnt_reg_a &lt;= <span class="number">4&#x27;b0000</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        cnt_reg_a [<span class="number">2</span>:<span class="number">0</span>] &lt;= cnt_reg_a [<span class="number">2</span>:<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">        cnt_reg_a [<span class="number">3</span>]   &lt;= ~cnt_reg_a [<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>同步复位/置位</strong>：任何寄存器都可实现同步复位/置位功能。指定同步复位/置位时，<strong><code>always</code> 的敏感表中仅有时钟沿信号</strong>，当同步复位/置位信号变化时，同步复位/置位并不立即发生，仅仅当时钟沿采到同步复位/置位的有效电平时，才会在时钟沿到达时刻进行复位/置位操作。</p>
<p><figure class="highlight verilog"><figcaption><span>reg_counter.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment">常用的同步复位电路, 设异步复位信号&quot;reset_&quot;是低电平有效信号。请比较上例, 对比 always </span></span><br><span class="line"><span class="comment">的敏感表。</span></span><br><span class="line"><span class="comment">******************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> reg_counter (clock, reset_, cnt_reg_s, cnt_reg_a);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span>        clock;</span><br><span class="line"><span class="keyword">input</span>        reset_;</span><br><span class="line"><span class="keyword">output</span> [<span class="number">3</span>:<span class="number">0</span>] cnt_reg_s;</span><br><span class="line"><span class="keyword">output</span> [<span class="number">3</span>:<span class="number">0</span>] cnt_reg_a;</span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] cnt_reg_s;  <span class="comment">//asynchronous reset</span></span><br><span class="line"><span class="keyword">always</span> @ (<span class="keyword">posedge</span> clock <span class="keyword">or</span> <span class="keyword">negedge</span> reset_)</span><br><span class="line">    <span class="keyword">if</span> (!reset_)</span><br><span class="line">        cnt_reg_s &lt;= <span class="number">4&#x27;b0000</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        cnt_reg_s [<span class="number">2</span>:<span class="number">0</span>] &lt;= cnt_reg_s [<span class="number">2</span>:<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">        cnt_reg_s [<span class="number">3</span>]   &lt;= ~cnt_reg_s [<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] cnt_reg_a;  <span class="comment">//synchronous reset</span></span><br><span class="line"><span class="keyword">always</span> @ (<span class="keyword">posedge</span> clock)</span><br><span class="line">    <span class="keyword">if</span> (!reset_)</span><br><span class="line">        cnt_reg_a &lt;= <span class="number">4&#x27;b0000</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        cnt_reg_a [<span class="number">2</span>:<span class="number">0</span>] &lt;= cnt_reg_a [<span class="number">2</span>:<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">        cnt_reg_a [<span class="number">3</span>]   &lt;= ~cnt_reg_a [<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="comment">// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>关于同步复位和异步复位的优缺点，在 <a href="#0309">3.9 小节</a> 有详细介绍。</p>
</blockquote></li>
<li><p><strong>同时使用时钟上升和下降沿的问题</strong>：有时因为数据采样或调整数据相位等需求，设计者会在一个 <code>always</code> 的敏感表中同时使用时钟的 <code>posedge</code> 和 <code>negedge</code>，或者在两个 <code>always</code> 的敏感表中分别使用时钟的 <code>posedge</code> 和 <code>negedge</code> 对某些寄存器电路操作。在这两种描述下，当时钟上沿或下沿到达时，该寄存器电路都会做相应的操作。<strong>这个双沿电路往往可以等同于使用了原时钟的倍频时钟的单沿操作电路</strong>。对于实现在 PLD 的设计而言，同时使用时钟的上、下沿往往是不推荐的，因为 PLD 内嵌的 PLL/DLL 和一些时钟电路往往只能对时钟的一个沿保证非常好的指标，而另个沿的抖动、偏斜、斜率等指标不见得非常优化，有时同时使用时钟的正负沿会因时钟的抖动、偏斜、占空比、斜率等问题造成一定的性能恶化。因此推荐的做法是：将原时钟通过 PLL/DLL 倍频，然后使用倍频时钟的单沿（如上升沿）进行操作。但是电路设计不可一概而论，如果必须使用时钟的双沿对同一个寄存器操作时，请设计者明确此时相当于使用了倍频时钟。</p>
<p><figure class="highlight verilog"><figcaption><span>clock_edge.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment">某电路使用 50MHz 时钟双沿操作相当于使用同相位 100MHz 倍频时钟操作。</span></span><br><span class="line"><span class="comment">******************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> clock_edge (clk_50M, clk_100M, rst_, cnt1, cnt2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span>        clk_50M, clk_100M, rst_;</span><br><span class="line"><span class="keyword">output</span> [<span class="number">3</span>:<span class="number">0</span>] cnt1, cnt2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</span></span><br><span class="line"><span class="keyword">reg</span>    [<span class="number">3</span>:<span class="number">0</span>] cnt_temp1, cnt_temp2;</span><br><span class="line"><span class="keyword">wire</span>   [<span class="number">3</span>:<span class="number">0</span>] cnt1;</span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk_50M <span class="keyword">or</span> <span class="keyword">negedge</span> rst_ )</span><br><span class="line">    <span class="keyword">if</span> (!rst_)</span><br><span class="line">        cnt_temp1 &lt;= <span class="number">4&#x27;b0000</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cnt_temp1 &lt;= cnt_temp2 + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">negedge</span> clk_50M <span class="keyword">or</span> <span class="keyword">negedge</span> rst_ )</span><br><span class="line">    <span class="keyword">if</span> (!rst_)</span><br><span class="line">        cnt_temp2 &lt;= <span class="number">4&#x27;b0000</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cnt_temp2 &lt;= cnt_temp1 + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> cnt1 = (clk_50M)? cnt_temp2 : cnt_temp1;</span><br><span class="line"><span class="comment">// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span>    [<span class="number">3</span>:<span class="number">0</span>] cnt2;</span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk_100M <span class="keyword">or</span> <span class="keyword">negedge</span> rst_ )</span><br><span class="line">    <span class="keyword">if</span> (!rst_)</span><br><span class="line">        cnt2 &lt;= <span class="number">4&#x27;b0000</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cnt2 &lt;= cnt2 + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></p>
<p>这里相当于使用与 50MHz 时钟 <code>clk_50M</code> 同相位的 2 倍频时钟 <code>cIk_100M</code> 进行累加计算，等效描述如下：</p>
<p><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">reg</span>    [<span class="number">3</span>:<span class="number">0</span>] cnt2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk_100M <span class="keyword">or</span> <span class="keyword">negedge</span> rst_ )</span><br><span class="line">    <span class="keyword">if</span> (!rst_)</span><br><span class="line">        cnt2 &lt;= <span class="number">4&#x27;b0000</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cnt2 &lt;= cnt2 + <span class="number">1</span>;</span><br></pre></td></tr></table></figure></p>
<p>以上代码综合后，对应的电路结构如<a href="#图4-1">图 4-1</a> 所示。</p>
<p><a name="图4-1"></a></p>
<div data-align="center">
<img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-12-02-josh-verilog-part-4/2020-12-02-josh-verilog-part-4-010-RegisterCircuitModeling-01.png!900px" alt="某双沿加法电路与等价倍频时钟单沿加法电路结构示意图"/>
</div>
<p>RTL 仿真波形如<a href="#图4-2">图 4-2</a> 所示。</p>
<p><a name="图4-2"></a></p>
<div data-align="center">
<img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-12-02-josh-verilog-part-4/2020-12-02-josh-verilog-part-4-020-RegisterCircuitModeling-02.png!900px" alt="某双沿加法电路与等价倍频时钟单沿加法电路仿真波型图"/>
</div>
<p>通过这个例子可以看出 ，某些使用双沿操作的电路等价于使用倍频时钟的单沿电路，也就是说，这些电路使用了时钟的双沿触发寄存器，则相当于提高了设计频率，提高了设计要求的时序难度。对于这些电路，在附加时序约束和进行时序分析时一定要考虑充分。</p></li>
</ol>
<h2 id="组合逻辑建模">3.3. 组合逻辑建模</h2>
<p>组合逻辑是逻辑电路设计的另一重要组成部分。组合逻辑的特点是输出的变化仅仅和输入的电平相关，而与时钟沿无关。RTL 级常用组合逻辑的建模有两种：第一种是 <code>always</code> 模块的敏感表为电平敏感信号的电路；第二种是 <code>assign</code> 等关键字描述的组合逻辑电路。</p>
<ol type="1">
<li><p><strong><code>always</code> 模块的敏感表为电平敏感信号的组合逻辑电路</strong></p>
<p>这种形式描述组合逻辑电路应用非常广泛，如果不考虑代码的复杂性，几乎任何组合逻辑电路都可以用这种方式建模。<code>always</code> 模块的敏感表为所有判定条件和输入信号，<strong>在使用这种结构描述组合逻辑时一定要将敏感表列写完整</strong>。在 <code>always</code> 模块中可以使用 <code>if ... else</code>、<code>case</code>、<code>for</code> 循环等各种 RTL 关键字结构。下面以某组合逻辑译码电路为例，说明这种组合逻辑建模方式。如前所述，在这种组合逻辑 <code>always</code> 模块中．推荐使用阻塞赋值 <code>=</code>，虽然信号被定义为 <code>reg</code> 型，但是最终综合实现结果并不是寄存器，而是组合逻辑，定义为 <code>reg</code> 型仅是纯语法需要而已。</p>
<p><figure class="highlight verilog"><figcaption><span>decode_cmb.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment">某组合逻辑译码电路。</span></span><br><span class="line"><span class="comment">******************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> decode_cmb (addr, CS, cs1, cs2, cs3, cs4);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span>  [<span class="number">7</span>:<span class="number">0</span>]      addr;         <span class="comment">// only the 2 MSB bits used</span></span><br><span class="line"><span class="keyword">input</span>             CS;           <span class="comment">// Low effect</span></span><br><span class="line"><span class="keyword">output</span> cs1, cs2, cs3, cs4;      <span class="comment">// Low effect</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</span></span><br><span class="line"><span class="keyword">reg</span>    cs1, cs2, cs3, cs4;</span><br><span class="line"><span class="keyword">parameter</span> chip1_decode = <span class="number">2&#x27;b00</span>,</span><br><span class="line">          chip2_decode = <span class="number">2&#x27;b01</span>,</span><br><span class="line">          chip3_decode = <span class="number">2&#x27;b10</span>,</span><br><span class="line">          chip4_decode = <span class="number">2&#x27;b11</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(CS <span class="keyword">or</span> addr)</span><br><span class="line">    <span class="keyword">if</span> (CS)</span><br><span class="line">        &#123;cs1, cs2, cs3, cs4&#125; = <span class="number">4&#x27;b1111</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">case</span> (addr[<span class="number">7</span>:<span class="number">6</span>])</span><br><span class="line">            chip1_decode: &#123;cs1, cs2, cs3, cs4&#125; = <span class="number">4&#x27;b0111</span>;</span><br><span class="line">            chip2_decode: &#123;cs1, cs2, cs3, cs4&#125; = <span class="number">4&#x27;b1011</span>;</span><br><span class="line">            chip3_decode: &#123;cs1, cs2, cs3, cs4&#125; = <span class="number">4&#x27;b1101</span>;</span><br><span class="line">            chip4_decode: &#123;cs1, cs2, cs3, cs4&#125; = <span class="number">4&#x27;b1110</span>;</span><br><span class="line">        <span class="keyword">endcase</span>                       </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="comment">// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></p>
<p>综合后对应的结构示意图如下<a href="#图4-3">图 4-3</a> 所示。</p>
<p><a name="图4-3"></a></p>
<div data-align="center">
<img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-12-02-josh-verilog-part-4/2020-12-02-josh-verilog-part-4-030-CombinatorialLogictModeling.png!700px" alt="某组合逻辑译码电路的结构示意图"/>
</div></li>
<li><p><code>assign</code> 等语句描述的组合逻辑电路</p>
<p>这种形式描述组合逻辑电路适用于描述那些相对简单的组合逻辑。信号一般被定义为 <code>wire</code> 型，常用的 <code>assign</code> 结构除了直接赋值逻辑表达式外，还可以使用 <code>?</code> 语句。</p>
<p><figure class="highlight verilog"><figcaption><span>decode_cmb2.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment">使用 assign 结构描述该组合逻辑译码电路。</span></span><br><span class="line"><span class="comment">******************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> decode_cmb2 (addr, CS, cs1, cs2, cs3, cs4);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span>  [<span class="number">7</span>:<span class="number">0</span>]      addr;           <span class="comment">// only the 2 MSB bits used</span></span><br><span class="line"><span class="keyword">input</span>             CS;             <span class="comment">// Low effect</span></span><br><span class="line"><span class="keyword">output</span> cs1, cs2, cs3, cs4;        <span class="comment">// Low effect</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</span></span><br><span class="line"><span class="keyword">wire</span>   cs1, cs2, cs3, cs4;</span><br><span class="line"><span class="keyword">parameter</span> chip1_decode = <span class="number">2&#x27;b00</span>,</span><br><span class="line">          chip2_decode = <span class="number">2&#x27;b01</span>,</span><br><span class="line">          chip3_decode = <span class="number">2&#x27;b10</span>,</span><br><span class="line">          chip4_decode = <span class="number">2&#x27;b11</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> cs1 = (!CS &amp;&amp; (addr[<span class="number">7</span>:<span class="number">6</span>] == chip1_decode))? <span class="number">0</span> : <span class="number">1</span> ;  </span><br><span class="line"><span class="keyword">assign</span> cs2 = (!CS &amp;&amp; (addr[<span class="number">7</span>:<span class="number">6</span>] == chip2_decode))? <span class="number">0</span> : <span class="number">1</span> ;  </span><br><span class="line"><span class="keyword">assign</span> cs3 = (!CS &amp;&amp; (addr[<span class="number">7</span>:<span class="number">6</span>] == chip3_decode))? <span class="number">0</span> : <span class="number">1</span> ;  </span><br><span class="line"><span class="keyword">assign</span> cs4 = (!CS &amp;&amp; (addr[<span class="number">7</span>:<span class="number">6</span>] == chip4_decode))? <span class="number">0</span> : <span class="number">1</span> ;  </span><br><span class="line"><span class="comment">// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></p>
<p>该描述方式实现的电路同<a href="#图4-3">图 4-3 某组合逻辑译码电路的结构示意图</a>。</p></li>
</ol>
<div class="note ">
            <p>可以看到，对于简单的组合逻辑使用 <code>assign</code> 和 <code>?</code> 语句比较清晰。但是如果所描述的组合逻辑过于复杂，则需要很多条 <code>assign</code> 语句或者嵌套的 <code>?</code> 语句来描述，不易解读，此时推荐使用第一种组合逻辑建模方法。</p>
          </div>
<h2 id="双线端口与三态信号建模">3.4. 双线端口与三态信号建模</h2>
<p>前面谈到所有的<strong>双向总线（既作输出又作输出的总线）应该在顶层模块定义为三态信号，禁止在顶层以外的其他子层次定义双向端口</strong>。某些早期 EDA 软件和器件支持在子模块定义双向总线，实例化三态信号，其实从理论上讲任何子模块中定义的三态信号都可以迁移到顶层来。实际上，很多流行的综合工具也是对子模块定义的三态信号综合为选择器，将子模块例化的三态信号迁移到顶层。</p>
<p>为了避免仿真和综合实现结果不一致，并便于维护，强烈建议仅在顶层定义双向总线和例化的三态信号，禁止在除顶层以外的其他层次赋值高阻态 <code>Z</code>，在顶层将双向信号分为输入信号和输出信号两种类型，然后根据需要分别传递到不同的子模块中。这样做的另一个好处是便于描述仿真激励。</p>
<p>以下介绍几种典型的双向信号和三态信号的描述方法。</p>
<ol type="1">
<li><p>为了清晰起见，在顶层可以将一个双向总线分成输入和输出两条总线，然后分别引入子模块使用。</p>
<p><figure class="highlight verilog"><figcaption><span>bibus.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment">将双向总线 data_bus 分为输入总线 data_in 和输出总线 data_in, 然后分别使用。</span></span><br><span class="line"><span class="comment">******************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> bibus (clk, rst, sel, data_bus, addr);</span><br><span class="line"><span class="keyword">input</span>       clk, rst, sel;</span><br><span class="line"><span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>] addr;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</span></span><br><span class="line"><span class="keyword">inout</span> [<span class="number">7</span>:<span class="number">0</span>] data_bus;</span><br><span class="line"><span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] data_in, data_out;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> data_in = data_bus;</span><br><span class="line"><span class="keyword">assign</span> data_bus = (sel) ? data_out : <span class="number">8&#x27;bZ</span>;</span><br><span class="line"><span class="comment">// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑</span></span><br><span class="line"></span><br><span class="line">decode decode_inst (</span><br><span class="line">    <span class="variable">.clock</span> (clk),</span><br><span class="line">    <span class="variable">.reset</span> (rst),</span><br><span class="line">    <span class="variable">.data_bus_in</span> (data_in),</span><br><span class="line">    <span class="variable">.addr_bus</span> (addr),</span><br><span class="line">    <span class="variable">.data_bus_out</span> (data_out)</span><br><span class="line">    );</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></p>
<p>简单的三态信号用 <code>assign</code> 语法描述，如上述 <code>bibus.v</code> 代码中，描述三态总线为：</p>
<p><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">assign</span> data_bus = (sel) ? data_out : <span class="number">8&#x27;bZ</span>;</span><br></pre></td></tr></table></figure></p></li>
<li><p>如果三态总线的使能关系比较复杂，不是单一信号，此时可以使用嵌套的问号表达式，或者使用语句描述（当然也可以用 <code>if ... else</code> 结构）。</p>
<p><figure class="highlight verilog"><figcaption><span>complex_bibus.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment">双向总线 databus 的输出由 3 个使能信号 sel1、sel2、se13共同确定, 下述代码中中使用嵌</span></span><br><span class="line"><span class="comment">套的问号表达式描述了该三态总线的使能选择。</span></span><br><span class="line"><span class="comment">******************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> complex_bibus (clk, rst, sel1, sel2, sel3, data_bus, addr);</span><br><span class="line"><span class="keyword">input</span>       clk, rst;</span><br><span class="line"><span class="keyword">input</span>       sel1, sel2, sel3;</span><br><span class="line"><span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>] addr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] data_in;</span><br><span class="line"><span class="comment">//wire [7:0] data_out;         //use wire type</span></span><br><span class="line"><span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] decode_out;</span><br><span class="line"><span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] cnt_out;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> data_in = data_bus;</span><br><span class="line"></span><br><span class="line">decode decode_inst (</span><br><span class="line">    <span class="variable">.clock</span> (clk),</span><br><span class="line">    <span class="variable">.reset</span> (rst),</span><br><span class="line">    <span class="variable">.data_bus_in</span> (data_in),</span><br><span class="line">    <span class="variable">.addr_bus</span> (addr),</span><br><span class="line">    <span class="variable">.data_bus_out</span> (decode_out)</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">counter counter_inst (</span><br><span class="line">    <span class="variable">.clock</span> (clk),</span><br><span class="line">    <span class="variable">.reset</span> (rst),</span><br><span class="line">    <span class="variable">.data_bus_in</span> (data_in),</span><br><span class="line">    <span class="variable">.cnt_out</span> (cnt_out)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line"><span class="comment">// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</span></span><br><span class="line"><span class="keyword">inout</span> [<span class="number">7</span>:<span class="number">0</span>] data_bus;</span><br><span class="line"><span class="keyword">assign</span> data_bus = (sel1)? decode_out : ((sel2)? cnt_out : ((sel3)? <span class="number">8&#x27;b11111111</span>: </span><br><span class="line">    <span class="number">8&#x27;bZZZZZZZZ</span>));</span><br><span class="line"><span class="comment">// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></p>
<p>但是如果使能情况更复杂，就不宜再使用上述 <code>complex-bibus.v</code> 中嵌套的问号表达式了。更清晰的描述方法是 <code>case</code> 语句，</p></li>
<li><p>通过 <code>case</code> 语句可以清晰地罗列每种使能组合情况下的输出情况。</p>
<p><figure class="highlight verilog"><figcaption><span>complex_bibus2.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment">这种描述需要使到组合逻辑的模块，此时需要引入中间变量 data_out，并定义为 reg 型，</span></span><br><span class="line"><span class="comment">******************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> complex_bibus2 (clk, rst, sel1, sel2, sel3, data_bus, addr);</span><br><span class="line"><span class="keyword">input</span>       clk, rst;</span><br><span class="line"><span class="keyword">input</span>       sel1, sel2, sel3;</span><br><span class="line"><span class="keyword">input</span> [<span class="number">7</span>:<span class="number">0</span>] addr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> data_in = data_bus;</span><br><span class="line"></span><br><span class="line">decode decode_inst (</span><br><span class="line">    <span class="variable">.clock</span> (clk),</span><br><span class="line">    <span class="variable">.reset</span> (rst),</span><br><span class="line">    <span class="variable">.data_bus_in</span> (data_in),</span><br><span class="line">    <span class="variable">.addr_bus</span> (addr),</span><br><span class="line">    <span class="variable">.data_bus_out</span> (decode_out)</span><br><span class="line">    );</span><br><span class="line">                    </span><br><span class="line">counter counter_inst (</span><br><span class="line">    <span class="variable">.clock</span> (clk),</span><br><span class="line">    <span class="variable">.reset</span> (rst),</span><br><span class="line">    <span class="variable">.data_bus_in</span> (data_in),</span><br><span class="line">    <span class="variable">.cnt_out</span> (cnt_out)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line"><span class="comment">// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</span></span><br><span class="line"><span class="keyword">inout</span> [<span class="number">7</span>:<span class="number">0</span>] data_bus;</span><br><span class="line"></span><br><span class="line"><span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] data_in;</span><br><span class="line"><span class="keyword">reg</span>  [<span class="number">7</span>:<span class="number">0</span>] data_out;    <span class="comment">//use reg type, but not registers</span></span><br><span class="line"><span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] decode_out;</span><br><span class="line"><span class="keyword">wire</span> [<span class="number">7</span>:<span class="number">0</span>] cnt_out;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(decode_out <span class="keyword">or</span> cnt_out <span class="keyword">or</span> sel1 <span class="keyword">or</span> sel2 <span class="keyword">or</span> sel3) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">case</span> (&#123;sel1, sel2, sel3&#125;)</span><br><span class="line">        <span class="number">3&#x27;b100</span>:  data_out = decode_out;</span><br><span class="line">        <span class="number">3&#x27;b010</span>:  data_out = cnt_out;</span><br><span class="line">        <span class="number">3&#x27;b001</span>:  data_out = <span class="number">8&#x27;b11111111</span>;</span><br><span class="line">        <span class="keyword">default</span>: data_out = <span class="number">8&#x27;bZZZZZZZZ</span>;         </span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">             </span><br><span class="line"><span class="keyword">assign</span> data_bus = data_out;                    </span><br><span class="line"><span class="comment">// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></p>
<p>请注意，虽然输出的中间变量 <code>data_out</code>，被定义为 <code>reg</code> 型，但是在物理实现时它并不是寄存器，而是纯组合逻辑。引入这个变量的原因是 <code>inout</code> 类型的信号只能被定义为 <code>wire</code> 或 <code>tri</code> 型，不能在组合逻辑的 <code>always</code> 模块中直接赋值。</p>
<p><figure class="highlight verilog"><figcaption><span>counter.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment">三态实例中调用的子模块</span></span><br><span class="line"><span class="comment">******************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> counter (clock,</span><br><span class="line">                reset,</span><br><span class="line">                data_bus_in,</span><br><span class="line">                cnt_out</span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span>        clock, reset;</span><br><span class="line"><span class="keyword">input</span>  [<span class="number">7</span>:<span class="number">0</span>] data_bus_in;</span><br><span class="line"><span class="keyword">output</span> [<span class="number">7</span>:<span class="number">0</span>] cnt_out;</span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span>    [<span class="number">7</span>:<span class="number">0</span>] cnt_out;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clock <span class="keyword">or</span> <span class="keyword">posedge</span> reset)</span><br><span class="line">    <span class="keyword">if</span> (reset)</span><br><span class="line">        cnt_out &lt;= <span class="number">8&#x27;b00000000</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cnt_out &lt;= data_bus_in + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></p>
<p><figure class="highlight verilog"><figcaption><span>decode.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment">三态实例中调用的子模块</span></span><br><span class="line"><span class="comment">******************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> decode (clock, reset, data_bus_in, addr_bus, data_bus_out);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span>        clock, reset;</span><br><span class="line"><span class="keyword">input</span>  [<span class="number">7</span>:<span class="number">0</span>] data_bus_in;</span><br><span class="line"><span class="keyword">input</span>  [<span class="number">7</span>:<span class="number">0</span>] addr_bus;</span><br><span class="line"></span><br><span class="line"><span class="keyword">output</span> [<span class="number">7</span>:<span class="number">0</span>] data_bus_out;</span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span>    [<span class="number">7</span>:<span class="number">0</span>] data_bus_out;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clock <span class="keyword">or</span> <span class="keyword">posedge</span> reset)</span><br><span class="line">    <span class="keyword">if</span> (reset)</span><br><span class="line">        data_bus_out &lt;= <span class="number">8&#x27;b00000000</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">case</span> (addr_bus)</span><br><span class="line">            <span class="number">8</span>&#x27;b <span class="number">11110000</span>: data_bus_out &lt;= <span class="number">8&#x27;b00001111</span>;</span><br><span class="line">            <span class="number">8</span>&#x27;b <span class="number">00001111</span>: data_bus_out &lt;= <span class="number">8&#x27;b11110000</span>;</span><br><span class="line">            <span class="number">8</span>&#x27;b <span class="number">10100000</span>: data_bus_out &lt;= <span class="number">8&#x27;b11111111</span>;</span><br><span class="line">            <span class="keyword">default</span>:      data_bus_out &lt;= data_bus_in;</span><br><span class="line">        <span class="keyword">endcase</span></span><br><span class="line">                 </span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></p></li>
</ol>
<h2 id="mux-建模">3.5. mux 建模</h2>
<p>mux 也是一种组合逻辑电路，它的常用建模方式也有两种：对于简单的 mux，可以直接用 <code>assign</code> 和 <code>?</code> 表达式建模，对于复杂的 mux，则需要使用 <code>always</code> 和 <code>if ... else</code>、<code>case</code> 等条件判断语句建模。</p>
<ol type="1">
<li><p><strong>简单的 mux 用 <code>?</code> 表达式建模。信号被定义为 <code>wire</code> 型，<code>?</code> 表达式的判断条件是的选择端。</strong></p>
<p><figure class="highlight verilog"><figcaption><span>mux.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment">使用&quot;?&quot;表达式描述一个 2 选 1 的 mux。</span></span><br><span class="line"><span class="comment">******************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> mux (en, a, b, mux_out);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span>        en;</span><br><span class="line"><span class="keyword">input</span>        a, b;</span><br><span class="line"><span class="keyword">output</span>       mux_out;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</span></span><br><span class="line"><span class="keyword">wire</span> mux_out;</span><br><span class="line"><span class="keyword">assign</span> mux_out = (en)? a : b;</span><br><span class="line"><span class="comment">// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>复杂的 mux 用 <code>case</code> 或嵌套的 <code>if ... else</code> 建模。信号被定义为 <code>reg</code> 型，每个<code>case</code> 或 <code>if ... else</code> 的条件分支即一路 mux 的选择输出。</strong></p>
<p><figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment">使用 case 描述一个 4 选 1 的 mux。</span></span><br><span class="line"><span class="comment">******************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// mux2.v</span></span><br><span class="line"><span class="keyword">module</span> mux2 (en, a, b, c, d, mux_out);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span>  [<span class="number">1</span>:<span class="number">0</span>] en;</span><br><span class="line"><span class="keyword">input</span>        a, b, c, d;</span><br><span class="line"><span class="keyword">output</span>       mux_out;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</span></span><br><span class="line"><span class="keyword">reg</span> mux_out;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(en <span class="keyword">or</span> a <span class="keyword">or</span> b <span class="keyword">or</span> c <span class="keyword">or</span> d)</span><br><span class="line">    <span class="keyword">case</span>(en)</span><br><span class="line">        <span class="number">2&#x27;b00</span>:  mux_out = a;</span><br><span class="line">        <span class="number">2&#x27;b01</span>:  mux_out = b;</span><br><span class="line">        <span class="number">2&#x27;b10</span>:  mux_out = c;</span><br><span class="line">        <span class="number">2&#x27;b11</span>:  mux_out = d;</span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="comment">// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></p></li>
</ol>
<h2 id="存储器建模">3.6. 存储器建模</h2>
<p>逻辑电路设计经常使用一些单口 RAM，双口 RAM 和 ROM 等存储器。Verilog 语法中基本的存储单元定义格式为：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">reg</span> [datawidth] MemoryName [addresswidth];</span><br></pre></td></tr></table></figure>
<p>例如，定义一个数据位宽为 8bit，地址为 63 位的 RAM8x64，则可定义为：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] RAM8x64 [<span class="number">0</span>:<span class="number">63</span>];</span><br></pre></td></tr></table></figure>
<p>在使用存储单元时，不能直接操作存储器的某地址的某位，如想取地址为 <code>32</code> 的第 2 位和高两位，但是这两种描述都是错误的。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">RAM8x64 [<span class="number">32</span>][<span class="number">2</span>]</span><br><span class="line">RAM8x64 [<span class="number">32</span>][<span class="number">6</span>:<span class="number">7</span>]</span><br></pre></td></tr></table></figure>
<p>正确的操作方法是：<strong>先将存储单元赋值给某个寄存器，然后再对该寄存器的某位进行相关操作</strong>。如下例所示。</p>
<figure class="highlight verilog"><figcaption><span>ram_basic.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment">一个简单的 8 位宽, 64 位地址 RAM 的读/写电路，读的时候，先将 RAM8x64 某地址的数据读</span></span><br><span class="line"><span class="comment">到 mem_data 寄存器，然后就可以对寄存器的任意位进行相关操作。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">******************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> ram_basic (clk, CS, WR, addr, data_in, data_out, en);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span>         clk;</span><br><span class="line"><span class="keyword">input</span>         CS;           <span class="comment">// CS = 1, RAM enable</span></span><br><span class="line"><span class="keyword">input</span>         WR;           <span class="comment">// WR =1 then WRite enable; WR = 0 then read enable</span></span><br><span class="line"><span class="keyword">input</span>         en;           <span class="comment">// data_out enable, convert the data sequency</span></span><br><span class="line"><span class="keyword">input</span>  [<span class="number">5</span>:<span class="number">0</span>]  addr;</span><br><span class="line"><span class="keyword">input</span>  [<span class="number">7</span>:<span class="number">0</span>]  data_in;</span><br><span class="line"><span class="keyword">output</span> [<span class="number">7</span>:<span class="number">0</span>]  data_out;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] RAM8x64 [<span class="number">0</span>:<span class="number">63</span>];</span><br><span class="line"><span class="keyword">reg</span> [<span class="number">7</span>:<span class="number">0</span>] mem_data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk)</span><br><span class="line">    <span class="keyword">if</span> (WR &amp;&amp; CS)           <span class="comment">// write</span></span><br><span class="line">        RAM8x64 [addr] &lt;= data_in [<span class="number">7</span>:<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (~WR &amp;&amp; CS)     <span class="comment">// read</span></span><br><span class="line">        mem_data &lt;= RAM8x64 [addr]; </span><br><span class="line">      </span><br><span class="line"><span class="keyword">assign</span> data_out = (en)? mem_data[<span class="number">7</span>:<span class="number">0</span>] : &#123;~mem_data[<span class="number">7</span>], mem_data[<span class="number">6</span>:<span class="number">0</span>]&#125;;</span><br><span class="line"><span class="comment">// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>上面讲解的仅仅是 Verilog 语法建模存储单元的一般方法。而对于 PLD 设计、由于几乎所有的 FPGA 都内嵌有 RAM 资源，则<strong>并不推荐使用 Verilog 直接建模 RAM</strong>。FPGA 内嵌的 RAM 资源大致分为两类：块RAM（BIock RAM）资源和分布式 RAM 资源（Distributed RAM，是一种基于特殊底层逻辑单元，通过查找表和触发器实现的 RAM 结构）。PLD中使用存储结构的基本方法有两大类：</p>
<ul>
<li><p>第一种方法是：通过器件商的开发平台中内嵌的 <strong>IP 生成器</strong>，在图形化界面中直接选择存储器类型（如双口 RAM、单口 RAM、ROM、分布式 RAM 等），配置存储器参数，生产相应 IP，然后在用户逻辑中直接调用该 IP 即可。这种设计方法是 PLD 设计中推荐的方法，因为器件商最了解 PLD 的底层硬件结构，通过 IP 生成器，可以自动地选择使用 PLD 内嵌的 RAM 资源，并生成存储器的粘合逻辑（glue logic），方便、高效、可靠。</p></li>
<li><p>第二种方法是：直接根据上面的描述用 Verilog 语言建模存储器，由综合器根据代码描述类推并优化存储器结构，调用器件内嵌的硬件存储器资源。这种方法有两个问题：第一是要清晰合理地在代码中描述存储器，有一定的设计难度；第二是最终实现结果在很大的程度上取决于综合器的类推算法，有一定的不确定性。这种方法经常使用在两个场合；第一是 PLD 本身没有块 RAM 或分布式 RAM 等专用存储单元（如 CPLD 等）；第二是用户非常熟悉综合器的类推算法，并能通过综合器的相关约束属性指定所需使用的底层硬件 RAM 资源。</p></li>
</ul>
<h2 id="简单的时钟分频电路">3.7. 简单的时钟分频电路</h2>
<p>时钟电路是 PLD 设计的核心。在 Part 5 介绍了同步时序电路的相关知识，并介绍了如何处理一些常用时钟电路设计。</p>
<p>对于 PLD 设计而言，由于大多数 PLD（特别是FPGA）都内嵌有专用 PLL/DLL 模块，通过这些内嵌的 PLL 或 DLL，可以实现灵活的分频/倍频（一般可实现小数分频倍频）、移相等调整与运算。所以这类 PLD 设计时钟电路的方法如上小节一样，都推荐使用器件商的开发平台中内嵌的 IP 生成器，在图形化界面中直接配置 PLL/DLL 的参数，生产相应的 IP，然后在用户逻辑中直接调用该IP即可。</p>
<p>这里介绍的一般时钟分频电路建模方法，适用于没有上述内嵌 PLL/DLL 时钟电路（如 CPLD、ASIC 设计等），或内嵌 PLL/DLL 资源不能满足所需时钟关系时的一些处理方法。</p>
<p>一般来说，PLD 中的<strong>主要时钟处理为分频和移相</strong>。偶数分频十分简单，只需用高速时钟做一个同小计数器，然后在相应的位抽头即可。奇数分频电路相对复杂一些。移相的基本方法是通过高速时钟调整相位，或者通过时钟反向调整相位。</p>
<ol type="1">
<li><p><strong>偶数分频 + 相位控制</strong></p>
<p><figure class="highlight verilog"><figcaption><span>clk_div_phase.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment">将一个 200kHz 时钟做 2 分频、4 分频、8 分频, 要求分频后的 3 个时钟同相, 而且与源时</span></span><br><span class="line"><span class="comment">钟近似同相。在这个设计中, 因为输入时钟速率很低, 仅有 200kHz, 而一般 PLD 内嵌的 PLL </span></span><br><span class="line"><span class="comment">的输入频率下限都在 MHz 级，所以无法使用 PLL 完成分频与相位调整要求。另外对于低速时</span></span><br><span class="line"><span class="comment">钟的分频，使用计数器既能满足时序要求，也比较节约器件资源。</span></span><br><span class="line"><span class="comment">******************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> clk_div_phase (rst, clk_200K, clk_100K, clk_50K, clk_25K);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span>        clk_200K;</span><br><span class="line"><span class="keyword">input</span>        rst;</span><br><span class="line"><span class="keyword">output</span>       clk_100K, clk_50K, clk_25K;</span><br><span class="line"><span class="keyword">wire</span>         clk_100K, clk_50K, clk_25K;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">2</span>:<span class="number">0</span>] cnt;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk_200K <span class="keyword">or</span> <span class="keyword">negedge</span> rst)</span><br><span class="line">    <span class="keyword">if</span> (!rst)</span><br><span class="line">        cnt &lt;= <span class="number">3&#x27;b000</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cnt &lt;= cnt + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> clk_100K = ~cnt [<span class="number">0</span>];</span><br><span class="line"><span class="keyword">assign</span> clk_50K  = ~cnt [<span class="number">1</span>];</span><br><span class="line"><span class="keyword">assign</span> clk_25K  = ~cnt [<span class="number">2</span>];</span><br><span class="line"><span class="comment">// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></p>
<p>这个设计的<strong>难点在于如何调整所有时钟的相位关系</strong>。本例巧妙地通过对计数器每个 bit 的反向，完成了所有分频后时钟的相位调整，保证了3个分频后时钟的相位严格同相。对硬件结构比较清晰则会发现，这 3 个派生时钟与源时钟相比有一个非常小的相位差，<strong>这个相位差是由寄存器的固有 <span class="math inline">\(T_{\mathrm{co}}\)</span>（延迟）和计数器累加的组合逻辑造成的</strong>，一般来说在 PLD 中寄存器固有 <span class="math inline">\(T_{\mathrm{co}}\)</span> 的典型值为 1~2ns，而简单的加法运算的组合逻辑门延迟也约为 ns 级，这两个延迟的总和与时钟周期相比微乎其微。如果忽略这个 ns 级的延迟，则通过每个分频时钟的反向，使 3 个分频时钟与源时钟同相，也就是说这 4 个时钟有共同的上升沿。</p></li>
<li><p><strong>奇数分频</strong></p>
<p><figure class="highlight verilog"><figcaption><span>clk_3div.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment">对源时钟做 3 分频, 要求 3 分频时钟占空比为50％。</span></span><br><span class="line"><span class="comment">******************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> clk_3div (clk, reset, clk_out);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span>       clk, reset;</span><br><span class="line"><span class="keyword">output</span>      clk_out;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">1</span>:<span class="number">0</span>]   state;</span><br><span class="line"><span class="keyword">reg</span>         clk1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> reset)</span><br><span class="line">    <span class="keyword">if</span>(!reset)</span><br><span class="line">        state &lt;= <span class="number">2&#x27;b00</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">case</span>(state)</span><br><span class="line">            <span class="number">2&#x27;b00</span>:  state &lt;=  <span class="number">2&#x27;b01</span>;</span><br><span class="line">            <span class="number">2&#x27;b01</span>:  state &lt;=  <span class="number">2&#x27;b11</span>;</span><br><span class="line">            <span class="number">2&#x27;b11</span>:  state &lt;=  <span class="number">2&#x27;b00</span>;</span><br><span class="line">            <span class="keyword">default</span>:state &lt;=  <span class="number">2&#x27;b00</span>;</span><br><span class="line">        <span class="keyword">endcase</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">negedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> reset)</span><br><span class="line">    <span class="keyword">if</span>(!reset)</span><br><span class="line">        clk &lt;= <span class="number">1&#x27;b0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        clk1 &lt;= state[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> clk_out = state[<span class="number">0</span>] &amp; clk1;</span><br><span class="line"><span class="comment">// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span> </span><br></pre></td></tr></table></figure></p>
<p>3 分频、5 分频等奇数分频时钟可以使用 <code>case</code> 结构或简单的状态机（FSM）描述，设计<strong>难点在于如何通过组合逻辑调整分频时钟的占空比。</strong></p></li>
</ol>
<h2 id="串并转换建模">3.8. 串/并转换建模</h2>
<p>数据流串/并转换的实现方法多种多样，根据数据的排序和数量的要求，可以选用移位寄存器、RAM 等实现。对于<strong>数量比较小的设计可以采用移位寄存器</strong>完成串/并转换；对于<strong>排列顺序有规定的串/并转换，可以用 <code>case</code> 语句判断实现</strong>；对于<strong>复杂的串/并转换，还可以用状态机实现</strong>。</p>
<figure class="highlight verilog"><figcaption><span>srl2pal.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment">简单的串行到并行转换, 数据排列顺序是高位在前。</span></span><br><span class="line"><span class="comment">******************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> srl2pal (clk, rst, srl_in, pal_out);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span>        clk;</span><br><span class="line"><span class="keyword">input</span>        rst;</span><br><span class="line"><span class="keyword">input</span>        srl_in;</span><br><span class="line"><span class="keyword">output</span> [<span class="number">7</span>:<span class="number">0</span>] pal_out;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</span></span><br><span class="line"><span class="keyword">reg</span>    [<span class="number">7</span>:<span class="number">0</span>] pal_out;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @ (<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst)</span><br><span class="line">    <span class="keyword">if</span> (!rst)</span><br><span class="line">        pal_out &lt;= <span class="number">8&#x27;b0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pal_out &lt;= &#123;pal_out,srl_in&#125;;</span><br><span class="line"><span class="comment">// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="同步复位和异步复位">3.9. 同步复位和异步复位<a name="0309"></a></h2>
<p>复位电路是每个数字逻辑电路的最重要组成部分之一。复位的目的有两个方面：第一是仿真的时候使电路进入初始状态或者其他预知状态；第二是对于综合实现的真实电路，通过复位使电路进入初始状态或者其他预知状态。一般来说，逻辑电路的任何一个寄存器，存储器结构和其他逻辑单元都必须要附加复位逻辑以保证电路能够从错误状态中恢复，可靠地工作。</p>
<p><strong>常用的复位信号为低电平有效信号，在应用时外部引脚接<span class="label primary">上拉电阻</span>，这样能增加复位电路的抗干扰性能。</strong></p>
<p>复位方式大致分为两类：同步复位和异步复位。这两种复位方式各有优缺点，因而应用场合不同。</p>
<h3 id="同步复位">3.9.1. 同步复位</h3>
<p>所谓同步复位是指：当复位信号变化时，并<strong>不立即生效，只有当有效时钟沿采样到已变化的复位信号后，才对所有寄存器复位</strong>。同步复位的应用要点如下：</p>
<h4 id="同步复位电路建模">3.9.1.1. 同步复位电路建模</h4>
<ol type="1">
<li><p>指定<strong>同步复位时，<code>always</code> 的敏感表中仅有时钟沿信号</strong>，仅仅当时钟沿采到同步复位的有效电平时，才会在时钟沿到达时刻进行复位操作。如果目标器件或可用库中的触发器本身包含同步复位端口，则在实现时可用直接调用同步复位端。然而很多目标器件（如 PLD）和 ASIC 库的触发器本身并不包含同步复位端口，则复位信号与输入信号组成某种组合逻辑（比如复位低电平有效，则复位与输入信号两者相与即可），然后输入至寄存器的输入端。为了提高复位电路的优先级，一般在电路描述时使用带有优先级的 <code>if ... else</code> 结构，复位电路在第一个 <code>if</code> 下描述，其他电路在 <code>else</code> 或 <code>else ... if</code> 分支中描述。</p>
<p><figure class="highlight verilog"><figcaption><span>syn_rst.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment">同步复位电路建模。</span></span><br><span class="line"><span class="comment">******************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> syn_rst (clk, rst_, cnt1, cnt2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span>        clk;</span><br><span class="line"><span class="keyword">input</span>        rst_;</span><br><span class="line"><span class="keyword">output</span> [<span class="number">4</span>:<span class="number">0</span>] cnt1 , cnt2;</span><br><span class="line"><span class="keyword">reg</span>    [<span class="number">4</span>:<span class="number">0</span>] cnt1 , cnt2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk)</span><br><span class="line">    <span class="keyword">if</span> (!rst_) <span class="keyword">begin</span></span><br><span class="line">        cnt1 &lt;= <span class="number">4&#x27;b0</span>;</span><br><span class="line">        cnt2 &lt;= <span class="number">4&#x27;b0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (cnt1 &lt; <span class="number">2&#x27;b11</span>)</span><br><span class="line">            cnt1 &lt;= cnt1 + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cnt1 &lt;= cnt1;                </span><br><span class="line">        cnt2 &lt;= cnt1 - <span class="number">1</span>;      </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="comment">// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>很多目标器件（如 FPGA 和 CPLD）和 ASIC 库的触发器本身并不包含同步复位端口，则同步复位会被实现为如<a href="#图4-4">图 4-4</a> 所示的结构。</p>
<p><a name="图4-4"></a></p>
<div data-align="center">
<img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-12-02-josh-verilog-part-4/2020-12-02-josh-verilog-part-4-040-SynchronousReset-01.png!600px" alt="同步复位实现结构示意图"/>
</div></li>
</ol>
<h4 id="同步复位的优点">3.9.1.2. 同步复位的优点</h4>
<ul>
<li><p>同步复位利于基于周期机制的仿真器进行仿真。</p></li>
<li><p>使用同步复位可以设计 100% 的同步时序电路，利于时序分析，其综合结果的频率往往较高。</p></li>
<li><p>同步复位仅在时钟的有效沿生效，可以<strong>有效地避免因复位电路毛刺造成的亚稳态和错误</strong>。在进行复位和释放复位信号时，都是仅当时钟沿采到复位信号电平变化时才进行相关操作，如果复位信号树的组合逻辑出现了某种毛刺，此时时钟沿采样到毛刺的概率非常低，通过时钟沿采样，可以十分有效地过滤复位电路组合逻辑产生的毛刺，增强电路稳定性。</p>
<div class="note info">
            <p>同步时序电路的概念参见 Part 5 2.1 小节；亚稳态的概念参见 Part 5 2.2 小节。</p>
          </div></li>
</ul>
<h4 id="同步复位的缺点">3.9.1.3. 同步复位的缺点</h4>
<ul>
<li><p>很多目标器件（如 FPGA 和 CPLD）和 ASIC 库的触发器本身并不包含同步复位端口，使用同步复位会增加更多逻辑资源。</p></li>
<li><p>同步复位的最大问题在于必须保证复位信号的有效时间足够长，从而才能保证所有触发器都有效地复位。由于仅当时钟沿采样到复位信号时才会进行复位操作，所以<strong>同步复位信号的持续时间起码要大于设计的最长时钟周期</strong>，以保证所有时钟的有效沿都能采样到同步复位信号。其实仅仅保证同步复位信号的持续时间大于最慢的时钟周期还是不够的，设计中<strong>还要考虑到同步复位信号树通过所有相关组合逻辑路径的延时以及由于时钟布线产生的偏斜（skew）</strong>，只有同步复位大于时钟最大周期加上同步信号穿过的组合逻辑路径延迟加上时钟偏斜时，才能保证同步复位可靠、彻底。同步复位实现结构如下图所示，假设同步复位逻辑树组合逻辑的延时为 <span class="math inline">\(\mathtt{t1}\)</span>，复位信号传播路径的最大延迟为 <span class="math inline">\(\mathtt{t2}\)</span>，最慢时钟的周期为 <span class="math inline">\(\mathtt{Period max}\)</span>，时钟的 skew 为 <span class="math inline">\(\mathtt{(clk2 - clk1)}\)</span>，则同步复位的周期 <span class="math inline">\(\mathtt{Tsyn\_rst}\)</span> 应该满足下述公式： <span class="math display">\[
\mathtt{Tsyn\_rst &gt; Period max + \left(clk2 - clk1 \right) + t1 + t2}
\]</span></p></li>
</ul>
<a name="图4-5"></a>
<div data-align="center">
<p><img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-12-02-josh-verilog-part-4/2020-12-02-josh-verilog-part-4-050-SynchronousReset-02.png!800px" alt="同步复位实现结构示意图"/></p>
</div>
<h3 id="异步复位">3.9.2. 异步复位</h3>
<h4 id="异步复位电路建模">3.9.2.1. 异步复位电路建模</h4>
<ol type="1">
<li><p>指定异步复位时，只需在 <code>always</code> 的敏感表中加入复位信号的有效沿即可，当复位信号有效沿到达时，无论时钟沿是否有效，复位立即发挥功能。</p>
<p><figure class="highlight verilog"><figcaption><span>asyn_rst.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment">异步复位电路建模。</span></span><br><span class="line"><span class="comment">******************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> asyn_rst (clk, rst_, cnt1, cnt2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span>        clk;</span><br><span class="line"><span class="keyword">input</span>        rst_;</span><br><span class="line"><span class="keyword">output</span> [<span class="number">4</span>:<span class="number">0</span>] cnt1 , cnt2;</span><br><span class="line"><span class="keyword">reg</span>    [<span class="number">4</span>:<span class="number">0</span>] cnt1 , cnt2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> rst_)</span><br><span class="line">    <span class="keyword">if</span> (!rst_) <span class="keyword">begin</span></span><br><span class="line">        cnt1 &lt;= <span class="number">4&#x27;b0</span>;</span><br><span class="line">        cnt2 &lt;= <span class="number">4&#x27;b0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (cnt1 &lt; <span class="number">2&#x27;b11</span>)</span><br><span class="line">        cnt1 &lt;= cnt1 + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cnt1 &lt;= cnt1;                </span><br><span class="line">    cnt2 &lt;= cnt1 - <span class="number">1</span>;      </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="comment">// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure></p></li>
<li><p>大多数目标器件（如 FPGA 和 CPLD）和 ASIC 库的触发器都包含异步复位端口，异步复位会被直接接到触发器的异步复位端口。同步复位实现结构如<a href="#图4-6">图 4-6</a> 所示。</p></li>
</ol>
<a name="图4-6"></a>
<div data-align="center">
<p><img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-12-02-josh-verilog-part-4/2020-12-02-josh-verilog-part-4-060-AsynchronousReset-01.png!500px" alt="异步复位实现结构示意图"/></p>
</div>
<h4 id="异步复位的优点">3.9.2.2. 异步复位的优点</h4>
<ul>
<li><p>由于多数目标器件（如FPGA 和 CPLD）和 ASIC 库的触发器都包含异步复位端口，异步复位会节约逻辑资源。</p></li>
<li><p>异步复位设计简单。</p></li>
<li><p>对于大多数 FPGA, 都有专用的全局异步复位/置位资源（GSR, Global Set Reset），使用GSR 资源，异步复位到达所有寄存器的偏斜（skew）最小。</p></li>
</ul>
<h4 id="异步复位的缺点">3.9.2.3. 异步复位的缺点</h4>
<ul>
<li><p>异步复位的作用和释放与时钟沿没有直接关系，在异步复位生效时问题并不明显，但是当异步复位释放时，如果异步复位信号释放时间和时钟的有效沿到达时间几乎一致，则容易造成触发器输出为<strong>亚稳态</strong>，造成逻辑错误。</p></li>
<li><p>另外，如果异步复位逻辑树的组合逻辑产生了<strong>毛刺</strong>，则毛刺的有效沿会使触发器误复位，造成逻辑错误。</p></li>
</ul>
<h4 id="推荐的复位电路设计方式">3.9.2.4. 推荐的复位电路设计方式</h4>
<ol type="1">
<li><p>推荐的复位电路设计方式是异步复位，同步释放。这种方式，可以有效地继承异步复位设计简单的优势，并克服异步复位的上述风险与缺陷。</p></li>
<li><p>在 FPGA/CPLD 等可编程逻辑器件设计中，使用异步复位，同步释放可以节约器件资源，并获得稳定可靠地复位效果，是推荐的复位设计方式。</p></li>
</ol>
<figure class="highlight verilog"><figcaption><span>asyn_rst_syn_release.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment">异步复位，同步释放电路建模。异步复位，同步释放的具体设计方法很多，关键是如何保证同步</span></span><br><span class="line"><span class="comment">地释放复位信号，本例举例的方法是在复位信号释放时，用系统时钟采样后再将复位信号送到寄</span></span><br><span class="line"><span class="comment">存器的异步复位端。</span></span><br><span class="line"><span class="comment">******************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> asyn_rst_syn_release(clk, rst_, cnt1, cnt2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span>        clk;</span><br><span class="line"><span class="keyword">input</span>        rst_;</span><br><span class="line"><span class="keyword">output</span> [<span class="number">4</span>:<span class="number">0</span>] cnt1 , cnt2;</span><br><span class="line"><span class="keyword">reg</span>    [<span class="number">4</span>:<span class="number">0</span>] cnt1 , cnt2;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</span></span><br><span class="line"><span class="comment">// reset release circuit</span></span><br><span class="line"><span class="keyword">reg</span> reset_reg;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk)</span><br><span class="line">     reset_reg &lt;= rst_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">negedge</span> reset_reg)</span><br><span class="line">    <span class="keyword">if</span> (!rst_) <span class="keyword">begin</span></span><br><span class="line">        cnt1 &lt;= <span class="number">4&#x27;b0</span>;</span><br><span class="line">        cnt2 &lt;= <span class="number">4&#x27;b0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (cnt1 &lt; <span class="number">2&#x27;b11</span>)</span><br><span class="line">            cnt1 &lt;= cnt1 + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cnt1 &lt;= cnt1;                </span><br><span class="line">        cnt2 &lt;= cnt1 - <span class="number">1</span>;      </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="comment">// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>上例使用时钟<strong>将外部输入的异步复位信号寄存一个节拍</strong>后，再送到触发器异步复位端口的设计方法的另一个好处在于：做 STA（静态时序分析）分析时，时序工具会自动检查同步后的异步复位信号和时钟的到达（Recovery）/撤销（Removal）时间关系，如果因布线造成的 skew 导致该到达I撤销时间不能满足，STA工具会上报该路径，帮助设计者进一步分析问题。异步部位同步化电路如<a href="#图4-7">图 4-7</a> 所示。</p>
<a name="图4-7"></a>
<div data-align="center">
<p><img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-12-02-josh-verilog-part-4/2020-12-02-josh-verilog-part-4-070-AsynchronousReset-02.png!500px" alt="异步复位同步化"/></p>
</div>
<h2 id="用-case-和-if-...-else-建模">3.10. 用 <code>case</code> 和 <code>if ... else</code> 建模</h2>
<p>一般来说， <code>case</code> 语句是“平行”（Balance, Parallel）的结构，即每个 <code>case</code> 分支的条件判断和执行都是并行的，没有“优先级（Prior）” 。而 <code>if ... else</code>、<code>if ... else if ...</code> 语句可以建模<strong>无优先级</strong>的判断结构， <code>if ... if ... if ...</code> 结构可以建模具<strong>有优先级</strong>的判断结构。</p>
<p>一般来说，建立优先级结构（优先级树）会消耗组合逻辑资源，如果非设计需要，推荐使用 <code>case</code> 或 <code>if ... else</code> 建立无优先级的判断结构。但是某些设计中，有些信号要求先到达（如：关键使能信号、选择信号等），而有些信号需要后到达（如：慢速信号、有效时间较长的信号等），此时则需要使用 <code>if ... if ...</code> 结构建立具有优先级的判断结构。</p>
<p>目前综合工具的优化能力越来越强，大多数情况下可以将不必要的优先级树优化掉，综合结果是否具有优先级，很大的程度上取决于综合工具的类型、综合工具的版本、目标器件（目标库）的固有硬件结构。</p>
<p>为了形象地理解优先级判断结构建模的问题，下面使用几个简单的例子，分别使用业界最流行的两个综合工具 Synplify Pro 和 Precision RTL 分别综合，分析其综合结果的 RTL 视图和结构视图（初学者不用关心这两个综合工具的使用方法，而需要重点观察综合结果的 RTL 视图和结构视图，分析不同语句建模的区别）。</p>
<figure class="highlight verilog"><figcaption><span>case1.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment">casex语句建模</span></span><br><span class="line"><span class="comment">******************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> case1(a, b, c, d, sel0, sel1, sel2, sel3, z);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span> a, b, c, d;</span><br><span class="line"><span class="keyword">input</span> sel0, sel1, sel2, sel3;</span><br><span class="line"><span class="keyword">output</span> z;</span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span> z;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</span></span><br><span class="line"><span class="keyword">always</span> @(a <span class="keyword">or</span> b <span class="keyword">or</span> c <span class="keyword">or</span> d <span class="keyword">or</span> sel0, sel1, sel2, sel3) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">casex</span> (&#123;sel0, sel1, sel2, sel3&#125;)</span><br><span class="line">        <span class="number">4&#x27;b1xxx</span>: z = d;</span><br><span class="line">        <span class="number">4&#x27;bx1xx</span>: z = c;</span><br><span class="line">        <span class="number">4&#x27;bxx1x</span>: z = b;</span><br><span class="line">        <span class="number">4&#x27;bxxx1</span>: z = a;</span><br><span class="line">        <span class="keyword">default</span>: z = <span class="number">1&#x27;b0</span>;</span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<figure class="highlight verilog"><figcaption><span>single_if.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment">单if语句(if ... else if ... else if ...)建模</span></span><br><span class="line"><span class="comment">******************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> single_if(a, b, c, d, sel0, sel1, sel2, sel3, z);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span> a, b, c, d;</span><br><span class="line"><span class="keyword">input</span> sel0, sel1, sel2, sel3;</span><br><span class="line"><span class="keyword">output</span> z;</span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span> z;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</span></span><br><span class="line"><span class="keyword">always</span> @(a <span class="keyword">or</span> b <span class="keyword">or</span> c <span class="keyword">or</span> d <span class="keyword">or</span> sel0 <span class="keyword">or</span> sel1 <span class="keyword">or</span> sel2 <span class="keyword">or</span> sel3) <span class="keyword">begin</span></span><br><span class="line">    z = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (sel3)</span><br><span class="line">        z = d;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (sel2)</span><br><span class="line">        z = c;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (sel1)</span><br><span class="line">        z = b;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (sel0)</span><br><span class="line">        z = a;                                                    </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<figure class="highlight verilog"><figcaption><span>mult_if.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment">多if语句(if ... if ... if ...)建模</span></span><br><span class="line"><span class="comment">******************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> mult_if(a, b, c, d, sel0, sel1, sel2, sel3, z);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span> a, b, c, d;</span><br><span class="line"><span class="keyword">input</span> sel0, sel1, sel2, sel3;</span><br><span class="line"><span class="keyword">output</span> z;</span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span> z;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</span></span><br><span class="line"><span class="keyword">always</span> @(a <span class="keyword">or</span> b <span class="keyword">or</span> c <span class="keyword">or</span> d <span class="keyword">or</span> sel0 <span class="keyword">or</span> sel1 <span class="keyword">or</span> sel2 <span class="keyword">or</span> sel3) <span class="keyword">begin</span></span><br><span class="line">    z = <span class="number">0</span>;                <span class="comment">// must add default value</span></span><br><span class="line">    <span class="keyword">if</span> (sel0) z = a;</span><br><span class="line">    <span class="keyword">if</span> (sel1) z = b;</span><br><span class="line">    <span class="keyword">if</span> (sel2) z = c;</span><br><span class="line">    <span class="keyword">if</span> (sel3) z = d;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>上面的描述如果在 Synopsys 公司的 Design compiler 或 FPGA Compiler 等综合工具的较早版本下综合，多<code>if</code> 语句（<code>if ... if ... if ...</code>）综合结构如<a href="#图4-8">图 4-8</a> 所示，而单 <code>if</code> 语旬（<code>if ... else if ... else if ...</code>）和 <code>casex</code> 语句综合结构如<a href="#图4-9">图 4-9</a> 所示。从图中分析河以看到多if 语句建模结构带有优先级，这时最后一条 <code>if</code> 语句对应的 <code>sel3</code> 和 <code>d</code> 的优先级最高；而单 <code>if</code> 语句和 <code>casex</code> 语句建模时没有建立优先级。</p>
<a name="图4-8"></a>
<div data-align="center">
<p><img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-12-02-josh-verilog-part-4/2020-12-02-josh-verilog-part-4-080-MultipleIf.png!800px" alt="多 if 语句 Design Compiler 综合结构视图"/></p>
</div>
<a name="图4-9"></a>
<div data-align="center">
<p><img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-12-02-josh-verilog-part-4/2020-12-02-josh-verilog-part-4-090-SingleIf.png!800px" alt="单 if 语句和 casex 语句建模使用 Design Compiler 综合结构视图"/></p>
</div>
<p>但是由于综合工具的综合优化策略不同，即使对于相同的代码，其综合结果也不尽相同。为了加深理解，使用业界最流行的 PLD 综合工具 Synplify Pro 和 Precision RTL 对多 <code>if</code> 语句（<code>if ... if ... if ...</code>）、单 <code>if</code> 语句（<code>if ... else if ... else if ...</code>）和 <code>casex</code> 语句分别综合，其中多 <code>if</code> 语句的 Synplify Pro 综合结果对应的 RTL 视图和工艺结构视图分别如<a href="#图4-10">图 4-10</a>、<a href="#图4-11">图 4-11</a> 所示；多 <code>if</code> 语句的 Precision RTL 综合结果对应的 RTL 视图和工艺结构视图分别如<a href="#图4-12">图 4-12</a>、<a href="#图4-13">图 4-13</a> 所示。简单分析即可发现，这 3 种语句的 Synplify Pro 和 Precision RTL 综合结果基本一致，都没有明显的优先级结构。这是因为 Synplify Pro 和Precision RTL 这两种综合工具为了节约硬件资源，根据其优化算法．优化掉了冗余的优先级判断结构。</p>
<a name="图4-10"></a>
<div data-align="center">
<p><img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-12-02-josh-verilog-part-4/2020-12-02-josh-verilog-part-4-100-MultipleIfSynplifyProRTLView.png!600px" alt="多 if 语句的 Synplify Pro 综合结果 RTL 视图"/></p>
</div>
<a name="图4-11"></a>
<div data-align="center">
<p><img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-12-02-josh-verilog-part-4/2020-12-02-josh-verilog-part-4-110-MultipleIfSynplifyProTechView.png!800px" alt="多 if 语句的 Synplify Pro 综合结果工艺结构视图"/></p>
</div>
<a name="图4-12"></a>
<div data-align="center">
<p><img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-12-02-josh-verilog-part-4/2020-12-02-josh-verilog-part-4-120-MultipleIfPrecisionRTLRTLView.png!800px" alt="多 if 语句的 Precision RTL 综合结果 RTL 视图"/></p>
</div>
<a name="图4-13"></a>
<div data-align="center">
<p><img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-12-02-josh-verilog-part-4/2020-12-02-josh-verilog-part-4-130-MultipleIfPrecisionRTLTechView.png!800px" alt="多 if 语句的 Precision RTL 综合结果工艺结构视图"/></p>
</div>
<p>所以，从语法上讲，多 <code>if</code> 语句（<code>if ... if ... if ...</code>）可以建模具有优先级的条件判断结构，而单 <code>if</code> 语句（<code>if ... else if ... else if ...</code>）和 <code>case</code> 语旬用于建模不带优先级的条件判断。但是随着综合工具优化能力的不断增强，新型的综合工具，大多时候会自动优化掉优先级结构，以减少芯片面积，提高时序性能。条件结构的综合结果是否带有优先级不但取决于综合工具的类型和版本．还和目标器件或目标库有直接关系。</p>
<p>这里推荐初学者尽量使用 <code>case</code> 或单 <code>if</code> 语句（<code>if ... else if ... else if ...</code>）建模判断结构，这样不论何种综合工具， 一般情况下都不会产牛不必要的优先级结构。使用单 <code>if</code> 结构．如果没有为所有的 <code>if</code> 指定默认的输出，则会生成 Latch（锁存器），如将上例代码删除 <code>z=0</code> 这一默认输出，而改为下面的描述，则会生成 Latch。使用 Synplify Pro 综合的综合结果的RTL 视图和工艺结构视图分别如<a href="#图4-14">图 4-14</a> 、<a href="#图4-15">图 4-15</a> 所示。</p>
<figure class="highlight verilog"><figcaption><span>mult_if.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment">多if语句(if ... if ... if ...)建模, 未指定默认输出, 生成 Latch</span></span><br><span class="line"><span class="comment">******************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> mult_if(a, b, c, d, sel0, sel1, sel2, sel3, z);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span> a, b, c, d;</span><br><span class="line"><span class="keyword">input</span> sel0, sel1, sel2, sel3;</span><br><span class="line"><span class="keyword">output</span> z;</span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span> z;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</span></span><br><span class="line"><span class="keyword">always</span> @(a <span class="keyword">or</span> b <span class="keyword">or</span> c <span class="keyword">or</span> d <span class="keyword">or</span> sel0 <span class="keyword">or</span> sel1 <span class="keyword">or</span> sel2 <span class="keyword">or</span> sel3) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (sel0) z = a;</span><br><span class="line">    <span class="keyword">if</span> (sel1) z = b;</span><br><span class="line">    <span class="keyword">if</span> (sel2) z = c;</span><br><span class="line">    <span class="keyword">if</span> (sel3) z = d;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<a name="图4-14"></a>
<div data-align="center">
<p><img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-12-02-josh-verilog-part-4/2020-12-02-josh-verilog-part-4-140-MultipleIfSynplifyProRTLView.png!800px" alt="多 if 语句无默认输出时 Synplify Pro 综合结果 RTL 视图"/></p>
</div>
<a name="图4-15"></a>
<div data-align="center">
<p><img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-12-02-josh-verilog-part-4/2020-12-02-josh-verilog-part-4-150-MultipleIfSynplifyProTechView.png!800px" alt="多 if 语句无默认输出时 Synplify Pro 综合结果工艺结构视图"/></p>
</div>
<p>如果生成的 Latch 并非设计者意愿，则会造成与设计意图的偏离甚至是错误。而使用完整的 <code>if. .. else</code> 或 <code>case</code>（全译码或加有 <code>default</code> 关键字）语句，则可以有效地避免无意之中生成的 Latch 。在<a href="https://josh-gao.top/posts/fd117896.html#3-4-%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B%E8%AF%AD%E6%97%AC">《Part 3 —— 描述方式和设计层次》的 3.4 小节</a>也有防止产生不必要 Latch 的相关描述，可以参考。</p>
<h2 id="可综合的-verilog-语法子集">3.11. 可综合的 Verilog 语法子集</h2>
<p>通过上节建模的感性认识，可以发现，在RTL 级建模时，使用的可综合的 Verilog 语法是整个 Verilog 语法的一个非常小的子集。其实可综合的 Verilog 常用的关键字非常有限，这恰恰体现了 Verilog 语言是硬件描述语言的本质。Verilog HDL 作为硬件描述语言，其本质在于把硬件电路流畅、合理地转换为语言形式，而使用较少的一些关键字就可以有效地将电路转换到可综合的RTL 语言结构。</p>
<p>常用的RTL 语法结构列举如下：</p>
<ul>
<li>模块声明：<code>module ... endmodule</code>；</li>
<li>端口声明：<code>input</code>、<code>output</code>、<code>inout</code>；</li>
<li>信号类型： <code>wire</code>、<code>reg</code>、<code>tri</code>等， <code>integer</code> 通常用于 <code>for</code> 语句中的索引；</li>
<li>参数定义： <code>parameter</code>；</li>
<li>运算操作符：各种逻辑操作、移位操作、算术操作符，请参考<a href="https://josh-gao.top/posts/fd2ca242.html#10-%E6%93%8D%E4%BD%9C%E6%95%B0%E3%80%81%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%92%8C%E8%A1%A8%E8%BE%BE%E5%BC%8F">《Part 2 —— Verilog 语言基础》的第 10 小节</a>；</li>
<li>比较判断： <code>case [default] endcase (casex/casez)</code>、<code>if ... else ...</code>；</li>
<li>连续赋值： <code>assign</code>、问号表达式；</li>
<li>always 模块：建模时序和组合逻辑（敏感表为电平或 <code>posedge</code> 或 <code>negedge</code> 的沿信号）；</li>
<li>语法分割符： <code>begin ... end</code>；</li>
<li>任务定义：<code>tast. .. end task</code>；</li>
<li>循环语句： <code>for</code>。</li>
</ul>
<p>这些关键字的语法在<a href="https://josh-gao.top/posts/fd2ca242.html">《Part 2 —— Verilog 语言基础》</a>和<a href="https://josh-gao.top/posts/fd117896.html">《Part 3 —— 描述方式和设计层次》</a>中都有详细介绍，请参考这部分内容。</p>
<h1 id="小结">4. 小结</h1>
<p>本篇笔记中首先介绍了 RTL 和综合的基本概念。然后摆脱长篇大论的理论说教模式，通过一个个具体范例，力图使初学者逐步建立起可综合 RTL 子集的概念。希望大家认真琢磨常用电路结构的建模方法，在实践中掌握 RTL 级设计的基本技巧。</p>
]]></content>
      <categories>
        <category>Verilog</category>
        <category>Josh 的学习笔记</category>
        <category>Verilog</category>
      </categories>
      <tags>
        <tag>Verilog</tag>
        <tag>HDL</tag>
        <tag>非阻塞赋值</tag>
        <tag>阻塞赋值</tag>
        <tag>组合逻辑</tag>
        <tag>三态</tag>
        <tag>同步复位</tag>
        <tag>异步复位</tag>
        <tag>条件语句</tag>
      </tags>
  </entry>
  <entry>
    <title>Josh 的学习笔记之 Verilog（Part 5 —— RTL 设计与编码指导）</title>
    <url>/posts/53b8b42e.html</url>
    <content><![CDATA[<p>在<a href="https://josh-gao.top/posts/ecb88422.html">《Part 4 —— RTL 概念与常用 RTL 建模》</a>中，通过具体的 RTL 建模建立了一些对 RTL 级描述的一些感性认识，本文将较深入地探讨一些 RTL 设计的基本规律。RTL 设计规律与方法是一个非常大的论题，在此不可能面面俱到，希望通过本文的介绍，引起大家的注意。如果大家能在日后的工作实践中，不断积累，有意识地积累基本设计原则、设计思想，将取得事半功倍的效果！</p>
<h1 id="一般性指导原则">1. 一般性指导原则</h1>
<p>RTL 级设计的评判标准有很多，如时序性能、所占面积、可测试性、可重要性、功耗、时钟域的分配、复位信号设计、是否与所用 EDA 工具匹配等。如果设计目标是在 FPGA 或 CPLD 等可编程逻辑器件上实现，则还需考虑是否能发挥这些 PLD 的结构特点等。根据以上所述这些目标的组合和优先级可以派生出很多不同的设计原则。这里仅仅讨论一般意义的指导原则。</p>
<p>这里抛砖引玉地提出 4 个基本设计原则，这些指导原则范畴非常广，不仅仅是要学习它们，更重要的是理解，并在今后的工作实践中充实、完善。</p>
<ol type="1">
<li><p><strong>面积和速度的平衡与互换原则</strong></p>
<p>面积和速度的平衡与互换原则提出了 RTL 设计的两个基本目标，并探讨了这两个目标对立统一的矛盾关系。</p></li>
<li><p><strong>硬件原则</strong></p>
<p>硬件原则重点在于提醒读者转化软件设计的思路，理解 HDL 语言设计的本质。</p></li>
<li><p><strong>系统原则</strong></p>
<p>系统原则希望读者能够通过全局、整体上把握设计，从而提高设计质址，优化设计效果。</p></li>
<li><p><strong>同步设计原则</strong></p>
<p>同步设计原则是设计时序稳定的基本要求，也是高速 RTL 设计的通用法则。</p></li>
</ol>
<a id="more"></a>
<h2 id="面积和速度的平衡与互换原则">1.1 面积和速度的平衡与互换原则</h2>
<p>这里“面积”是指一个设计所消耗的目标器件（如 FPGA/CPLD/ASIC 等）的硬件资源数量：</p>
<ul>
<li>对于 FPGA，可以用所消耗的触发器（FF）和查找表（LUT）来衡扯；</li>
<li>对于 CPLD，常用宏单元（MC）衡量；</li>
<li>对于 ASIC 可以用设计的系统门衡量。</li>
</ul>
<p>“速度”指设计在芯片上稳定运行时所能够达到的最高频率，这个频率由设计的时序状况决定，与设计满足的时钟周期、PAD to PAD Time、Clock Setup Time、Clock Hold Time 和 Clock-to-Output Delay 等众多时序特征量密切相关。</p>
<div class="note ">
            <p>面积（Area）和速度（Speed）这两个指标贯穿着 RTL 设计的始终，是设计质量评价的终极标准。</p>
          </div>
<p>这里就讨论一下设计中关于面积和速度的基本原则：<span class="label primary">面积和速度的平衡与互换</span>。</p>
<p>面积和速度是一对对立统一的矛盾体。要求一个设计同时具备设计面积最小，运行频率最高，这是不现实的。科学的设计目标应该是在满足设计时序要求（包含对设计最高频率的要求）的前提下，占用最小的芯片面积，或者在所规定的面积下，使设计的时序余量更大、频率更高。这两种目标充分体现了面积和速度的平衡思想。关于面积和速度的要求，不应该简单地理解为工程师水平的提高和设计完美性的追求，而应该认识到它们是和产品的质量、成本直接相关的。<strong>如果设计的时序余量比较大，运行的频率比较高，则意味着设计的健壮性更强，整个系统的质量更有保证；另一方面，设计所消耗的面积更小，则意味着在单位芯片上实现的功能模块更多，需要的芯片数量更少，整个系统的成本也随之大幅度削减。</strong></p>
<p>作为矛盾的两个组成部分，面积和速度的地位是不一样的。相比之下，满足时序、工作频率的要求更重要一些，当两者冲突时，采用<strong>速度优先</strong>的准则。</p>
<p>面积和速度的互换是 RTL 设计的一个重要思想。从理论上讲，一个设计如果时序余量较大，所能跑的频率远远高于设计要求，那么就能通过功能模块复用减少整个设计消耗的芯片面积，这就是<strong>用速度的优势换面积的节约</strong>；反之，如果一个设计的时序要求很高，普通方法达不到设计频率，那么一般可以通过将数据流串/并转换，并行复制多个操作模块，对整个设计采取“乒乓操作”和“串/并转换”的思想进行处理，在芯片输出模块处再对数据进行“并/串转换”。从宏观上看，整个芯片满足了处理速度的要求，这相当于<strong>用面积复制换取速度的提高</strong>。面积和速度互换的具体操技巧很多，比如模块复用、“乒乓操作”、“串/并转换”等，需要在工作中不断积累。下面举例说明如何使用“速度换面积”和“面积换速度”。</p>
<h3 id="用速度的优势换面积的节约举例">1.1.1 “用速度的优势换面积的节约”举例</h3>
<p>WCDMA（宽带码分多址）系统中使用到了快速哈达码（Fast Hadamard Transform, FHT）运算， FHT 由 4 步相同的算法完成，如<a href="#图5-1">图 5-1</a> 所示。</p>
<a name="图5-1"></a>
<div data-align="center">
<p><img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-12-05-josh-verilog-part-5/2020-12-05-josh-verilog-part-5-010-FastHadamardTransform.png!sign" alt="FHT 原理图"/></p>
</div>
<p>FHT 单步算法如下：</p>
<p><span class="math display">\[
\begin{aligned}
&amp;\mathrm{Out}[2i]=\mathrm{In}[2i] + \mathrm{In}[2i+8],&amp;i=0\sim7\\
&amp;\mathrm{Out}[2i+1]=\mathrm{In}[2i+1] - \mathrm{In}[2i+1+8],&amp;i=0\sim7
\end{aligned}
\]</span></p>
<p>考虑流水线式数据处理的要求，最自然的设计方法就是设计不同端口宽度的 4 个单步 FHT，并用将这 4 个单步模块串联起来，从而完成数据流的流水线处理。该 FHT 实现方式的代码如下：</p>
<figure class="highlight verilog"><figcaption><span>fhtpart.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment">该模块是 FHT 的顶层，调用 4 个不同端口宽度的单步 FHT 模块，完成整个 FHT 算法</span></span><br><span class="line"><span class="comment">******************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> fhtpart(</span><br><span class="line">    Clk,Reset,FhtStarOne,FhtStarTwo,FhtStarThree,FhtStarFour,</span><br><span class="line">    I0,I1,I2,I3,I4,I5,I6,I7,I8,</span><br><span class="line">    I9,I10,I11,I12,I13,I14,I15,</span><br><span class="line">    Out0,Out1,Out2,Out3,Out4,Out5,Out6,Out7,Out8,</span><br><span class="line">    Out9,Out10,Out11,Out12,Out13,Out14,Out15</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span>           Clk;                <span class="comment">// 设计的主时钟</span></span><br><span class="line"><span class="keyword">input</span>           Reset;              <span class="comment">// 异步复位</span></span><br><span class="line"><span class="keyword">input</span>           FhtStarOne,FhtStarTwo,FhtStarThree,FhtStarFour;</span><br><span class="line">                                    <span class="comment">// 4 个单步算法的时序控制信号</span></span><br><span class="line">                                    </span><br><span class="line"><span class="comment">// FHT 的 16 个输入</span></span><br><span class="line"><span class="keyword">input</span>   [<span class="number">11</span>:<span class="number">0</span>]  I0,I1,I2,I3,I4,I5,I6,I7,I8;</span><br><span class="line"><span class="keyword">input</span>   [<span class="number">11</span>:<span class="number">0</span>]  I9,I10,I11,I12,I13,I14,I15; </span><br><span class="line">                                    </span><br><span class="line"><span class="comment">// FHT 的 16 个输出</span></span><br><span class="line"><span class="keyword">output</span>  [<span class="number">15</span>:<span class="number">0</span>]  Out0,Out1,Out2,Out3,Out4,Out5,Out6,Out7;</span><br><span class="line"><span class="keyword">output</span>  [<span class="number">15</span>:<span class="number">0</span>]  Out8,Out9,Out10,Out11,Out12,Out13,Out14,Out15;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第 1 次 FHT 单步运算的输出</span></span><br><span class="line"><span class="keyword">wire</span>    [<span class="number">12</span>:<span class="number">0</span>]  m0,m1,m2,m3,m4,m5,m6,m7,m8,m9;</span><br><span class="line"><span class="keyword">wire</span>    [<span class="number">12</span>:<span class="number">0</span>]  m10,m11,m12,m13,m14,m15;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第 2 次 FHT 单步运算的输出</span></span><br><span class="line"><span class="keyword">wire</span>    [<span class="number">13</span>:<span class="number">0</span>]  mm0,mm1,mm2,mm3,mm4,mm5,mm6,mm7,mm8,mm9;</span><br><span class="line"><span class="keyword">wire</span>    [<span class="number">13</span>:<span class="number">0</span>]  mm10,mm11,mm12,mm13,mm14,mm15;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第 3 次 FHT 单步运算的输出</span></span><br><span class="line"><span class="keyword">wire</span>    [<span class="number">14</span>:<span class="number">0</span>]  mmm0,mmm1,mmm2,mmm3,mmm4,mmm5,mmm6,mmm7,mmm8,mmm9;</span><br><span class="line"><span class="keyword">wire</span>    [<span class="number">14</span>:<span class="number">0</span>]  mmm10,mmm11,mmm12,mmm13,mmm14,mmm15;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第 4 次 FHT 单步运算的输出</span></span><br><span class="line"><span class="keyword">wire</span>    [<span class="number">15</span>:<span class="number">0</span>]  Out0,Out1,Out2,Out3,Out4,Out5,Out6,Out7,Out8,Out9;</span><br><span class="line"><span class="keyword">wire</span>    [<span class="number">15</span>:<span class="number">0</span>]  Out10,Out11,Out12,Out13,Out14,Out15;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第 1 次 FHT 单步运算</span></span><br><span class="line">fht_unit1 fht_unit1(</span><br><span class="line">    Clk,Reset,FhtStarOne,</span><br><span class="line">    I0,I1,I2,I3,I4,I5,I6,I7,I8,I9,I10,I11,I12,</span><br><span class="line">    I13,I14,I15,</span><br><span class="line">    m0,m1,m2,m3,m4,m5,m6,m7,m8,m9,m10,m11,m12,</span><br><span class="line">    m13,m14,m15</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第 2 次 FHT 单步运算</span></span><br><span class="line">fht_unit2 fht_unit2(</span><br><span class="line">    Clk,Reset,FhtStarTwo,</span><br><span class="line">    m0,m1,m2,m3,m4,m5,m6,m7,m8,m9,m10,m11,m12,</span><br><span class="line">    m13,m14,m15,</span><br><span class="line">    mm0,mm1,mm2,mm3,mm4,mm5,mm6,mm7,mm8,mm9,mm10,mm11,mm12,</span><br><span class="line">    mm13,mm14,mm15</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第 3 次 FHT 单步运算</span></span><br><span class="line">fht_unit3 fht_unit3(</span><br><span class="line">    Clk,Reset,FhtStarThree,</span><br><span class="line">    mm0,mm1,mm2,mm3,mm4,mm5,mm6,mm7,mm8,mm9,mm10,mm11,mm12,</span><br><span class="line">    mm13,mm14,mm15,</span><br><span class="line">    mmm0,mmm1,mmm2,mmm3,mmm4,mmm5,mmm6,mmm7,mmm8,mmm9,mmm10,mmm11,mmm12,</span><br><span class="line">    mmm13,mmm14,mmm15</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第 4 次 FHT 单步运算</span></span><br><span class="line">fht_unit4 fht_unit4(</span><br><span class="line">    Clk,Reset,FhtStarFour,</span><br><span class="line">    mmm0,mmm1,mmm2,mmm3,mmm4,mmm5,mmm6,mmm7,mmm8,mmm9,mmm10,mmm11,mmm12,</span><br><span class="line">    mmm13,mmm14,mmm15,</span><br><span class="line">    Out0,Out1,Out2,Out3,Out4,Out5,Out6,Out7,Out8,Out9,Out10,Out11,Out12,</span><br><span class="line">    Out13,Out14,Out15</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>单步 FHT 运算举例如下（仅举例第 1 步的模块）：</p>
<figure class="highlight verilog"><figcaption><span>fht_unit1.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment">第 1 次 FHT 单步运算</span></span><br><span class="line"><span class="comment">******************************/</span></span><br><span class="line"><span class="keyword">module</span> fht_unit1(</span><br><span class="line">    Clk,Reset,FhtStar,</span><br><span class="line">    In0,In1,In2,In3,In4,In5,In6,In7,In8,In9,In10,In11,In12,</span><br><span class="line">    In13,In14,In15,</span><br><span class="line">    Out0,Out1,Out2,Out3,Out4,Out5,Out6,Out7,Out8,Out9,Out10,Out11,Out12,</span><br><span class="line">    Out13,Out14,Out15</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span>           Clk;        <span class="comment">// 设计的主时钟</span></span><br><span class="line"><span class="keyword">input</span>           Reset;      <span class="comment">// 异步复位</span></span><br><span class="line"><span class="keyword">input</span>           FhtStar;    <span class="comment">// 单步 FHT 运算控制信号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 单步 FT运算输入</span></span><br><span class="line"><span class="keyword">input</span>   [<span class="number">11</span>:<span class="number">0</span>]  In0,In1,In2,In3,In4,In5,In6,In7,In8,In9;</span><br><span class="line"><span class="keyword">input</span>   [<span class="number">11</span>:<span class="number">0</span>]  In10,In11,In12,In13,In14,In15;</span><br><span class="line">                            </span><br><span class="line"><span class="comment">// 单步 FT运算输出</span></span><br><span class="line"><span class="keyword">output</span>  [<span class="number">12</span>:<span class="number">0</span>]  Out0,Out1,Out2,Out3,Out4,Out5,Out6,Out7,Out8,Out9;</span><br><span class="line"><span class="keyword">output</span>  [<span class="number">12</span>:<span class="number">0</span>]  Out10,Out11,Out12,Out13,Out14,Out15;</span><br><span class="line"></span><br><span class="line"><span class="keyword">reg</span>     [<span class="number">12</span>:<span class="number">0</span>]  Out0,Out1,Out2,Out3,Out4,Out5;</span><br><span class="line"><span class="keyword">reg</span>     [<span class="number">12</span>:<span class="number">0</span>]  Out6,Out7,Out8,Out9,Out10,Out11;</span><br><span class="line"><span class="keyword">reg</span>     [<span class="number">12</span>:<span class="number">0</span>]  Out12,Out13,Out14,Out15;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 补码运算</span></span><br><span class="line"><span class="keyword">wire</span>    [<span class="number">11</span>:<span class="number">0</span>]  In8Co  =~ In8+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">wire</span>    [<span class="number">11</span>:<span class="number">0</span>]  In9Co  =~ In9+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">wire</span>    [<span class="number">11</span>:<span class="number">0</span>]  In10Co =~ In10+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">wire</span>    [<span class="number">11</span>:<span class="number">0</span>]  In11Co =~ In11+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">wire</span>    [<span class="number">11</span>:<span class="number">0</span>]  In12Co =~ In12+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">wire</span>    [<span class="number">11</span>:<span class="number">0</span>]  In13Co =~ In13+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">wire</span>    [<span class="number">11</span>:<span class="number">0</span>]  In14Co =~ In14+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">wire</span>    [<span class="number">11</span>:<span class="number">0</span>]  In15Co =~ In15+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> Clk <span class="keyword">or</span> <span class="keyword">negedge</span> Reset) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span>(!Reset) <span class="keyword">begin</span></span><br><span class="line">        Out0&lt;=<span class="number">0</span> ; Out1&lt;=<span class="number">0</span> ; Out2&lt;= <span class="number">0</span>; Out3&lt;= <span class="number">0</span>;</span><br><span class="line">        Out4&lt;=<span class="number">0</span> ; Out5&lt;=<span class="number">0</span> ; Out6&lt;= <span class="number">0</span>; Out7&lt;= <span class="number">0</span>;</span><br><span class="line">        Out8&lt;=<span class="number">0</span> ; Out9&lt;=<span class="number">0</span> ; Out10&lt;=<span class="number">0</span>; Out11&lt;=<span class="number">0</span>;</span><br><span class="line">        Out12&lt;=<span class="number">0</span>; Out13&lt;=<span class="number">0</span>; Out14&lt;=<span class="number">0</span>; Out15&lt;=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span>(FhtStar) <span class="keyword">begin</span></span><br><span class="line">            Out0  &lt;= &#123;In0[<span class="number">11</span>],In0 &#125; + &#123;In8[<span class="number">11</span>],In8 &#125;;</span><br><span class="line">            Out1  &lt;= &#123;In0[<span class="number">11</span>],In0 &#125; + &#123;In8Co[<span class="number">11</span>],In8Co &#125;;</span><br><span class="line">            Out2  &lt;= &#123;In1[<span class="number">11</span>],In1 &#125; + &#123;In9[<span class="number">11</span>],In9 &#125;;</span><br><span class="line">            Out3  &lt;= &#123;In1[<span class="number">11</span>],In1 &#125; + &#123;In9Co[<span class="number">11</span>],In9Co &#125;;</span><br><span class="line">            Out4  &lt;= &#123;In2[<span class="number">11</span>],In2 &#125; + &#123;In10[<span class="number">11</span>],In10 &#125;;</span><br><span class="line">            Out5  &lt;= &#123;In2[<span class="number">11</span>],In2 &#125; + &#123;In10Co[<span class="number">11</span>],In10Co &#125;;</span><br><span class="line">            Out6  &lt;= &#123;In3[<span class="number">11</span>],In3 &#125; + &#123;In11[<span class="number">11</span>],In11 &#125;;</span><br><span class="line">            Out7  &lt;= &#123;In3[<span class="number">11</span>],In3 &#125; + &#123;In11Co[<span class="number">11</span>],In11Co &#125;;</span><br><span class="line">            Out8  &lt;= &#123;In4[<span class="number">11</span>],In4 &#125; + &#123;In12[<span class="number">11</span>],In12 &#125;;</span><br><span class="line">            Out9  &lt;= &#123;In4[<span class="number">11</span>],In4 &#125; + &#123;In12Co[<span class="number">11</span>],In12Co &#125;;</span><br><span class="line">            Out10 &lt;= &#123;In5[<span class="number">11</span>],In5 &#125; + &#123;In13[<span class="number">11</span>],In13 &#125;;</span><br><span class="line">            Out11 &lt;= &#123;In5[<span class="number">11</span>],In5 &#125; + &#123;In13Co[<span class="number">11</span>],In13Co &#125;;</span><br><span class="line">            Out12 &lt;= &#123;In6[<span class="number">11</span>],In6 &#125; + &#123;In14[<span class="number">11</span>],In14 &#125;;</span><br><span class="line">            Out13 &lt;= &#123;In6[<span class="number">11</span>],In6 &#125; + &#123;In14Co[<span class="number">11</span>],In14Co &#125;;</span><br><span class="line">            Out14 &lt;= &#123;In7[<span class="number">11</span>],In7 &#125; + &#123;In15[<span class="number">11</span>],In15 &#125;;</span><br><span class="line">            Out15 &lt;= &#123;In7[<span class="number">11</span>],In7 &#125; + &#123;In15Co[<span class="number">11</span>],In15Co &#125;;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>评估一下系统的流水线时间余量后，发现整个流水线有 16 个时钟周期，而 FHT 模块的频率很高，加法本身仅消耗 1 个时钟周期，加上数据的选择和分配所消耗时间，也完全能满足系统频率要求，所以<strong>将单步 FHT 运算复用 4 次</strong>，就能大幅度节约所消耗的资源。这种复用单步算法的FHT 实现框图如<a href="#图5-2">图 5-2</a> 所示，由输入选择寄存、单步FHT 模块、输出选择寄存和计数器构成。</p>
<a name="图5-2"></a>
<div data-align="center">
<p><img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-12-05-josh-verilog-part-5/2020-12-05-josh-verilog-part-5-020-FHTOperationReuseStructureDiagram.png!sign" width="500px" alt="FHT 运算复用结构图"/></p>
</div>
<p>代码如下：</p>
<figure class="highlight verilog"><figcaption><span>wch_fht.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment">优化后的 FHT 运算</span></span><br><span class="line"><span class="comment">******************************/</span></span><br><span class="line"><span class="keyword">module</span> wch_fht(</span><br><span class="line">    Clk,Reset,</span><br><span class="line">    PreFhtStar,</span><br><span class="line">    In0,In1,In2,In3,In4,In5,In6,In7,</span><br><span class="line">    In8,In9,In10,In11,In12,In13,In14,In15,</span><br><span class="line">    Out0,Out1,Out2,Out3,Out4,Out5,Out6,Out7,Out8,</span><br><span class="line">    Out9,Out10,Out11,Out12,Out13,Out14,Out15</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span>           Clk;        <span class="comment">// 设计的主时钟</span></span><br><span class="line"><span class="keyword">input</span>           Reset;      <span class="comment">// 异步复位信号</span></span><br><span class="line"><span class="keyword">input</span>           PreFhtStar; <span class="comment">// FHT 运算指示信号, 和上级模块运算关联</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// FHT 的 16 个输入</span></span><br><span class="line"><span class="keyword">input</span>   [<span class="number">11</span>:<span class="number">0</span>]  In0,In1,In2,In3,In4,In5,In6,In7;</span><br><span class="line"><span class="keyword">input</span>   [<span class="number">11</span>:<span class="number">0</span>]  In8,In9,In10,In11,In12,In13,In14,In15;</span><br><span class="line"></span><br><span class="line"><span class="comment">// FHT 的 16 个输出</span></span><br><span class="line"><span class="keyword">output</span>  [<span class="number">15</span>:<span class="number">0</span>]  Out0,Out1,Out2,Out3,Out4,Out5,Out6,Out7;</span><br><span class="line"><span class="keyword">output</span>  [<span class="number">15</span>:<span class="number">0</span>]  Out8,Out9,Out10,Out11,Out12,Out13,Out14,Out15;</span><br><span class="line"></span><br><span class="line"><span class="comment">// FHT 输出寄存信号</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">15</span>:<span class="number">0</span>] Out0,Out1,Out2,Out3,Out4,Out5,Out6,Out7;</span><br><span class="line"><span class="keyword">reg</span> [<span class="number">15</span>:<span class="number">0</span>] Out8,Out9,Out10,Out11,Out12,Out13,Out14,Out15;</span><br><span class="line"></span><br><span class="line"><span class="comment">// FHT 的中间结果</span></span><br><span class="line"><span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>] Temp0,Temp1,Temp2,Temp3,Temp4,Temp5,Temp6,Temp7;</span><br><span class="line"><span class="keyword">wire</span> [<span class="number">15</span>:<span class="number">0</span>] Temp8,Temp9,Temp10,Temp11,Temp12,Temp13,Temp14,Temp15;</span><br><span class="line"></span><br><span class="line"><span class="comment">// FHT 运算控制计数器，和前一级流水线模块配合</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">2</span>:<span class="number">0</span>] Cnt3;             <span class="comment">//count from 0 to 4,when Reset Cnt3=7;</span></span><br><span class="line"><span class="keyword">reg</span> FhtEn;                  <span class="comment">//Enable fht culculate</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> Clk <span class="keyword">or</span> <span class="keyword">negedge</span> Reset) <span class="keyword">begin</span> </span><br><span class="line">    <span class="keyword">if</span> (!Reset)</span><br><span class="line">        Cnt3&lt;= #<span class="number">1</span> <span class="number">3&#x27;b111</span>;  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (PreFhtStar)</span><br><span class="line">            Cnt3&lt;= #<span class="number">1</span> <span class="number">3&#x27;b100</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            Cnt3&lt;= #<span class="number">1</span> Cnt3-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> Clk <span class="keyword">or</span> <span class="keyword">negedge</span> Reset)</span><br><span class="line"><span class="keyword">if</span> (!Reset)</span><br><span class="line">   FhtEn&lt;= #<span class="number">1</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (PreFhtStar)</span><br><span class="line">        FhtEn&lt;= #<span class="number">1</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>  (Cnt3==<span class="number">1</span>)</span><br><span class="line">        FhtEn&lt;= #<span class="number">1</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 补码运算, 复制符号位   </span></span><br><span class="line"><span class="keyword">assign</span> Temp0  = (Cnt3 == <span class="number">4</span>) ? &#123;In0[<span class="number">11</span>],In0[<span class="number">11</span>],In0[<span class="number">11</span>],In0[<span class="number">11</span>],In0&#125;     :Out0;</span><br><span class="line"><span class="keyword">assign</span> Temp1  = (Cnt3 == <span class="number">4</span>) ? &#123;In1[<span class="number">11</span>],In1[<span class="number">11</span>],In1[<span class="number">11</span>],In1[<span class="number">11</span>],In1&#125;     :Out1;</span><br><span class="line"><span class="keyword">assign</span> Temp2  = (Cnt3 == <span class="number">4</span>) ? &#123;In2[<span class="number">11</span>],In2[<span class="number">11</span>],In2[<span class="number">11</span>],In2[<span class="number">11</span>],In2&#125;     :Out2;</span><br><span class="line"><span class="keyword">assign</span> Temp3  = (Cnt3 == <span class="number">4</span>) ? &#123;In3[<span class="number">11</span>],In3[<span class="number">11</span>],In3[<span class="number">11</span>],In3[<span class="number">11</span>],In3&#125;     :Out3;</span><br><span class="line"><span class="keyword">assign</span> Temp4  = (Cnt3 == <span class="number">4</span>) ? &#123;In4[<span class="number">11</span>],In4[<span class="number">11</span>],In4[<span class="number">11</span>],In4[<span class="number">11</span>],In4&#125;     :Out4;</span><br><span class="line"><span class="keyword">assign</span> Temp5  = (Cnt3 == <span class="number">4</span>) ? &#123;In5[<span class="number">11</span>],In5[<span class="number">11</span>],In5[<span class="number">11</span>],In5[<span class="number">11</span>],In5&#125;     :Out5;</span><br><span class="line"><span class="keyword">assign</span> Temp6  = (Cnt3 == <span class="number">4</span>) ? &#123;In6[<span class="number">11</span>],In6[<span class="number">11</span>],In6[<span class="number">11</span>],In6[<span class="number">11</span>],In6&#125;     :Out6;</span><br><span class="line"><span class="keyword">assign</span> Temp7  = (Cnt3 == <span class="number">4</span>) ? &#123;In7[<span class="number">11</span>],In7[<span class="number">11</span>],In7[<span class="number">11</span>],In7[<span class="number">11</span>],In7&#125;     :Out7;</span><br><span class="line"><span class="keyword">assign</span> Temp8  = (Cnt3 == <span class="number">4</span>) ? &#123;In8[<span class="number">11</span>],In8[<span class="number">11</span>],In8[<span class="number">11</span>],In8[<span class="number">11</span>],In8&#125;     :Out8;</span><br><span class="line"><span class="keyword">assign</span> Temp9  = (Cnt3 == <span class="number">4</span>) ? &#123;In9[<span class="number">11</span>],In9[<span class="number">11</span>],In9[<span class="number">11</span>],In9[<span class="number">11</span>],In9&#125;     :Out9;</span><br><span class="line"><span class="keyword">assign</span> Temp10 = (Cnt3 == <span class="number">4</span>) ? &#123;In10[<span class="number">11</span>],In10[<span class="number">11</span>],In10[<span class="number">11</span>],In10[<span class="number">11</span>],In10&#125;:Out10;</span><br><span class="line"><span class="keyword">assign</span> Temp11 = (Cnt3 == <span class="number">4</span>) ? &#123;In11[<span class="number">11</span>],In11[<span class="number">11</span>],In11[<span class="number">11</span>],In11[<span class="number">11</span>],In11&#125;:Out11;</span><br><span class="line"><span class="keyword">assign</span> Temp12 = (Cnt3 == <span class="number">4</span>) ? &#123;In12[<span class="number">11</span>],In12[<span class="number">11</span>],In12[<span class="number">11</span>],In12[<span class="number">11</span>],In12&#125;:Out12;</span><br><span class="line"><span class="keyword">assign</span> Temp13 = (Cnt3 == <span class="number">4</span>) ? &#123;In13[<span class="number">11</span>],In13[<span class="number">11</span>],In13[<span class="number">11</span>],In13[<span class="number">11</span>],In13&#125;:Out13;</span><br><span class="line"><span class="keyword">assign</span> Temp14 = (Cnt3 == <span class="number">4</span>) ? &#123;In14[<span class="number">11</span>],In14[<span class="number">11</span>],In14[<span class="number">11</span>],In14[<span class="number">11</span>],In14&#125;:Out14;</span><br><span class="line"><span class="keyword">assign</span> Temp15 = (Cnt3 == <span class="number">4</span>) ? &#123;In15[<span class="number">11</span>],In15[<span class="number">11</span>],In15[<span class="number">11</span>],In15[<span class="number">11</span>],In15&#125;:Out15;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> Clk <span class="keyword">or</span> <span class="keyword">negedge</span> Reset) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (!Reset) <span class="keyword">begin</span></span><br><span class="line">        Out0&lt;=<span class="number">0</span>;Out1&lt;=<span class="number">0</span>;Out2&lt;=<span class="number">0</span>;Out3&lt;=<span class="number">0</span>;Out4&lt;=<span class="number">0</span>;Out5&lt;=<span class="number">0</span>;Out6&lt;=<span class="number">0</span>;Out7&lt;=<span class="number">0</span>;</span><br><span class="line">        Out8&lt;=<span class="number">0</span>;Out9&lt;=<span class="number">0</span>;Out10&lt;=<span class="number">0</span>;Out11&lt;=<span class="number">0</span>;Out12&lt;=<span class="number">0</span>;Out13&lt;=<span class="number">0</span>;Out14&lt;=<span class="number">0</span>;Out15&lt;=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> ((Cnt3&lt;=<span class="number">4</span>) &amp;&amp; Cnt3&gt;=<span class="number">0</span> &amp;&amp; FhtEn) <span class="keyword">begin</span></span><br><span class="line">            Out0[<span class="number">15</span>:<span class="number">0</span>]  &lt;= #<span class="number">1</span> Temp0[<span class="number">15</span>:<span class="number">0</span>] + Temp8[<span class="number">15</span>:<span class="number">0</span>];</span><br><span class="line">            Out1[<span class="number">15</span>:<span class="number">0</span>]  &lt;= #<span class="number">1</span> Temp0[<span class="number">15</span>:<span class="number">0</span>] - Temp8[<span class="number">15</span>:<span class="number">0</span>];</span><br><span class="line">            Out2[<span class="number">15</span>:<span class="number">0</span>]  &lt;= #<span class="number">1</span> Temp1[<span class="number">15</span>:<span class="number">0</span>] + Temp9[<span class="number">15</span>:<span class="number">0</span>];</span><br><span class="line">            Out3[<span class="number">15</span>:<span class="number">0</span>]  &lt;= #<span class="number">1</span> Temp1[<span class="number">15</span>:<span class="number">0</span>] - Temp9[<span class="number">15</span>:<span class="number">0</span>];</span><br><span class="line">            Out4[<span class="number">15</span>:<span class="number">0</span>]  &lt;= #<span class="number">1</span> Temp2[<span class="number">15</span>:<span class="number">0</span>] + Temp10[<span class="number">15</span>:<span class="number">0</span>];</span><br><span class="line">            Out5[<span class="number">15</span>:<span class="number">0</span>]  &lt;= #<span class="number">1</span> Temp2[<span class="number">15</span>:<span class="number">0</span>] - Temp10[<span class="number">15</span>:<span class="number">0</span>];</span><br><span class="line">            Out6[<span class="number">15</span>:<span class="number">0</span>]  &lt;= #<span class="number">1</span> Temp3[<span class="number">15</span>:<span class="number">0</span>] + Temp11[<span class="number">15</span>:<span class="number">0</span>];</span><br><span class="line">            Out7[<span class="number">15</span>:<span class="number">0</span>]  &lt;= #<span class="number">1</span> Temp3[<span class="number">15</span>:<span class="number">0</span>] - Temp11[<span class="number">15</span>:<span class="number">0</span>];</span><br><span class="line">            Out8[<span class="number">15</span>:<span class="number">0</span>]  &lt;= #<span class="number">1</span> Temp4[<span class="number">15</span>:<span class="number">0</span>] + Temp12[<span class="number">15</span>:<span class="number">0</span>];</span><br><span class="line">            Out9[<span class="number">15</span>:<span class="number">0</span>]  &lt;= #<span class="number">1</span> Temp4[<span class="number">15</span>:<span class="number">0</span>] - Temp12[<span class="number">15</span>:<span class="number">0</span>];</span><br><span class="line">            Out10[<span class="number">15</span>:<span class="number">0</span>] &lt;= #<span class="number">1</span> Temp5[<span class="number">15</span>:<span class="number">0</span>] + Temp13[<span class="number">15</span>:<span class="number">0</span>];</span><br><span class="line">            Out11[<span class="number">15</span>:<span class="number">0</span>] &lt;= #<span class="number">1</span> Temp5[<span class="number">15</span>:<span class="number">0</span>] - Temp13[<span class="number">15</span>:<span class="number">0</span>];</span><br><span class="line">            Out12[<span class="number">15</span>:<span class="number">0</span>] &lt;= #<span class="number">1</span> Temp6[<span class="number">15</span>:<span class="number">0</span>] + Temp14[<span class="number">15</span>:<span class="number">0</span>];</span><br><span class="line">            Out13[<span class="number">15</span>:<span class="number">0</span>] &lt;= #<span class="number">1</span> Temp6[<span class="number">15</span>:<span class="number">0</span>] - Temp14[<span class="number">15</span>:<span class="number">0</span>];</span><br><span class="line">            Out14[<span class="number">15</span>:<span class="number">0</span>] &lt;= #<span class="number">1</span> Temp7[<span class="number">15</span>:<span class="number">0</span>] + Temp15[<span class="number">15</span>:<span class="number">0</span>];</span><br><span class="line">            Out15[<span class="number">15</span>:<span class="number">0</span>] &lt;= #<span class="number">1</span> Temp7[<span class="number">15</span>:<span class="number">0</span>] - Temp15[<span class="number">15</span>:<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span>    </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>为了便于对比两种实现方式的资源消耗，在 Synplify Pro 中对两种实现方法分别做了综合。两次综合选用的参数都完全一致，所以仅考察设计所消耗的寄存器和逻辑资源，选 中Disable I/O In sertion 选项，不插入 I/O，取消 Synplify Pro 中诸如 FSM Compiler、FSM Explorer、Resource Sharing、Retiming、Pipelining等综合优化选项。两次综合的结果如<a href="#图5-3">图 5-3</a> 和<a href="#图5-4">图 5-4</a> 所示。</p>
<a name="图5-3"></a>
<div data-align="center">
<p><img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-12-05-josh-verilog-part-5/2020-12-05-josh-verilog-part-5-030-FHTPARTResource.bmp!sign" alt="未采用复用方案的“fhtpart”模块综合所消耗的资源"/></p>
</div>
<a name="图5-4"></a>
<div data-align="center">
<p><img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-12-05-josh-verilog-part-5/2020-12-05-josh-verilog-part-5-040-WCHFHTResource.bmp!sign" alt="采用复用方案的“wch_fht”模块综合所消耗的资源"/></p>
</div>
<p>通过对比可以清晰地观察到，采用复用实现方案所占面积约为原方案的 1/4，而得到这个好处的代价是，完成整个 FHT 运算的周期为原来的 4 倍。这个例子通过运算周期的加长，换取了消耗芯片面积的减少，是前面所述的用频率换面积的一种体现。本例所述“频率换面积”的前提是，FHT 模块频率较高，运算周期的余量较大，采用4 步复用后．仍然能够满足系统流水线设计的要求。其实，如果流水线时序允许，FHT 运算甚至可以采用 1 bit 串行方案实现，该方案所消耗的芯片面积资源更少！</p>
<h3 id="用面积复制换取速度的提高举例">1.1.2 “用面积复制换取速度的提高”举例</h3>
<p>举一个通过复制模块，并行处理达到高处理带宽的例子（可实际应用于无线系统、有线接入、路由器、视频系统等）。假设输入数据流的速率是 800 Mbit/s，而 FPGA 上设计的数据处理模块的处理速度最大为 200 Mbit/s，由于处理模块的数据吞吐量满足不了要求，直接在 FPGA 上实现这个设计是一个“impossible mission”！</p>
<p>这种情况下。就应该利用“面积换速度”的思想，至少复制 4 个处理模块，<strong>首先将输入数据进行串/并转换</strong>，然后利用这 4 个模块并行处理分配的数据，<strong>最后将处理结果并/串变换</strong>，完成数据速率的要求。在整个处理模块的两端看，数据速率仍然是 800 Mbit/s，而在 FPGA 的内部看，每个子模块处理的数据速率仅为 200 Mbit/s，其实整个数据的吞吐扯的保障是依赖于 4 个子模块并行处理完成的，也就是说利用了占用更多的芯片面积，实现了高速处理，通过使用“面积的复制换取处理速度的提高”的思想实现了设计。设计的示意框图如<a href="#图5-5">图 5-5</a> 所示。</p>
<a name="图5-5"></a>
<div data-align="center">
<p><img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-12-05-josh-verilog-part-5/2020-12-05-josh-verilog-part-5-050-MoreAreaforSpeed.png!sign" width="700px" alt="“面积换速度”示意图"/></p>
</div>
<p>“面积复制换取速度提高”或者说“面积复制换取数据吞吐量的提高”是目前 FPGA 设计的常用技巧之一。现代高速FPGA 基本都有 DDR/DDR2/DDR3 的 I/O 硬件电路，通过这种 I/O 硬件电路，可以实现输入数据流的 1:2 和 1:4 的串/并变换和并/串变换，很多中高端 FPGA 在 I/O BANK 附近还专门设计了硬件的 DLL 或PLL，配合 DDR/DDR2/DDR3 的 I/O 硬件电路完成对应的采样时钟的降速和倍速。调用这些 I/O 的硬件模块，可以方便、可靠地实现数据流的并行化（输入端）和串行化（输出端），从而更利于实现“面积复制换取速度提高”，或“面积复制换取数据吞吐量的提高”的设计思想。</p>
<p>上面仅仅是对“面积换速度“思想的一个简单的举例，其实具体操作过程中还涉及很多的方法和技巧，例如，对高速数据流进行串/并转换，采用“乒乓操作”方法提高数据处理速率等。希望读者通过平时的应用进一步积累经验。</p>
<h2 id="硬件原则">1.2 硬件原则</h2>
<p>硬件原则主要针对 HDL 代码编写而言。首先应该明确 FPGA/CPLD、ASIC 的逻辑设计所采用的硬件描述语言（HDL） 同软件语言（如 C、C++ 等）是有本质区别的！以 Verilog 语言为例，虽然 Verilog 很多语法规则和 C 语言相似，但是 Verilog 作为硬件描述语言，它的本质作用在于描述硬件，应该认识到 Verilog 是采用了 C 语言形式的硬件的抽象，它的<strong>最终实现结果是芯片内部的实际电路</strong>。</p>
<p>所以评判一段 HDL 代码优劣的最终标准是其描述并实现的硬件电路的性能（包括面积和速度两个方面）。评价一个设计的代码水平较高，仅仅是说<strong>这个设计由硬件向 HDL 代码这种表现形式转换得更流畅、合理</strong>。而一个设计的最终性能，在更大程度上取决于设计工程师所构想的硬件实现方案的效率以及合理性。</p>
<p>初学者，特别是由软件转行的初学者，片面追求代码的整洁、简短，这是错误的，是与评价 HDL 的标准背道而驰的！正确的编码方法是，首先要做到对所需实现的硬件电路“胸有成竹”，对该部分硬件的结构与连接十分清晰，然后再用适当的 HDL 语句表达出来即可。</p>
<p>前面已经讨论过 HDL 语言与 C 语言等软件语言相比的最显著区别在于：HDL 语言便于描述“互联”、”并发”、”时间”这 3 个硬件设计的基本概念。</p>
<ul>
<li><p><strong>互连（connectivity）</strong>: 互连是硬件电路的一个基本要素，在 C 语言中，并没有直接可以用来表示模块间互连的变扯；而 HDL 的网线型变最则专为模块互连而设计，描述电路连接清晰明确。如 Verilog 的 <code>wire</code> 型变量配合一些驱动结构就能有效地描述各个模块直接的端口与网线连接关系。</p></li>
<li><p><strong>并发（concurrency）</strong> : C 语言天生是<strong>串行</strong>的，不能描述硬件之间并发的特性， C 语言编译后．其机器指令在 CPU 的高速缓冲队列中基本是顺序执行；而 Verilog 可以有效地描述并行的硬件系统，硬件系统比软件系统速度快、实时性高的一个重要原因就是硬件系统中<strong>各个单元的运算是独立的，信号流是并行的</strong>。所以在使用 HDL 建模时，应该充分理解硬件系统的并行处理特点，合理安排数据流的时序，提高整个设计的效率。</p></li>
<li><p><strong>时间（time）</strong>：C 程序运行的时候，没有一个严格的时间概念，程序运行的时间长短，取决于处理器本身的性能；而 HDL 语言定义了绝对和相对的时间度量，在仿真时可以通过时间度扯与周期关系描述信号直接的时间关系。</p></li>
</ul>
<p>Verilog 作为一种 HDL 语言，对系统行为的建模方式是分层次的。比较重要的层次有系统级（System）、算法级（Algorithm）、寄存器传输级（RTL）、逻辑级（Logic）、门级（Gate）和电路开关级（Switch）等。系统级和算法级与 C 语言更相似，可用的语法和表现形式也更丰富。自 RTL 级以后，HDL 语言的功能就越来越侧重于硬件电路的描述，可用的语法和表现形式的局限性也越大。相比之下， C 语言与系统级和算法级 Verilog 描述更相近一些，而与 RTL 级、Gate 级、Switch 级描述从描述目标和表现形式上都有较大的差异。</p>
<p>下举例说明 RTL 级 Verilog 描述语法和 C 语言描述语法的区别。</p>
<p>在C 语言的描述中，为了使代码执行效率高，表述简洁，经常用到下面的 <code>for</code> 循环语句：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = O; i &lt; l6; i++)</span><br><span class="line">    DoSomething();</span><br></pre></td></tr></table></figure>
<p>但是在实际工作中，除了描述仿真测试激励（testbench）时使用 <code>for</code> 循环语句外，RTL 级编码中<strong>必须要慎用 <code>for</code> 循环</strong>。其原因是 <strong><code>for</code> 循环会被综合器展开为所有变量情况的执行语句，每个变量独立占用寄存器资源，有些情况下不能有效地复用硬件逻辑资源，造成资源浪费</strong>。在 RTL 硬件描述中，遇到类似算法，常用的方式是先搞清楚设计的时序要求，做一个 <code>reg</code> 型计数器，在每个时钟沿累加，并在每个时钟沿判断 计数器情况，做相应的处理，能复用的处理模块尽量复用，即使所有操作不易复用，也可以采用 <code>case</code> 语句展开描述。代码如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] counter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk)</span><br><span class="line">    <span class="keyword">if</span> (syn_rst)</span><br><span class="line">        counter &lt;= <span class="number">4&#x27;b0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        counter &lt;= counter + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">case</span> (counter)</span><br><span class="line">        <span class="number">4&#x27;b0000</span>:</span><br><span class="line">        <span class="number">4&#x27;b0001</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>另外，在 C 描述中有 <code>if ... else</code> 和 <code>switch</code> 条件判断语句，其语法如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (flag)       <span class="comment">// 表示flag为真</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (variable) &#123;</span><br><span class="line">    <span class="keyword">case</span> value1: ...; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> value2: ...; <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">default</span>: ...;     <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两者之间的区别主要在于 <code>switch</code> 是多分支选择语句，而 <code>if</code> 语句只有两个分支可供选择。虽然可以用嵌套的 <code>if</code> 语句来实现多分支选择，但那样的程序冗长难读。</p>
<p>对应 Verilog 也有 <code>if ... else</code> 语句和 <code>case</code> 语句，<code>if</code> 语句的语法相似，<code>case</code> 语句的语法如下：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> (<span class="keyword">var</span>)</span><br><span class="line">    var_value1: ...;</span><br><span class="line">    var_value2: ...;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">default</span>: ...;</span><br></pre></td></tr></table></figure>
<p>通过 <a href="https://josh-gao.top/posts/ecb88422.html#3-10-%E7%94%A8-case-%E5%92%8C-if-else-%E5%BB%BA%E6%A8%A1">《Part 4 —— RTL 概念与常用 RTL 建模》的 3.10 小节</a>的学习，我们会发现 <code>case</code> 语句和 <code>if ... else if ... else if ...</code> 语句以及 <code>if ... if ... if ...</code> 语句建模时可以建立无优先级和带有优先级的判断结构，使用 HDL 语言建模时，关键在于其综合实现结果的硬件结构。</p>
<p>这里进一步引申讨论一下 Verilog 的 <code>for</code> 循环。前面讲过 Verilog 语言是分层次的，即使同一个语法关键字在不同的应用层次也有不同的理解，for 循环就是一个非常好的例子。</p>
<ul>
<li><code>for</code> 循环在行为级描述测试激励时的应用：前面介绍过，推荐使用 Behavior 级方式描述测试激励，在描述测试激励时，推荐使用 <code>for</code> 循环。好处主要有两个，一是描述简单，代码清晰；二是仿真器会对 <code>for</code> 循环开放一片内存，提供代码执行效率，加快仿真进程。</li>
</ul>
<ul>
<li><code>for</code> 循环在 RTL 级描述硬件电路时的应用：在 RTL 级描述硬件时，一定要慎用 <code>for</code> 循环。前面已经介绍过，<code>for</code> 循环在硬件实现时会被综合器展开，不利于硬件资源复用，如果应用不当，还会造成资源浪费。但是任何问题不是绝对的，如果用户非常清晰 <code>for</code> 循环会被综合器展开这一基本原则，则可以逆向思维，对某些硬件上无法复用的展开结构抽象为 <code>for</code> 循环描述，大大提高代码的可读性。</li>
</ul>
<h2 id="系统原则">1.3 系统原则</h2>
<p>系统原则包含两个层次的含义：一是实现的目标器件本身可以看作一个系统，需要充分有效地发挥该系统的每个单元的功效。如果设计的实现目标为 FPGA，因为当代 FPGA 内嵌了很多固有的硬件资源（如：可编程输入/输出单元、基本可编程逻辑单元、嵌入式块 RAM 、丰富的布线资源、底层嵌入功能单元和内嵌专用硬核等），如何合理地使用这些硬件资源，对设计的全局有个宏观上的合理安排，比如合理安排时钟域、模块复用、约束、面积和速度等问题就显得至关重要。如果实现目标是 SoC，则需要分析什么样的算法和功能适合放在硬件系统里面实现，什么样的算法和功能适合放在微处理器系统（如 DSP、CPU 等）里面实现，并进一步合理划分软硬件之间的数据交换。</p>
<p>从更高层面上看，对于任何一个硬件系统，如何进行模块划分与任务分配，什么样的算法和功能适合放在可编程逻辑器件或 ASIC 里面实现，什么样的算法和功能适合放在 DSP、CPU 等微处理器实现，如何划分软硬件功能，安排模块接口设计等问题都非常重要。要知道<strong>在系统上复用模块节省的面积远比在代码上小打小闹来得实惠多。</strong></p>
<p><a href="#图5-6">图 5-6</a> 描述了FPGA 设计的系统规划流程。我们可以发现<strong>对设计从整体上进行模块复用应该在系统功能定义后就充分考虑</strong>，并指导模块的具体划分。模块划分非常重要，除了关系到是否最大程度上发挥项目成员的协同设计能力，而且直接决定着设计的综合、实现效果和相关的操作时间，模块划分的具体方法请参考 4.2 小节中关于模块划分技巧的论述。</p>
<a name="图5-6"></a>
<div data-align="center">
<p><img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-12-05-josh-verilog-part-5/2020-12-05-josh-verilog-part-5-060-SystemPlanningProc.png!sign" width="700px" alt="系统规划的简化流程"/></p>
</div>
<p>对系统原则做一点引申，简单谈谈模块化设计方法。模块化设计是系统原则的一个很好的体现，它不仅是一种设计工具，它更是一种设计思路、设计方法，它是由顶向下、模块划分、分工协作设计思路的集中体现，是当代大型复杂系统的推荐设计方法。目前很多的 EDA 厂商都提高了模块化设计工具，通过这类工具划分每个模块的设计区域，然后单独设计和优化每个模块，最后将每个模块融合到顶层设计中，从而实现了团队协作、并行设计的模块化设计方法。合理使用模块化设计方法，能在最大程度上继承以往设计成果，并行分工协作，有效利用开发资源，缩短开发周期。</p>
<p>下举例说明如何在系统层次复用模块</p>
<p>利用“可编程匹配滤波器“实现 WCDMA 基站的方案，其核心是在合理规划系统的基础上，合理划分模块并安排操作时序，提高单元模块的复用率令从而大大降低硬件消耗，其设计思想是系统原则的集中体现。可编程匹配滤波器原理框图如<a href="#图5-7">图 5-7</a> 所示。</p>
<a name="图5-7"></a>
<div data-align="center">
<p><img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-12-05-josh-verilog-part-5/2020-12-05-josh-verilog-part-5-070-ProgrammableMatchFilter.png!sign" width="500px" alt="系统规划的简化流程"/></p>
</div>
<p>其设计思想是：利用信道固有特点（如信道 pilot 导频、信道结构等），应用现代可编程数字信号处理的技术（如 DSP、FPGA 等），采取反馈与控制匹配滤波方式，实现对某信道的已扩信息的自动解扩解扰。该可编程 MF 的主要组成部分为本地码发生器、可编程信号 MF（S MF）、帧匹配滤波器（FRAME MF）和控制器。本地码发生器可生成各种所需的扩频、加扰序列，可接收控制器的指示脉冲，产生规定的本地解扩、解扰序列，作为 S MF 的参考序列；S MF 是完成匹配滤波的主体，可接收控制器的指示脉冲，将自己的匹配状态切换到下一匹配状态；F MF 完成对导频信号等特殊信号（信息位待选集有限）的检测，生成指示相关峰，通知控制器将 S MF 切换到下一匹配状态；控制器统一协调各部分工作。这种可编程滤波器可以在如越区切换、同步方面、CPCH 收发信机等多方面应用，如果适当安排时序流程，可以在较大程度上节约硬件资源。</p>
<h1 id="同步设计原则和多时钟处理">2. 同步设计原则和多时钟处理</h1>
<h2 id="同步设计原则">2.1 同步设计原则<a name="0201"></a></h2>
<p>同步设计是 PLD 和 ASIC 设计的最重要原则。本小节首先阐释为什么在 PLD 设计中要采用同步时序设计，然后重点论述同步时序设计的要点。</p>
<h3 id="异步时序设计与同步时序设计">2.1.1 异步时序设计与同步时序设计</h3>
<p>简单比较一下异步电路和同步电路的异同。</p>
| 电路类型 |
<center>
特点
</center>
<table>
<colgroup>
<col style="width: 57%" />
<col style="width: 42%" />
</colgroup>
<tbody>
<tr class="odd">
<td style="text-align: center;">异步电路</td>
<td style="text-align: left;">· 电路的核心逻辑用组合电路实现，比如异步的 FIFO/RAM 读/写信号、地址译码等电路。<br>· 电路的主要信号、输出信号等并不依赖于任何一个时钟性信号，不是由时钟信号驱动触发器（FF）产生的。<br>· 异步时序电路的最大缺点是容易产生毛刺。在布局布线后仿真和用高分辨率逻辑分析仪观测实际信号时，这种毛刺尤其明显。<br>· 不利于器件移植，这包括 FPGA 器件族之间的移植和从 FPGA 向结构化 ASIC 的移植。<br>· 不利于静态时序分析（STA）、验证设计时序性能。</td>
</tr>
<tr class="even">
<td style="text-align: center;">同步电路</td>
<td style="text-align: left;">· 电路的核心逻辑用各种各样的触发器实现。<br>· 电路的主要信号、输出信号等都是由某个时钟沿驱动触发器产生的。<br>· 同步时序电路可以很好地避免毛刺。布局布线后仿真和用高速逻辑分析仪采样实际工作信号皆无毛刺。<br>· 利于器件移植，这包括 FPGA 器件族之间的移植和从 FPGA 向结构化 ASIC 的移植。<br>· 有利于静态时序分析（STA）、验证设计时序性能。</td>
</tr>
</tbody>
</table>
<p>早期 PLD 设计经常使用行波计数器（Ripple Counters）或者异步脉冲生成器等典型的异步逻辑设计方式以节约设计所消耗的面积资源。但是<strong>异步逻辑设计的时序正确性完全依赖于每个逻辑元件和布线的延迟</strong>，所以其时序约束相对繁杂而困难，并且<strong>极易产生亚稳态、毛刺等，造成设计的稳定性下降和设计频率不高</strong>。随着数字逻辑的不断经济化，器件资源已经不再成为设计的主要矛盾，而同步时序电路对全面提高设计的频率和稳定性至关重要，从这个层面上讲，尽量使用同步时序电路更加重要。</p>
<p>另一方面，随着 PLD 和 ASIC 的逻辑规模不断扩大，在芯片中完成复杂且质量优良的异步时序设计<strong>过于费时费力</strong>，其所需调整的时序路径和需要附加的相关约束相当繁琐，<strong>异步时序方法是和可编程设计理念背道而驰的</strong>。</p>
<p>随着EDA 工具的发展，大规模设计的综合、实现的优化效果越来越强。但是目前大多数综合、实现等EDA 工具都是基于时序驱动（Timing Driven）优化策略的。异步时序电路增加了时序分析的难度，需要确定最佳时序路径所需的计算量超出想象，所需时序约束相当繁琐，而且<strong>对于异步电路很多综合、实现工具的编译会带来歧义</strong>。而对于同步时序设计则恰恰相反，其<strong>时序路径清晰，相关时序约束简单明了，综合、实现优化容易，布局布线计算量小</strong>。所以目前可编程逻辑的 EDA 工具都推荐使用同步时序设计。</p>
<p>综上所述，<strong>现代数字芯片设计推荐采用同步时序设计方式！</strong></p>
<h3 id="同步时序设计">2.1.2 同步时序设计</h3>
<p>同步时序设计的基本原则是<strong>使用时钟沿触发所有的操作</strong>。如果所有寄存器的时序要求（Setup、Hold 时间等指标）都能够满足，则同步时序设计与异步时序设计相比，在不同的 PVT（工艺、电压、温度）条件下能获得更佳的系统稳定性与可靠性。</p>
<p>同步设计中，稳定可靠的数据采样必须遵从以下两个基本原则：</p>
<ul>
<li><p>在有效时钟沿到达前，数据输入至少已经稳定了采样寄存器的 Setup 时间之久，这条原则简称<strong>满足 Setup 时间原则</strong>；</p></li>
<li><p>在有效时钟沿到达后，数据输入至少还将稳定保持采样寄存器的 Hold 时间之久，这条原则简称<strong>满足 Hold 时间原则</strong>。</p></li>
</ul>
<p>同步时序设计有以下几个注意事项：</p>
<ul>
<li><p>异步时钟域的数据转换。详见 <a href="#0203">2.3 小节“异步时钟域数据同步”</a>。</p></li>
<li><p>组合逻辑电路的设计方法。详见<a href="#05">第 5 节“组合逻辑的注意事项”</a>。</p></li>
<li><p>同步时序电路的时钟设计。 详见<a href="#06">第 6 节“时钟设计的注意事项”</a>。</p></li>
<li><p>同步时序电路的延迟。同步时序设计中电路延迟最常用的设计方法是用分频或倍频的时钟或者同步计数器完成所需延迟。换句话说，同步时序电路的延时被当作一个电路逻辑来设计。对于<strong>比较大的和特殊定时要求的延时，一般用高速时钟产生一个计数器，根据计数器的计数，控制延时</strong>；对于<strong>比较小的延时，可以用 D 触发器打一下</strong>，这种做法<strong>不仅使信号延时了一个时钟周期，而且完成了信号与时钟的初次同步</strong>，在输入信号采样或增加时序约束余量时使用。另外许多初学者用行为级（Behavioral Level）方法描述延时，如 <code>#5 a&lt;= 4'b0101;</code> 这种行为级描述方法常用于仿真测试激励，但是<strong>在电路综合时会被忽略、并不能起到延时作用</strong>。</p></li>
</ul>
<h2 id="亚稳态">2.2 亚稳态</h2>
<p>在后续笔记中会介绍异步时钟域转换的问题，在谈这个话题之前，先分析一下什么是亚稳态，以及如何避免。</p>
<p>异步时钟域的转换的核心就是要保证下级时钟对上级数据采样的 Setup 时间和 Hold 时间。如果触发器的Setup 时间或者 Hold 时间不满足，就可能产生亚稳态，<strong>此时触发器输出端 Q 在有效时钟沿之后比较长的一段时间内处于不确定的状态，在这段时间内 Q 端产生毛刺并不断振荡，最终固定在某一电压值，此电压值并不一定等于原来数据输入端 D 的数值</strong>，这段时间称为决断时间（Resolution time）。经过 Resolution time 之后 Q 端将稳定到 0 或1, 但是究竟是 0 还是1，这是随机的，与输入没有必然的关系，其产生示意图如<a href="#图5-8">图 5-8</a> 所示。</p>
<a name="图5-8"></a>
<div data-align="center">
<p><img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-12-05-josh-verilog-part-5/2020-12-05-josh-verilog-part-5-080-MetastableGenerate.png!sign" width="700px" alt="亚稳态产生示意图"/></p>
</div>
<p><strong>亚稳态的危害主要体现在破坏系统的稳定性</strong>。由于输出在稳定下来之前可能是毛刺、振荡、固定的某一电压值，因此亚稳态将<strong>导致逻辑误判</strong>，严重情况下输出 0~1 之间的中间电压值还会<strong>使下一级产生亚稳态，即导致亚稳态的传播</strong>。逻辑误判导致功能性错误，而亚稳态的传播则扩大了故障面。另外，在亚稳态状态下，任何诸如环境噪声、电源于扰等细微扰动都将导致更恶劣的状态不稳定。这时这个系统的传输延迟增大，状态输出错误，在某些情况下甚至会使寄存器在两个有效判定门限（V<sub>oL</sub> 、V<sub>oH</sub>）之间长时间的振荡。</p>
<p><strong>只要系统中有异步元件，亚稳态就无法避免</strong>，因此设计的电路<strong>首先要减少亚稳态导致的错误</strong>，<strong>其次要使系统对产生的错误不敏感</strong>。前者要靠同步设计来实现，而后者则根据不同的设计应用不同的处理办法。</p>
<p><strong>使用两级以上寄存器采样可以有效地减少亚稳态继续传播的概率</strong>。在<a href="#图5-9">图 5-9</a> 中，左边为异步输入端，经过两级触发器采样，在右边的输出与 <code>bclk</code> 同步，而且该输出基本不存在亚稳态。其原理是使第一个触发器的输出端存在亚稳态，经过一个 clk 周期后，第二个触发器 D 端的电平仍未稳定的概率非常小，因此第二个触发器 Q 端基本不会产生亚稳态。理论上如果再添加一级寄存器，使同步采样达到 3 级，则末级输出为亚稳态的概率几乎为 0。</p>
<a name="图5-9"></a>
<div data-align="center">
<p><img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-12-05-josh-verilog-part-5/2020-12-05-josh-verilog-part-5-090-TwoStageRegisterSampling.png!sign" width="700px" alt="两级寄存器采样降低亚稳态概率"/></p>
</div>
<p>使用<a href="#图5-9">图 5-9</a> 两级寄存器采样仅能降低亚稳态的概率，但是并不能保证第二级输出的稳态电平就是正确电平。前面说过经过 Resolution time 之后寄存器输出的电平是一个不确定的稳态值，也就是说<strong>这种处理方法并不能排除采样错误的产生</strong>，这时就<strong>要求所设计的系统对采样错误有一定的容忍度</strong>。有些应用本身就对采样错误不敏感，如一帧图像编码，一段话音编码等。而有些系统对错误采样比较敏感。这类由于亚稳态造成的采样是一些突发的错误，所以可以采用一些纠错编码手段完成错误的纠正。</p>
<h2 id="异步时钟域数据同步">2.3 异步时钟域数据同步<a name="0203"></a></h2>
<p>异步时钟域数据同步是芯片设计的一个常见问题，既是一个重点也是一个难点问题。很多设计工作时的不稳定都是源于异步时钟域数据同步不稳定。</p>
<h3 id="两类异步时钟域同步的表现形式">2.3.1 两类异步时钟域同步的表现形式</h3>
<p>异步时钟域数据同步，也被称为数据接口同步，顾名思义，是指<strong>如何在两个时钟不同步的数据域之间可靠地进行数据交换</strong>。数据的时钟域不同步主要有两种情况：</p>
<ul>
<li>两个域的时钟频率相同，但是相位差不固定，或者相差固定但是不可测，简称为同频异相问题；</li>
<li>两个时钟域频率根本不同，简称为异频问题。</li>
</ul>
<h3 id="两种不推荐的异步时钟域操作方法">2.3.2 两种不推荐的异步时钟域操作方法</h3>
<p>首先讨论两种在设计中不推荐的异步时钟域转换方法：一种是通过增加 Buffer 或者其他门延时调整采样；另一种是盲目使用时钟正负沿调整数据采样。</p>
<ol type="1">
<li><p>通过 Buffer 等组合逻辑延迟线调整采样时间</p>
<p>在早期逻辑电路图设计阶段，有一些设计者养成了手工加入 Buffer 或者非门调整数据延迟的习惯，从而保证本级模块的时钟对上级模块数据的建立、保持时间的要求。这些做法目前主要应用的场合有两种：一是使用分立逻辑元件（如 74 系列）搭建数字逻辑电路；另一种是在 ASIC 设计领域。<strong>目前使用分立逻辑元件搭建数字逻辑电路的场合一般为系统复杂度相对较低，系统灵活性要求不高的场合。</strong>在上述场合使用分立逻辑器件设计数字逻辑电路，由于可以使用的调整延时的手段相对有限，而且采用插入 Buffer 、数字延迟逻辑甚至两个非门等手段调整采样的 Setup 和 Hold 时间是可以接受的。而 ASIC 设计领域采用这种方法是以严格的仿真和约束条件作为强力支持的。</p>
<p>正如 <a href="#0201">2.1 同步设计原则</a>所述，<strong>使用组合逻辑方法产生延迟，容易产生毛刺</strong>，而且这种设计方法的<strong>时序余量较差</strong>，一旦外界条件变换（环境试验，特别是高低温试验），采样时序就有可能完全紊乱，造成电路瘫痪。另外，一旦芯片更新换代，或者移植到其他器件族的芯片上，采样时延必须重新调整，电路的可维护性和继承性都很差。</p></li>
<li><p>盲目使用时钟正负沿调整数据采样</p>
<p>很多初学者习惯随意使用时钟的正负沿调整采样，甚至产生一系列不同相位或不同占空比的时钟，使用其正负沿调整数据。这种做法是不推荐的，原因如下：</p>
<ol type="1">
<li><p>如果在一个时钟周期内，使用时钟的双沿同时操作，则使用该时钟的同相倍频时钟也能实现相同的功能。换句话说，一个时钟周期内，使用时钟的双沿同时操作，相当于使用了一个同相的倍频时钟。此时因为设计的时钟频率提升，所有相关的使用约束都会变得更紧，不利于可靠实现。</p></li>
<li><p>芯片中的 PLL 和 DLL 一般都能较好地保证某个时钟沿的 Jitter、Skew 和占空比等各种参数指标，而对于另一个时钟沿的指标控制并不是那么严格。特别对于综合、实现等 EDA 的软件，如果没有明确对另外一个沿进行相关，这个沿的时序分析不一定完善，其综合或实现结果就不一定能严格满足用户期望的时序要求（比如 Setup、Hold 时间等），往往造成在该沿操作不稳定的结果。</p></li>
</ol>
<p>总结这两点，如果设计者并不十分清楚同时使用上下沿的方法，不如直接使用同相倍频时钟更加简单、明确、可靠。但是如果设计者十分清楚同一周期使用双沿的注意事项，附加了相应的约束，这种做法并非不可。</p>
<p>针对使用两个时钟沿，在这里还想补充以下两点：</p>
<ul>
<li>使用者虽然使用了同一个时钟的两个沿，但是<strong>保证不在同一个周期内同时使用双沿，则不会增加时钟频率</strong>。</li>
<li>DDR 、QDR 本身就是利用了上下沿采样的原理，随着存储器件高速发展，时钟速度已经成为存取器件的瓶颈，所以可用时钟上下沿操作缓解对单沿 RAM 时钟振荡器的要求。但是必须清楚，硬件的 DDR、QDR 电路（包括 ASIC 的 DDR、QDR 与 FPGA 内嵌的 DDR、QDR 电路）是专用高速设计电路，对时钟的正沿、负沿的 Jitter 、Skew 和占空比等指标都有详细和明确的要求，这一点是和普通逻辑设计，特别是实现在 FPGA 中设计的情况截然不同，希望读者加以区分。</li>
</ul></li>
</ol>
<h3 id="异步时钟域数据同步常用方法">2.3.3 异步时钟域数据同步常用方法</h3>
<p>下面分别介绍 <a href="#0203">2.3 小节</a>提出的两大类异步时钟域数据同步问题的解决方法。</p>
<ol type="1">
<li><p>同频异相问题</p>
<p>同频异相问题的简单解决方法是<strong>用后级时钟对前级数据采样两次</strong>，即通常所述的<strong>用寄存器打两次</strong>。数据同步如<a href="#图5-10">图 5-10</a> 所示，这样的做法是有效地减少了亚稳态的传播，使后级电路数据都是有效电平值。但是这种做法并不能保证两级寄存器采样后的数据是正确的电平值，因为一旦 Setup 或 Hold 时间不满足，采样发生亚稳态，则经判决时间（Resolution Time）后，还是可能判决到错误电平值。所以这种方法仅仅适用于对少量错误不敏感的功能单元。</p>
<p><a name="图5-10"></a></p>
<div data-align="center">
<img data-src="https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-12-05-josh-verilog-part-5/2020-12-05-josh-verilog-part-5-100-DataSynchronization.png!sign" width="700px" alt="数据同步"/>
</div>
<p>可靠的做法是用 DPRAM 、FIFO 或者一段寄存器 Buffer 完成异步时钟域的数据转换。把数据存放在 DPRAM 或FIFO 的方法如下：将上级芯片提供的数据随路时钟作为写信号，将数据写入 DPRAM 或者FIFO, 然后使用本级的采样时钟（ 一般是数据处理的主时钟），将数据读出即可。由于时钟频率相同，所以 DPRAM 或 FIFO 两端的数据吞吐率一致，实现起来相对简单。</p></li>
<li><p>异频问题</p>
<p>可靠完成异频问题的解决方法就是使用 DPRAM 或 FIFO 。其实现思路与前面所述一致，用上级随路时钟写上级数据，然后用本级时钟读出数据。但是由于时钟频率不同，所以两个端口的数据吞吐率不一致，设计时一定要开好缓冲区，并通过监控（Full、Half、Empty 等指示）确保数据流不会溢出。</p></li>
</ol>
<h1 id="代码风格">3. 代码风格</h1>
<p>代码风格，即 Coding Style，其分为一般性 Coding Style 和针对综合工具、实现工具、器件类型的 Coding Style。</p>
<h2 id="coding-style-的分类">3.1 Coding Style 的分类</h2>
<p>所谓一般性的 Coding Style，是指不依赖于综合、实现工具和器件类型的代码风格。不同的综合实现工具对一些语法细节的阐释略有不同，特别是那些关于优先级实现的先后顺序等，所以不同的综合工具在个别细节上对 Coding Style 的解释有一定的差异。本篇笔记所述的 Coding Style，如果没有特别声明，都是不依赖于具体 EDA 工具， 一般意义上的 Coding Style，适用于不同厂商的综合实现工具和不同目标器件。</p>
<p>还有一类 Coding Style 是针对某种综合工具或者特定器件结构的，根据器件硬件结构，正确地实例化底层单元模块，合理地使用其内嵌的硬件电路，以达到最优化的设计效果。另外需要特别声明一点，一般 ASIC 设计的 Coding Style 和 PLD（主要指 FPGA 和 CPLD）设计的 Coding Style 有明显差异。这主要是因为PLD 设计是基于固有的硬件结构（如：逻辑单元、块 RAM、PLL/DLL、时钟资源等）。而 ASIC 设计结构灵活，目标多样，特别是在功耗、速度、时序等要求上，与 PLD 设计有明显差异。例如， ASIC 设计中根据要求会有意识地采样某些组合逻辑、门控时钟等降低功耗或提高速度。这里讲述的 Coding Style 和基本原则如不特殊声明，均基于 PLD 设计要求。</p>
<p>另外本篇笔记所述 Coding Style 主要是基于 RTL（寄存器传输级）而言，并非其他描述层次。所以诸如业界非常热门的结构化设计方法（Architectural-based Design）的代码风格的原则和方法与本章无关，甚至有很多原则和方法是与本章所述背道而驰的。</p>
<h2 id="coding-style-的重要性">3.2 Coding Style 的重要性</h2>
<p>当代的可编程逻辑设计日趋复杂，其系统复杂度和设计频率要求与 5 年前不可同日而语。良好的 Coding Style 对设计的工作频率，所消耗的芯片面积，甚至整个系统的稳定性都非常重要，良好规范的Coding Style 便于设计移植。</p>
<p>随着 EDA 技术的不断发展，综合、实现工具的优化能力越来越强大，可以自动完成许多复杂设计的面积和时序方面的优化，并且其优化效果日趋先进。但是如果盲目依赖综合、实现等 EDA 工具的优化，而忽略自己设计的代码风格，就大错特错了。因为 Coding Style 对综合、实现等 EDA 工具的优化结果的影响可以用这样一句话来概括：<strong>好的Coding Style 会使综合、实现等优化事半功倍，达到最优化的结果；不良的Coding Style 会使综合、实现优化南辕北辙，甚至产生错误的结果</strong>。所以必须明确：综合、实现等 EDA 工具的优化能力和正确性最终取决于设计的 Coding Style 的优劣。</p>
<p>在后面的几节中，将详细谈谈设计和代码风格。</p>
<h1 id="结构层次和模块划分">4. 结构层次和模块划分</h1>
<h2 id="结构层次化编码">4.1 结构层次化编码</h2>
<p>结构层次化编码（Hierarchical Coding）是模块化设计思想的一种体现。目前大型设计中必须采用结构层次化编码风格，以提高代码的可读性，易于模块划分，易于分工协作，易于设计仿真测试激励。最基本的结构化层次是由一个顶层模块和若干个子模块构成，每个子模块根据需要还可以包含自己的子模块。结构层次化编码结构如<a href="#图5-11">图 5-11</a> 所示。</p>
<a name="图5-11"></a>
<div data-align="center">
<pre><code>&lt;img src=&quot;https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-12-05-josh-verilog-part-5/2020-12-05-josh-verilog-part-5-110-StructuredCoding.png!sign&quot; width=&quot;500px&quot; alt=&quot;结构层次化编码示意图&quot;/&gt;</code></pre>
</div>
<p>结构层次化编码有如下注意事项：</p>
<ul>
<li><p><strong>结构的层次不易太深，一般为 3~5 层即可</strong>。在综合时， 一般综合工具为了获得更好的综合效果，特别是为了使综合结果所占用的面积更小，会默认将 RTL 代码的层次打平（Flatten）。而有时为了在综合后仿真和布局布线后的时序仿真中较方便地找出一些中间信号，比如子模块之间的接口信号等，可以在综合工具中设置保留结构层次，以便于仿真信号的查找和观察。</p></li>
<li><p><strong>顶层模块最好仅包含对所有模块的组织和调用，而不应该完成比较复杂的逻辑功能</strong>。较为合理的顶层模块由输入/输出管脚声明、模块的调用与实例化、全局时钟资源、全局置位/复位、三态缓冲和一些简单的组合逻辑等构成。</p></li>
<li><p><strong>所有的 I/O 信号，如输入、输出、双向信号等的描述在顶层模块完成。</strong></p></li>
<li><p><strong>子模块之间也可以有接口，但是最好不要建立子模块间跨层次的接口</strong>，例如，上图中模块 <code>A1</code> 到模块 <code>B1</code> 之间不宜直接连接，两者需要交换的信号可以通过模块 <code>A</code> 模块 <code>B</code> 的接口传递。这样做的好处是增加了设计的可读性和可维护性。</p></li>
<li><p>子模块的合理划分非常重要，应该综合考虑子模块的功能、结构、时序、复杂度等多方面因素。</p></li>
</ul>
<p>结构层次化编码的本质不应该简单地理解为一种具体的设计手段，而应该认识到它更是<strong>一种系统层次的设计方法</strong>。很多初学者都有这样一个疑问：一个设计完全可以在同一个模块内完整描述，为什么还要将其中的时序逻辑和组合逻辑、不同优化目标、不同功能的电路分成多级层次，使用多个模块描述呢？模块划分增加了内部接口描述的工作量，这不是“自讨苦吃“么？</p>
<p>虽然理论上任何设计都可以在同一个模块中完成，但是如果将不同功能、不同层次、不同类型的电路混淆在同一个模块中，这不是一种好的系统设计方法，对于比较复杂的设计，将会导致整个设计杂乱无章，不利于设计的阅读与维护，也会给综合和实现过程带来许多麻烦。</p>
<h2 id="模块划分的技巧">4.2 模块划分的技巧</h2>
<p>结构层次化设计方法的第一个要点就是模块划分，模块划分非常重要，关系到能否最大程度上发挥项目成员协同设计的能力，更重要的是它直接决定着设计的综合、实现的耗时与效率。模块划分的基本原则介绍如下：</p>
<ol type="1">
<li><p><strong>对每个同步时序设计的子模块的输出使用寄存器</strong></p>
<p>这也被称为用寄存器分割同步时序模块的原则。使用寄存器分割同步时序单元的好处是：便于综合工具权衡所分割的子模块中的组合电路部分和同步时序电路部分，从而达到更好的时序优化效果，这种模块划分符合时序约束的习惯，便于利用约束属性进行时序约束。</p></li>
<li><p><strong>将相关的逻辑或者可以复用的逻辑划分在同一模块内</strong></p>
<p>这个做法有时被称为<strong>呼应系统原则</strong>。这样做的好处有：一方面将相关的逻辑和可以复用的逻辑划分在同一模块，可在最大程度上复用资源，减少设计所消耗的面积；另一方面更利于综合工具优化某个具体功能的时序关键路径。其原因是，传统的综合工具只能同时优化某一部分的逻辑，而所能同时优化的逻辑的从本单元就是模块，所以将相关功能划分在同一模块将在时序和面积上获得更好的综合优化效果。</p></li>
<li><p><strong>将不同优化目标的逻辑分开</strong></p>
<p>在介绍速度、面积平衡与互换原则时，合理的设计目标应该综合考虑面积最小和频率最高两个指标。好的设计，在规划阶段设计者就应该初步规划了设计的规模和时序关键路径，并对设计的优化目标有一个整体上的把握。对于时序紧张的部分．应该独立划分为一个模块．其优化目标为“Speed”，这种划分方法便于设计者进行时序约束，也便于综合和实现工具进行优化。目前很多综合与实现工具都支持物理区域位置约束，以模块为单元进行物理区域约束，从而优化关键路径时序，以达到更高的系统工作频率就更为方便有效。另一类情况是，设计的矛盾主要集中在芯片的资源消耗上。这时应该将资源消耗过大的部分划分为独立的模块，这类模块的优化目标应该定为“Area” 。同理，将它们规划到一起，更有利于区域布局与约束。这种根据优化目标进行优化的方法最大好处是，对于某个模块综合器仅需要考虑一种优化目标和策略，从而比较容易达到较好的优化效果。相反，如果同时考虑两种优化目标，会使综合器陷入互相制约的困境，耗费巨大的综合优化时间也得不到令人满意的综合优化结果。</p></li>
<li><p><strong>将时序约束较松的逻辑归到同一模块</strong></p>
<p>有些逻辑的时序非常宽松，不需要较高的时序约束，可以将这类逻辑归入同一模块，如多周期路径（Multi-cycle Path）等。将这些模块归类，并指定宽松约束，则可以让综合器尽量节省面积资源。</p></li>
<li><p><strong>将存储逻辑独立划分成模块</strong></p>
<p>RAM、ROM、CAM 和 FIFO 等存储单元应该独立划分模块。这样做的好处是便于利用综合约束属性显化指定这些存储单元的结构和所使用的资源类型，也便于综合器将这些存储单元自动类推为指定器件的硬件原语。另一个好处是在仿真时消耗的内存也会减少，便于提高仿真速度。这是因为大多数仿真器对大面积的RAM都有独特的内存管理方式，以提高仿真效率。</p></li>
<li><p><strong>合适的模块规模</strong></p>
<p>从理论上讲，模块的规模越大，越利于模块资源共享（Resource Sharing）。但是庞大的模块，将要求对综合器同时处理更多的逻辑结构．这将对综合器的处理能力和计算机的配置提出了较高的要求。另外，庞大的模块划分，不利于发挥目前非常流行的增拭综合与实现技术的优势。</p></li>
</ol>
<h1 id="组合逻辑的注意事项">5. 组合逻辑的注意事项<a name="05"></a></h1>
<p>相对复杂一些的设计都是由两部分组成的，分别为时序逻辑（Sequential Logic）和组合逻辑（Combination Logic）。同步时序设计系统中并不是不包含组合逻辑，而是要更加合理地设计、划分组合逻辑。在以下几小节中将介绍组合逻辑设计的一些问题。</p>
<h2 id="always-组合逻辑信号敏感表">5.1 <code>always</code> 组合逻辑信号敏感表</h2>
<p>几乎所有的编码指导手册都有关于信号敏感表的论述。时序逻辑的信号敏感表比较好写，在信号敏感表中写明时钟信号的正负触发沿即可，关于信号敏感表的主要问题集中在组合逻辑的信号敏感表的写法。在此，仅强调组合逻辑的信号敏感表的相关要点：</p>
<ul>
<li><p>正确的信号敏感表设计方法是将 <code>always</code> 模块中<strong>使用到的所有输入信号和条件判断信号都列在信号敏感表中</strong>。</p></li>
<li><p>希望通过信号敏感表的增减完成某项逻辑功能是不可能的。</p></li>
<li><p>不完整的信号敏感表会造成前仿真结果和综合、实现后仿真结果不一致。</p></li>
<li><p>一般综合工具对于不完整的信号敏感表的默认做法是，将处理进程中用到的所有输入和判断条件信号都默认添加到综合结果的信号敏感表中，并对原设计代码敏感表中遗漏的信号报警告（warning）信息。</p></li>
</ul>
<p>有些初学者发现在信号敏感表中增减一些信号，会得到不同的仿真结果，于是企图依靠修改信号敏感表，而方便地完成某些逻辑的设计，这种做法是不可能的。其实一般综合工具的默认操作都是将 <code>always</code> 模块中使用到的所有输入信号和条件判断信号都当作触发信号，综合到信号敏感表中，所以增减信号敏感表，其实得到的综合结果完全一致。而增减信号敏感表，得到的仿真结果不同是因为仿真器的工作机制决定的，大多数仿真器是数据流和时钟周期驱动的，如果信号敏感表中没有某个信号，则无法触发和该信号相关的仿真进程，从而得到的仿真结果不同。</p>
<h2 id="组合逻辑环路">5.2 组合逻辑环路</h2>
<p><strong>组合逻辑反馈环路是数字同步逻辑设计的大忌</strong>，它最容易因振荡、毛刺、时序违规等引起整个系统的不稳定和不可靠。</p>
<p>典型的组合逻辑反馈环路如<a href="#图5-12">图 5-12</a> 所示，寄存器的 Q 端输出直接通过组合逻辑反馈到寄存器的异步复位端，如果 Q 输出为 0 时，经组合逻辑运算后为异步复位端有效，则电路进入不断清零的死循环。</p>
<a name="图5-12"></a>
<div data-align="center">
<pre><code>&lt;img src=&quot;https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-12-05-josh-verilog-part-5/2020-12-05-josh-verilog-part-5-120-CombinatorialLogicFeedbackLoop.png!sign&quot; width=&quot;400px&quot; alt=&quot;组合逻辑反馈环路示意图&quot;/&gt;</code></pre>
</div>
<p>组合逻辑反馈环路是一种<strong>高风险</strong>设计方式，主要原因如下：</p>
<ul>
<li><p>组合反馈环的逻辑功能完全依赖于其反馈环路上组合逻辑的门延迟和布线延迟等，如果这些传播延迟有任何改变，则该组合反馈环单元的整体逻辑功能将彻底改变，而且改变后的逻辑功能很难确定。</p></li>
<li><p><strong>组合反馈环的时序分析是无穷循环的时序计算</strong>，综合、实现等 EDA 工具迫不得已必须主动割断其时序路径，以完成相关的时序计算，而不同的 EDA 工具对组合反馈环的处理方法各不相同，所以组合反馈环的最终实现结果有很多不确定因素。</p></li>
</ul>
<p>同步时序系统中应该避免使用组合逻辑反馈环路，注意事项主要有以下两点：</p>
<ul>
<li><p>牢记<strong>任何反馈环路必须包含寄存器</strong>。</p></li>
<li><p>检查综合、实现报告的 Warning 信息，发现 Combinational Loops 后进行相应修改。</p></li>
</ul>
<h2 id="脉冲产生器">5.3 脉冲产生器</h2>
<p>在异步时序设计中，常用延时链（Delay Chains）产生脉冲，常用的异步脉冲产生方法如<a href="#图5-13">图 5-13</a> 所示。</p>
<a name="图5-13"></a>
<div data-align="center">
<pre><code>&lt;img src=&quot;https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-12-05-josh-verilog-part-5/2020-12-05-josh-verilog-part-5-130-AsynchronousPulseGeneration.png!sign&quot; width=&quot;500px&quot; alt=&quot;常用的异步脉冲产生方法示意图&quot;/&gt;</code></pre>
</div>
<p>这类异步方法设计的脉冲产生电路的脉冲宽度取决于 Delay Chains 的门延迟和线延迟，而在 FPGA/CPLD 中，大多数 Timing Driven 的综合、布线工具无法保证其布线延迟恒定。另外，PLD 器件本身在不同的 PVT（工艺、电压、温度）环境下其延时参数也有微小波动，所以脉冲宽度无法准确确定。而且 STA 工具也无法准确分析脉冲的特性，为时序仿真和验证带来了很多的不确定性。</p>
<p>异步脉冲序列产生电路（Multi-Vibrators）也被称为毛刺生成器（Glitch Generator），<strong>利用组合反馈环路振荡而不断产生毛刺</strong>。正如前面所述，组合反馈环是同步时序必须避免的．这类基于组合反馈环的 Multi-Vibrator 也会给设计带来稳定性、可靠性等方面的问题，必须避免使用。</p>
<p>同步时序设计脉冲电路的常用方法如<a href="#图5-14">图 5-14</a> 所示。该设计的脉冲宽度不因器件或设计移植而改变，恒等于时钟周期，而且避免了异步设计的诸多不确定因素，其时序路径便于计算、STA 分析和仿真验证。</p>
<a name="图5-14"></a>
<div data-align="center">
<pre><code>&lt;img src=&quot;https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-12-05-josh-verilog-part-5/2020-12-05-josh-verilog-part-5-140-SynchronousPulseGeneration.png!sign&quot; width=&quot;500px&quot; alt=&quot;常用的同步脉冲产生方法示意图&quot;/&gt;</code></pre>
</div>
<h2 id="慎用锁存器">5.4 慎用锁存器</h2>
<p>同步时序设计要尽量慎用锁存器（Latch）， 特别要注意综合出与设计意图不一致的 Latch 导致仿真和设计的错误。对于某些特定设计一定要使用 Latch 时，设计者必须明确该 Latch 是否为有意设计的。综合出与设计意图不吻合的Latch 结构的主要原因在于：在设计组合逻辑时，使用不完全的条件判断语句。如：有 <code>if</code> 而没有 <code>else</code>，或不完整的 <code>case</code> 语句等（这仅是一种可能，并不一定生成 Latch）；另外一种情况是设计中有组合逻辑的反馈环路（Combinatorial Feedback Loops）等异步逻辑。</p>
<figure class="highlight verilog"><figcaption><span>latch.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/******************************</span></span><br><span class="line"><span class="comment">因if语句不完整而产生Latch的典型情况</span></span><br><span class="line"><span class="comment">******************************/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> latch (cond_1, data_in, data_out);</span><br><span class="line"></span><br><span class="line"><span class="keyword">input</span>   cond_1;</span><br><span class="line"><span class="keyword">input</span>   data_in;</span><br><span class="line"><span class="keyword">output</span>  data_out;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</span></span><br><span class="line"><span class="keyword">reg</span>     data_out;</span><br><span class="line"></span><br><span class="line"><span class="keyword">always</span> @(cond_1 <span class="keyword">or</span> data_in) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">if</span> (cond_1)</span><br><span class="line">        data_out &lt;= data_in;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>上述描述，由于未指定在条件 <code>cond_1</code> 等于 <code>0</code> 时的动作，一般情况下会生成 Latch 结构如<a href="#图5-15">图 5-15</a> 所示。</p>
<a name="图5-15"></a>
<div data-align="center">
<pre><code>&lt;img src=&quot;https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-12-05-josh-verilog-part-5/2020-12-05-josh-verilog-part-5-150-LatchRTL.png!sign&quot; width=&quot;400px&quot; alt=&quot;Latch 的 RTL 示意图&quot;/&gt;</code></pre>
</div>
<p>防止产生非目的性的Latch 的措施如下：</p>
<ul>
<li>使用完备的 <code>if ... else</code> 语句。</li>
<li>检查设计中是否含有组合逻辑反馈环路。</li>
<li>为每个输入条件设计输出操作，对 <code>case</code> 语句设置 <code>default</code> 操作。特别是在状态机设计中，最好有一个 <code>default</code> 的状态转移，而且每个状态最好也有一个 <code>default</code> 的操作。</li>
<li>如果使用 <code>case</code> 语句时，特别是在设计状态机时，尽量附加综合约束属性，综合为完全条件 <code>case</code> 语句（full case）。目前，大多数综合工具支持 full case 的综合约束属性，具体的语法请参考综合工具的约束属性指南。</li>
</ul>
<blockquote>
<p>仔细检查综合器的综合报告，目前大多数的综合器对所综合出的 Latch 都会报“warning”， 通过综合报告可以较为方便地找出无意中生成的 Latch。</p>
</blockquote>
<h1 id="时钟设计的注意事项">6. 时钟设计的注意事项<a name="06"></a></h1>
<p>时钟是同步设计的基础，在同步设计中，所有操作都是基于时钟沿触发的，所以时钟的设计对同步时序电路而言非常重要。对于 PLD 设计，通常推荐使用 FPGA 内嵌的 PLL 或 DLL 完成时钟的频率与相位变化，并用全局时钟和专用时钟选择器进行时钟布线。对于 ASIC 设计，常会用到各种各样的组合逻辑产生的时钟，但是这些设计如果直接移植到同步时序电路中会带来各种各样的问题，本节旨在辨析一些常用的时钟电路的优劣。</p>
<h2 id="内部逻辑产生的时钟">6.1 内部逻辑产生的时钟</h2>
<p><strong>如果需要使用内部逻辑产生时钟，必须要在组合逻辑产生的时钟后插入寄存器</strong>，如<a href="#图5-16">图 5-16</a> 所示。如果直接使用组合逻辑产生的信号作为时钟信号或者异步置位/复位信号，会使设计不稳定。这是因为组合逻辑难免产生毛刺，这些毛刺到达一般数据路径，在经过寄存器采用后一般影响不大，但是如果作为时钟信号或者异步置位/复位信号时，如果毛刺的宽度足以驱动寄存器的时钟端或者异步置位/复位端，则必将产生错误的逻辑操作；即使毛刺的宽度不足以驱动时钟端或异步置位/复位端，也会带来寄存器的不稳定，甚至激发寄存器产生亚稳态。所以对于时钟路径，必须插入寄存器以过滤毛刺。</p>
<a name="图5-16"></a>
<div data-align="center">
<pre><code>&lt;img src=&quot;https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-12-05-josh-verilog-part-5/2020-12-05-josh-verilog-part-5-160-InternalClockDesignwithRegister.png!sign&quot; width=&quot;800px&quot; alt=&quot;内部时钟设计必须插入寄存器&quot;/&gt;</code></pre>
</div>
<p>另一方面，组合逻辑产生的时钟还会带来另外一个问题，组合逻辑电路的 Jitter 和 Skew 都比较大，如果时钟产生逻辑的延迟比数据路径的延迟更大，会带来负的 Skew，负的 Skew 同步逻辑设计是灾难性的。所以<strong>使用组合逻辑产生内部时钟仅适用于时钟频率较低、时钟精度要求不高的情况</strong>。另外，<strong>这类时钟应该使用快速布线资源布线，而且需要对组合逻辑电路附加一定的约束条件，以确保时钟质质量</strong>。</p>
<h2 id="ripple-counter">6.2 Ripple Counter</h2>
<p>所谓 Ripple Counter，即行波计数器，其结构为：一组寄存器级连，每个寄存器的输出端接到下一级寄存器的时钟管脚，这种计数器常常用于异步分频电路。早期的 PLD 设计经常使用 Ripple Counter 以节约芯片资源。但是由于 Ripple Counter 是一种典型的异步时序逻辑，正如前面“<a href="#0201">同步设计原则</a>”所述，异步时序逻辑会带来各种各样的时序问题，<strong>在同步时序电路设计中必须严格避免使用 Ripple Counter</strong>。</p>
<h2 id="时钟选择">6.3 时钟选择</h2>
<p>在通信系统中，为了适应不同的数据速率要求，经常要进行时钟切换。有时为了节约功耗，也会把高速时钟切换到低速时钟，或者进行时钟休眠操作。时钟切换的最佳途径是使用芯片内部的专用 Clock MUX 。这些 MUX 的反应速度快，锁定时间短，切换瞬间带来的冲击和抖动小。</p>
<p>如果所需器件没有专用的 Clock MUX，应该尽量满足如下几点：</p>
<ul>
<li>时钟切换控制逻辑在配置后将不再改变。</li>
<li>时钟切换后，对所有相关电路复位，以保证所有寄存器、状态机和 RAM 等电路的状态不会锁死或进入死循环。</li>
<li>所设计系统对时钟切换过程发生的短暂错误不敏感。</li>
</ul>
<h2 id="门控时钟">6.4 门控时钟</h2>
<p>门控时钟即 Gated Clock，如<a href="#图5-17">图 5-17</a> 所示，是 IC 设计的一种常用减少功耗的手段。通过 Gating Logic 的控制，可以控制门后端的所有寄存器不再翻转，从而非常有效地节约功耗。</p>
<a name="图5-17"></a>
<div data-align="center">
<pre><code>&lt;img src=&quot;https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-12-05-josh-verilog-part-5/2020-12-05-josh-verilog-part-5-170-GatedClock.png!sign&quot; width=&quot;800px&quot; alt=&quot;门控时钟&quot;/&gt;</code></pre>
</div>
<p>但是 Gated Clock 不是同步时序电路，其 Gating Logic（门控逻辑）会污染 Clock 的质量，通过控制门后会产生毛刺并使时钟的 Skew（偏斜）、Jitter（延时）等指标恶化。正如“<a href="#0201">同步设计原则</a>” 一节所述，在同步时序电路中，应该尽量不使用 Gated Clock 。</p>
<p>虽然有些材料指出当功耗成为主要矛盾时，可以使用门控时钟改进电路如<a href="#图5-18">图 5-18</a> 所示的电路完成类似门控时钟的功能，但是笔者仍强烈建议在 PLD 设计中不要使用该图所示的门控时钟改进电路。虽然这个改进电路已经在较大程度上解决了门控电路产生的毛刺，但是请读者注意，这个电路工作的前提是时钟源Clock 的占空比（Duty Cycle）是非常理想的 50%，如果时钟的占空比不能保证 50%，则会产生许多有规律的毛刺信号。另外这个电路还有一个前提，那就是 Clock 与 Enable 信号的不布线 Skew 为 0，否则也会造成宽度为 Skew 的毛刺。</p>
<a name="图5-18"></a>
<div data-align="center">
<pre><code>&lt;img src=&quot;https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-12-05-josh-verilog-part-5/2020-12-05-josh-verilog-part-5-180-ImprovedGatedClock.png!sign&quot; width=&quot;800px&quot; alt=&quot;门控时钟改进电路&quot;/&gt;</code></pre>
</div>
<p>如果功耗真的成为了 PLD 设计的首要问题，建议采用其他方法减少功耗。如果最近发展起来的低核电压芯片（Core 电压为 1.0V），芯片休眠功能，Clock MUX 等新技术器件能有效地节约芯片功耗。</p>
<h2 id="时钟同步使能端">6.5 时钟同步使能端</h2>
<p>大多数像寄存器这样的同步单元，都支持时钟的同步使能（Synchronous Clock Enable）。需要注意的是，虽然使能无效时这些单元无输出，但是这种方法并不能如 Gated Clock 一样减少功耗。但 Synchronous Clock Enable 却能够非常方便地完成一些逻辑功能，通过使用同步时钟使能端完成某些逻辑功能，有时可以节约芯片面积并提高设计频率。</p>
<p>同步使能端如<a href="#图5-19">图 5-19</a> 所示，上半部分是同步使能功能，在目前大多数的器件上可以直接将使能信号连接到芯片的同步使能端实现，如<a href="#图5-19">图 5-19</a> 的下半部分所示。</p>
<a name="图5-19"></a>
<div data-align="center">
<pre><code>&lt;img src=&quot;https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-12-05-josh-verilog-part-5/2020-12-05-josh-verilog-part-5-190-EnableSynchronization.png!sign&quot; width=&quot;500px&quot; alt=&quot;同步使能端&quot;/&gt;</code></pre>
</div>
<h1 id="rtl-代码优化技巧">7. RTL 代码优化技巧</h1>
<h2 id="使用-pipelining-技术优化时序">7.1 使用 Pipelining 技术优化时序</h2>
<p>Pipelining，即流水线时序优化方法，其本质是调整一个较长的组合逻辑路径中的寄存器位置，用寄存器合理分割该组合逻辑路径，从而降低了对路径的 Output 和 Setup 等时间参数的要求，达到提高设计频率的目的。但是必须要注意的是，使用 Pipelining 优化技术<strong>只能合理地调整寄存器位置，而不应该凭空增加寄存器级数</strong>，所以 Pipelining 有时也被称为 Register Balance。</p>
<p>目前一些先进的综合工具能根据用户参数配置，自动运用 Pipelining 技术，通过用寄存器平衡设计中的较长组合路径（Register Balance)，在一定程度上提高设计的工作频率。这种时序优化手段对乘法器、ROM等单元效果显著。</p>
<h2 id="模块复用与-resource-sharing">7.2 模块复用与 Resource Sharing</h2>
<p>本小节的模块复用和Resource Sharing 主要站在微观的角度观察节约面积的问题。为了便与理解，首先看两个例子。</p>
<p>这是一个补码平方器的例子，输入是 8 位补码，求其平方和。由于输入是补码，所以当最高位是 1 时，表示原值是负数，需要按位取反，加 1 后再平方；当最高位是 0 时，表示原值是正数，直接求平方。</p>
<p>第一种实现方式：</p>
<figure class="highlight verilog"><figcaption><span>resource_share1.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> resource_share1 (data_in,square);</span><br><span class="line"><span class="keyword">input</span>   [ <span class="number">7</span>:<span class="number">0</span>]  data_in;        <span class="comment">// 输入是补码</span></span><br><span class="line"><span class="keyword">output</span>  [<span class="number">15</span>:<span class="number">0</span>]  square;</span><br><span class="line"><span class="keyword">wire</span>    [ <span class="number">7</span>:<span class="number">0</span>]  data_bar;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> data_bar = ~data_in + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">assign</span> square=(data_in[<span class="number">7</span>]) ? (data_bar*data_bar) : (data_in*data_in);</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>第二种实现方式：</p>
<figure class="highlight verilog"><figcaption><span>resource_share2</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> resource_share2 (data_in,square);</span><br><span class="line"><span class="keyword">input</span>   [ <span class="number">7</span>:<span class="number">0</span>]  data_in;        <span class="comment">// 输入是补码</span></span><br><span class="line"><span class="keyword">output</span>  [<span class="number">15</span>:<span class="number">0</span>]  square;</span><br><span class="line"><span class="keyword">wire</span>    [ <span class="number">7</span>:<span class="number">0</span>]  data_tmp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> data_tmp = (data_in[<span class="number">7</span>]) ? (~data_in + <span class="number">1</span>) : data_in;</span><br><span class="line"><span class="keyword">assign</span> square = data_tmp * data_tmp;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>仔细观察一下可以发现：第一种实现方式需要两个 16 位乘法器，同时平方，然后根据输入补码的符号选择输出结果，其关键在于使用了两个乘法器，选择器在乘法器之后；第二种实现方法，首先根据输入补码的符号，换算为正数，然后平方，其关键在于选择器在乘法器之前，仅使用了一个乘法器，节约了资源。第二种实现方式与第一种实现方式相比节约的资源有两部分：第一部分，节约了一个 16 bit 乘法器；第二部分，后者的选择器是 1 bit 判断 8 bit 输出，而前者是 1 bit 判断 16 bit 输出。</p>
<p>两种代码的硬件结构示意图如<a href="#图5-20">图 5-20</a> 和图5 - 21 所示。</p>
<a name="图5-20"></a>
<div data-align="center">
<pre><code>&lt;img src=&quot;https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-12-05-josh-verilog-part-5/2020-12-05-josh-verilog-part-5-200-TwoMultipliedwithoutResourceSharing.png!sign&quot; width=&quot;&quot; alt=&quot;未Resource Sharing，2个乘法器的实现方案&quot;/&gt;</code></pre>
</div>
<a name="图5-21"></a>
<div data-align="center">
<pre><code>&lt;img src=&quot;https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-12-05-josh-verilog-part-5/2020-12-05-josh-verilog-part-5-210-OneMultipliedwithResourceSharing.png!sign&quot; width=&quot;&quot; alt=&quot;Resource Sharing，1个乘法器的实现方案&quot;/&gt;</code></pre>
</div>
<p>对于综合后的 RTL 视图，这里需要强调以下几点：</p>
<ol type="1">
<li><p>上例资源共享的单元是乘法器，通过 Resource Sharing，节省了一个乘法器和一些选择器占用的资源。其实如果拓展一下思维，将乘法器换成加法器、除法器等，甚至推广到<strong>任何一个普通的模块</strong>，后续结构含有选择器，都可以使用本例的设计思想，通过 Resource Sharing 成倍地节省前级模块所消耗的资源。</p></li>
<li><p>不同的综合工具、同一综合工具的不同版本、不同的优化参数、不同厂商的目标器件、同一厂商的不同器件族等因素都可能造成不同的综合结果。</p></li>
<li><p>目前很多综合工具都有“Resource Sharing”之类的优化参数，选择该参数，综合工具会自动考察设计中是否有可以资源共享的单元，在保证逻辑功能不变的情况下，进行 Resource Sharing，以<strong>获得面积更小的综合结果</strong>。</p></li>
<li><p>最后需要强调的是，<strong>不能因为综合工具的优化能力增强，而片面依靠综合工具放松对自己 Coding Style 的要求</strong>。这是因为：第一，综合工具的优化力度毕竟有限，很多情况下不能智能地发现需要 Resource Sharing 的逻辑；第二，前面已经说过，“不同的综合工具、同一综合工具的不同版本、不同的优化参数、不同厂商的目标器件、同一厂商的不同器件族等因素"都会直接影响综合工具的优化能力和效果，所以依靠综合工具的优化能力十分不可靠；第三，在 ASIC 设计中，综合工具非常忠于用户意图，这时 Coding Style 更加重要。所以逻辑工程师必须注意自己 Coding Style 方面的修养并不断提高。</p></li>
</ol>
<h2 id="逻辑复制">7.3 逻辑复制</h2>
<p>逻辑复制是一种通过增加面积而改善时序条件的优化手段。逻辑复制最常使用的场合是调整信号的扇出。如果某个信号需要驱动后级的很多单元，换句话说，也就是其扇出非常大，那么为了增加这个信号的驱动能力，必须插入很多级 Buffer，这样就在一定程度上增加了这个信号路径的延时。这时可以复制生成这个信号的逻辑，使多路同频同相的信号驱动后续电路，平均到每路的扇出变低，不需要加 Buffer 也能满足驱动能力的要求，这样就节约了该信号的路径时延。用逻辑复制改善扇头电路如<a href="#图5-22">图 5-22</a> 所示。</p>
<a name="图5-22"></a>
<div data-align="center">
<pre><code>&lt;img src=&quot;https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-12-05-josh-verilog-part-5/2020-12-05-josh-verilog-part-5-220-DuplicationtoImproveFanOut.png!sign&quot; width=&quot;&quot; alt=&quot;用逻辑复制改善扇出&quot;/&gt;</code></pre>
</div>
<p>需要说明的是，现在很多综合工具都可以自动设置最大扇出值（Max Fanout），如果某个信号的扇出值大于最大扇出，则该信号自动被综合工具复制。最大扇出值和器件的工艺密切相关，其合理值应该根据器件手册的声明和工程经验设置。这里举例用逻辑复制手段调整扇出，达到优化路径时延仅仅是为了讲述逻辑复制的概念，其实逻辑复制还有其他很多形式。例如，香农扩展（Shannon Expansion) 等时序优化技术，香农扩展在后面将会有详细的介绍。</p>
<p>有的读者会有疑问，逻辑复制和资源共享是两个矛盾的概念，既然使用了资源共享优化技术，为什么还要做逻辑复制呢？</p>
<p>其实这个问题的本质，还是面积与速度的平衡，<strong>逻辑复制与前面的 Resource Sharing 是两个对立统一的概念</strong>。<strong>Resource Sharing 的目的是为了节省面积资源，而逻辑复制的目的是为了提高工作频率</strong>。当使用逻辑复制手段提高工作频率的时候，必然会增加面积资源，这是与资源共享相对立的；但是正如前面介绍的面积与速度的对立统一一样，<strong>逻辑复制和资源共享都是到达设计目标的两种手段</strong>，一个侧重于速度目标，一个侧重于面积目标，两者存在一种转换与平衡的关系，所以两者又是统一的。</p>
<p>首先看下面的一个加法器资源共享的例子。</p>
<p>这个例子和前面乘法器的例子非常相似，只是将平方器换成了加法器。实现这个加法器也有两种代码写法，对应两种不同的硬件结构，资源共享如<a href="#图5-23">图 5-23</a> 所示。</p>
<a name="图5-23"></a>
<div data-align="center">
<pre><code>&lt;img src=&quot;https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-12-05-josh-verilog-part-5/2020-12-05-josh-verilog-part-5-230-ResourceSharingExample.png!sign&quot; width=&quot;700px&quot; alt=&quot;资源共享示例&quot;/&gt;</code></pre>
</div>
<p>第一种写法，对应左边的 RTL 结构示意图：</p>
<figure class="highlight verilog"><figcaption><span>mod_copy1.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> mod_copy1 (sel, a, b, c, d, data_out);</span><br><span class="line"><span class="keyword">input</span>   sel, a, b, c, d;</span><br><span class="line"><span class="keyword">output</span>  data_out;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</span></span><br><span class="line"><span class="keyword">assign</span> data_out= (sel)? (a+b) : (c+d) ;</span><br><span class="line"><span class="comment">// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>第二种写法，对应右边的 RTL 结构示意图：</p>
<figure class="highlight verilog"><figcaption><span>mod_copy2.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> mod_copy2 (sel, a, b, c, d, data_out);</span><br><span class="line"><span class="keyword">input</span>   sel, a, b, c, d;</span><br><span class="line"><span class="keyword">output</span>  data_out;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓</span></span><br><span class="line"><span class="keyword">wire</span> temp1, temp2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> temp1 = (sel) ? (a) : (c) ;</span><br><span class="line"><span class="keyword">assign</span> temp2 = (sel) ? (b) : (d) ;</span><br><span class="line"><span class="keyword">assign</span> data_out = temp1 + temp2;</span><br><span class="line"><span class="comment">// ↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>第一种写法比第二种省了一个加法器。而且第一种写法比第二种写法耗时略少一些，这在本例还不算十分明显，当运算模块不是加法器而是一些较复杂的逻辑时，会比较明显。当<strong>设计的时序满足要求，或者设计的面积紧张时，一般会采用资源共享的优化方法</strong>，将第一种设计转换为第二种设计，绝大多数情况如是；但是<strong>在某些特殊情况下，时序非常紧张，就会反其道而行之，将第二种设计转换为第一种设计</strong>，从而便于调整组合逻辑信号的到达时间，提高这个加法选择器的工作频率。</p>
<h2 id="香农扩展">7.4 香农扩展</h2>
<p>前面已经讲到，香农扩展（Shannon Expansion）也是一种逻辑复制、增加面积、提高频率的时序优化手段。</p>
<p>其定义如下，布尔逻辑可以做如下扩展： <span class="math display">\[
F\left(a,b,c\right) = aF\left(a,b,c\right) +\bar{a}F\left(a,b,c\right)
\]</span> 从上面的定义可以看到，香农扩展即布尔逻辑扩展，是卡诺逻辑化简反向运算，香农扩展相当于逻辑复制，提高频率；而卡诺逻辑化简相当于资源共享，节约面积。</p>
<p>香农扩展通过增加 MUX，从而缩短了某个优先级，但是组合路径长的信号路径时延，从而提高了该关键路径的工作频率。通过下面的例子，会对香农扩展有更全面的理解。</p>
<p>设所需的运算逻辑表达式为：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">F= (((&#123;<span class="number">8</span>&#123;late&#125;&#125; | in0) + in1) == in2) &amp; en;</span><br></pre></td></tr></table></figure>
<p>其中信号 <code>in0</code> 、<code>in1</code> 和 `<code>in2 都是 8 bit 的数据，信号</code>late<code>和信号</code>en<code>是控制信号，信号</code>late` 是本逻辑运算的关键路径信号，延时最大。</p>
<p>使用香农扩展。</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">F = late<span class="variable">.F</span>(late = <span class="number">1</span>) + ~late<span class="variable">.F</span>(late = <span class="number">0</span>)</span><br><span class="line">= late.[(((&#123;<span class="number">8</span>&#123;<span class="number">1&#x27;b1</span>&#125;&#125; | i0)+in1) == in2) &amp; en] + ~late.[(((&#123;<span class="number">8</span>&#123;<span class="number">11</span>b0&#125;&#125; | in0) + in1) == in2) &amp; en]</span><br><span class="line">= late.[(<span class="number">8&#x27;b1</span> + inl) == in2) &amp; en] + ~late[((in0 + in1) == in2) &amp; en]</span><br></pre></td></tr></table></figure>
<p>这相当于一个以 <code>late</code> 为选择信号，以 <code>[(8'b1 + in1) == in2) &amp; en]</code> 和 <code>[((in0 + in1) == in2) &amp; en]</code> 为两个输入信号的 2 选 1 的MUX 。因此， <code>late</code> 信号的优先级被提高，其信号路径的延时降低，但是其代价是设计的面积增加了，并且需要两个比较运算符。</p>
<p>未使用香农扩展的 Verilog 代码描述如下：</p>
<figure class="highlight verilog"><figcaption><span>un_shannon.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> un_shannon (in0, in1, in2, late, en, out);</span><br><span class="line"><span class="keyword">input</span>   [<span class="number">7</span>:<span class="number">0</span>]   in0, in1, in2;</span><br><span class="line"><span class="keyword">input</span>           late, en;</span><br><span class="line"><span class="keyword">output</span>          out;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> out = (((&#123;<span class="number">8</span>&#123;late&#125;&#125; | in0) + in1) == in2) &amp; en;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<a name="图5-24"></a>
<div data-align="center">
<pre><code>&lt;img src=&quot;https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-12-05-josh-verilog-part-5/2020-12-05-josh-verilog-part-5-240-BeforeShannonExtension.png!sign&quot; width=&quot;&quot; alt=&quot;未使用香农扩展前的逻辑表达式对应的RTL视图&quot;/&gt;</code></pre>
</div>
<p>从图中可以清晰地看到，未使用香农扩展时，从输入 PAD late 到输出 PAD out 之间共有4 个逻辑单元， 5 段路径。其综合结果使用了 8 个 2 输入或门，1 个 8 bit 输入加法器， 1 个 8 bit 比较器， 1 个 2 输入与门。</p>
<p>使用香农扩展的 Verilog 代码如下：</p>
<figure class="highlight verilog"><figcaption><span>shannon_fast.v</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> shannon_fast (in0, in1, in2, late, en, out);</span><br><span class="line"><span class="keyword">input</span>   [<span class="number">7</span>:<span class="number">0</span>]   in0, in1, in2;</span><br><span class="line"><span class="keyword">input</span>           late, en;</span><br><span class="line"><span class="keyword">output</span>          out;</span><br><span class="line"></span><br><span class="line"><span class="keyword">wire</span>            late_eq_0, late_eq_1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">assign</span> late_eq_0 = ((in0+in1) == in2) &amp; en;</span><br><span class="line"><span class="comment">//assign late_eq_0 = (((&#123;8&#123;1&#x27;b0&#125;&#125; | in0) + in1) == in2) &amp; en;</span></span><br><span class="line"><span class="keyword">assign</span> late_eq_1 = ((<span class="number">8&#x27;b1</span>+in1) == in2) &amp; en;</span><br><span class="line"><span class="comment">//assign late_eq_1 = (((&#123;8&#123;1&#x27;b1&#125;&#125; | in0) + in1) == in2) &amp; en;</span></span><br><span class="line"><span class="keyword">assign</span> out = (late) ? late_eq_1 : late_eq_0;</span><br><span class="line"></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<a name="图5-25"></a>
<div data-align="center">
<pre><code>&lt;img src=&quot;https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-12-05-josh-verilog-part-5/2020-12-05-josh-verilog-part-5-250-AfterShannonExtension.png!sign&quot; width=&quot;&quot; alt=&quot;香农扩展后的逻辑表达式对应的RTL视图&quot;/&gt;</code></pre>
</div>
<p>在图中可以清晰地看到，使用香农扩展后，从输入 PAD late 到输出 PAD out 之间共有 1 个逻辑单元，2 段路径。其综合结果使用了 2 个 8 bit 输入加法器， 2 个 8 bit 比较器，2 个输入与门和一个 2 输入选择器。</p>
<p>从RTL 视图可以清晰地看到，采用香农扩展后，对于 <code>late</code> 信号这一关键路径，消除了 3 个逻辑层次，从而在一定程度上提高了设计的工作频率。作为提高工作频率的代价，是多用 1 个加法器和选择器，消耗了更多的面积。由于本例十分简单，所以多消耗的 LUT 和缩短的路径时延都不十分显著，如果在复杂设计中运用香农扩展，就会取得更加显著的效果。</p>
<p>正如前面反复强调的面积和速度的平衡关系所述，<strong>是否使用香衣扩展时序优化手段，关键要看被优化对象的优化目标是面积还是路径</strong>。</p>
<h1 id="小结">8. 小结</h1>
<p><a href="#图5-26">图 5-26</a> 罗列了 RTL 编码的全面设计目标，它们是：</p>
<ul>
<li>时序（Timing）：要求设计满足预期的时序约束条件，满足预期频率要求。</li>
<li>面积（Areag）：要求设计所消耗的资源满足所规划的面积要求。</li>
<li>时钟（Clocksg）：要求设计中的时钟质量满足规划要求。</li>
<li>验证（Verificationg）：要求设计通过仿真验证的测试。</li>
<li>可测试性（DFT, Design For Testg）：要求设计时充分考量设计的可测试性。</li>
<li>可重用性（Reuseg）：希望设计便于被重用，便千继承设计成果。</li>
<li>功耗（Powerg）：要求设计的最大功耗在规定范围之内。</li>
<li>Vendor Policies（原厂的要求）：这里主要指 EDA 工具的优化测量和 PLD 或 ASIC 厂方的设计规格与软硬件需求。</li>
</ul>
<a name="图5-26"></a>
<div data-align="center">
<pre><code>&lt;img src=&quot;https://josh-blog-1257563604.cos.ap-beijing.myqcloud.com/img/2020-12-05-josh-verilog-part-5/2020-12-05-josh-verilog-part-5-260-GoalsofRTLCode.png!sign&quot; width=&quot;600px&quot; alt=&quot;RTL代码的设计目标&quot;/&gt;</code></pre>
</div>
<p>对一个 RTL 设计求全责备地要求它同时满足上述所有目标是非常困难的，应该根据这个RTL 设计的实现载体和具体应用，分析上述要求对本设计的重要性，然后综合考虑以上因素。</p>
]]></content>
      <categories>
        <category>Verilog</category>
        <category>Josh 的学习笔记</category>
        <category>Verilog</category>
      </categories>
      <tags>
        <tag>Verilog</tag>
        <tag>HDL</tag>
        <tag>RTL</tag>
        <tag>同步</tag>
        <tag>多时钟</tag>
        <tag>速度</tag>
        <tag>面积</tag>
      </tags>
  </entry>
</search>
